console.log("--- game.js started ---");

// --- DOM Elements ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const healthValueSpan = document.getElementById('healthValue');
const maxHealthValueSpan = document.getElementById('maxHealthValue');
const hungerValueSpan = document.getElementById('hungerValue');
const dayValueSpan = document.getElementById('dayValue');
const levelValueSpan = document.getElementById('levelValue');
const xpValueSpan = document.getElementById('xpValue');
const debugDiv = document.getElementById('debug');
const mainHotbarSlots = document.querySelectorAll('#hotbar .hotbar-slot');
const deathMessageDiv = document.getElementById('deathMessage');
const craftingMenuDiv = document.getElementById('craftingMenu');
const craftingMenuTitle = document.getElementById('craftingMenuTitle');
const closeCraftingButton = document.getElementById('closeCraftingButton');
const timeUIDiv = document.getElementById('timeUI');
const minionInfoBar = document.getElementById('minionInfoBar'); // Ref for minion bar
// Class Selection Elements
const classSelectionOverlay = document.getElementById('classSelectionOverlay');
const classSelect = document.getElementById('classSelect');
const startGameButton = document.getElementById('startGameButton');
// Perk Selection Elements
const levelPerkOverlay = document.getElementById('levelPerkOverlay');
const perkDescription = document.getElementById('perkDescription');
const perkChoice1Button = document.getElementById('perkChoice1Button');
const perkChoice2Button = document.getElementById('perkChoice2Button');
// Weapon Choice Elements
const weaponChoiceOverlay = document.getElementById('weaponChoiceOverlay');
const weaponChoiceTitle = document.getElementById('weaponChoiceTitle');
const weapon1Name = document.getElementById('weapon1Name');
const weapon1Desc = document.getElementById('weapon1Desc');
const weapon2Name = document.getElementById('weapon2Name');
const weapon2Desc = document.getElementById('weapon2Desc');
const weaponChoice1Button = document.getElementById('weaponChoice1Button');
const weaponChoice2Button = document.getElementById('weaponChoice2Button');
// Pet Choice Elements
const petChoiceOverlay = document.getElementById('petChoiceOverlay');
const petChoice1Button = document.getElementById('petChoice1Button');
const petChoice2Button = document.getElementById('petChoice2Button');
const petChoice3Button = document.getElementById('petChoice3Button');
const petChoice4Button = document.getElementById('petChoice4Button');
const petChoice5Button = document.getElementById('petChoice5Button');


// --- Game Settings ---
const PLAYER_SPEED = 4;
const PLAYER_RADIUS = 15;
const PLAYER_MAX_HEALTH = 100;
const PLAYER_MAX_HUNGER = 100;
const LIMB_RADIUS = 5;
const HAND_DISTANCE = PLAYER_RADIUS + 10;
const ATTACK_SWING_ARC = Math.PI / 2;
const ATTACK_DURATION = 150;
const MELEE_ATTACK_COOLDOWN = 250; // How often melee can *damage*
const INTERACT_DURATION = 100;
const ATTACK_RANGE = 60;
const BASE_ATTACK_POWER = 5;
const BASE_GATHER_POWER = 3;
const SWORD_MULTIPLIER = 2.0;
const AXE_MULTIPLIER = 3.0;
const PICKAXE_MULTIPLIER = 4.0;
const FLASH_DURATION = 100;
const ITEM_PICKUP_RANGE_SQ = (PLAYER_RADIUS + 10) * (PLAYER_RADIUS + 10);
const DROPPED_ITEM_RADIUS = 5;
const INVENTORY_COLS = 8;
const INVENTORY_ROWS = 4;
const HOTBAR_SIZE = 5;
const MAX_STACK_SIZE = 64;
const PLACE_GRID_SIZE = 20;
const PLACE_RANGE_SQ = (PLAYER_RADIUS + 60) * (PLAYER_RADIUS + 60);
const INTERACT_RANGE_SQ = (PLAYER_RADIUS + 50) * (PLAYER_RADIUS + 50);
const HEAL_AMOUNT = 25;
const BOW_COOLDOWN = 1600;
const PROJECTILE_SPEED = 8;
const PROJECTILE_RANGE = 450;
const PROJECTILE_RADIUS = 3;
const MINIMAP_WIDTH = 160;
const MINIMAP_HEIGHT = 120;
const MINIMAP_PADDING = 15;
const MINIMAP_ALPHA = 0.75;
const MINIMAP_PLAYER_COLOR = '#00FF00';
const MINIMAP_BOSS_COLOR = '#FF0000';
const MINIMAP_RESPAWN_COLOR = '#FFFF00';
const MINIMAP_PLAYER_SIZE = 3;
const BASE_XP_FOR_LEVEL_2 = 100;
const XP_LEVEL_EXPONENT = 1.5;
const MONSTER_XP_REWARD = 10;
const PLAINS_BOSS_XP_REWARD = 250;
const MINION_KILL_XP_MULTIPLIER = 0.5; // XP multiplier for minion kills
const MAX_UNDEAD_MINIONS = 10;
const MAX_SUMMONED_SLIMES = 2;

// --- World & Time Settings ---
const WORLD_WIDTH = 2000 * 10;
const WORLD_HEIGHT = 1500 * 10;
const ISLAND_PADDING = 150 * 3;
const DAY_LENGTH = 120000;
const NIGHT_START_PERCENT = 0.65;
const TRANSITION_DURATION_PERCENT = 0.08;
const SUNSET_START_PERCENT = NIGHT_START_PERCENT - TRANSITION_DURATION_PERCENT;
const SUNRISE_START_PERCENT = 1.0 - TRANSITION_DURATION_PERCENT;
const MAX_NIGHT_OPACITY = 0.75;

// --- Biome Definitions ---
const WORLD_THIRD_X = WORLD_WIDTH / 3; const WORLD_THIRD_Y = WORLD_HEIGHT / 3;
const BIOME_BOUNDS = { ROCKY_X_END: WORLD_THIRD_X, ROCKY_Y_END: WORLD_THIRD_Y, SWAMP_X_START: WORLD_WIDTH - WORLD_THIRD_X, SWAMP_Y_END: WORLD_THIRD_Y, VOLCANO_X_END: WORLD_THIRD_X, VOLCANO_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, BADLANDS_X_START: WORLD_WIDTH - WORLD_THIRD_X, BADLANDS_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, FROSTLANDS_Y_END: WORLD_THIRD_Y, DESERT_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, FOREST_X_END: WORLD_THIRD_X, JUNGLE_X_START: WORLD_WIDTH - WORLD_THIRD_X };
const WORLD_CENTER_X = WORLD_WIDTH / 2; const WORLD_CENTER_Y = WORLD_HEIGHT / 2;
const JUNGLE_LAKE = { x: BIOME_BOUNDS.JUNGLE_X_START + (WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START) * 0.15, y: BIOME_BOUNDS.FROSTLANDS_Y_END + (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END) * 0.2, width: (WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START) * 0.7, height: (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END) * 0.6, color: '#367588' };
const LAVA_POOL_COUNT = 5; const lavaPools = []; for (let i = 0; i < LAVA_POOL_COUNT; i++) { const poolWidth = (BIOME_BOUNDS.VOLCANO_X_END * 0.1) + (Math.random() * BIOME_BOUNDS.VOLCANO_X_END * 0.2); const poolHeight = ( (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START) * 0.1) + (Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START) * 0.2); lavaPools.push({ x: (Math.random() * (BIOME_BOUNDS.VOLCANO_X_END - poolWidth)), y: BIOME_BOUNDS.VOLCANO_Y_START + (Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START - poolHeight)), width: poolWidth, height: poolHeight, color: '#FF4500', lightRadius: 80 + Math.random() * 60, lightOpacity: 0.7 + Math.random() * 0.15 }); }
const WALL_THICKNESS = 15;
const WALL_COLOR = 'rgba(60, 40, 30, 0.8)';

const BIOME_DATA = {
    plains:     { color: '#A0D995', treeDensity: 0.04, rockDensity: 0.02, enemyDensity: 0.003, cactusDensity: 0, spawnMultiplier: 1.5 },
    forest:     { color: '#2E8B57', treeDensity: 0.5,  rockDensity: 0,    enemyDensity: 0.02,  cactusDensity: 0, spawnMultiplier: 3 },
    jungle:     { color: '#556B2F', treeDensity: 0.2,  rockDensity: 0.01, enemyDensity: 0.015, cactusDensity: 0, spawnMultiplier: 3 },
    frostlands: { color: '#E6E6FA', treeDensity: 0.15, rockDensity: 0.04, enemyDensity: 0.01,  cactusDensity: 0, spawnMultiplier: 2.5 },
    desert:     { color: '#EDC9AF', treeDensity: 0,    rockDensity: 0.25, enemyDensity: 0.018, cactusDensity: 0.2, spawnMultiplier: 2.5 },
    rocky:      { color: '#A9A9A9', treeDensity: 0,    rockDensity: 0.8,  enemyDensity: 0.01,  cactusDensity: 0, spawnMultiplier: 4 },
    swamp:      { color: '#6B8E23', treeDensity: 0.1,  rockDensity: 0.01, enemyDensity: 0.025, cactusDensity: 0, spawnMultiplier: 3, hasWater: true },
    volcano:    { color: '#4C4646', treeDensity: 0,    rockDensity: 0.5,  enemyDensity: 0.022, cactusDensity: 0, spawnMultiplier: 4, hasLava: true },
    badlands:   { color: '#D2B48C', treeDensity: 0,    rockDensity: 0.1,  enemyDensity: 0.025, cactusDensity: 0.05, spawnMultiplier: 3.5, hasBoneTrees: true },
};

// --- Necromancer Settings ---
const NECROMANCER_KILLS_TO_SUMMON = 5;

// --- Class Data ---
const CLASS_DATA = {
    // value: { healthMult, speedMult, swordBoost, bowBoost, lifesteal, daySpeedPenalty, killsToSummon, className }
    knight:     { healthMult: 1.0, speedMult: 1.00, swordBoost: 3.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, killsToSummon: 0,   className: 'knight' },
    archer:     { healthMult: 1.0, speedMult: 1.00, swordBoost: 1.0, bowBoost: 5.0, lifesteal: 0,   daySpeedPenalty: 1.0, killsToSummon: 0,   className: 'archer' },
    scout:      { healthMult: 0.8, speedMult: 1.75, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, killsToSummon: 0,   className: 'scout' },
    tank:       { healthMult: 3.0, speedMult: 0.80, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, killsToSummon: 0,   className: 'tank' },
    vampire:    { healthMult: 0.8, speedMult: 1.00, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 2.5, daySpeedPenalty: 0.5, killsToSummon: 0,   className: 'vampire' },
    necromancer:{ healthMult: 0.5, speedMult: 0.80, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, killsToSummon: NECROMANCER_KILLS_TO_SUMMON, className: 'necromancer' },
    summoner:   { healthMult: 0.9, speedMult: 0.90, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, killsToSummon: 0,   className: 'summoner' },
};

// --- Boss Settings ---
const PLAINS_BOSS_RADIUS = 40; const PLAINS_BOSS_HEALTH = 1000; const PLAINS_BOSS_SPEED = 1.0; const PLAINS_BOSS_DETECT_RANGE_SQ = 400 * 400; const PLAINS_BOSS_ATTACK_COOLDOWN = 1500; const PLAINS_BOSS_ATTACK_CHOICE_COOLDOWN = 3000; const BOSS_HIT_RANGE = PLAINS_BOSS_RADIUS + PLAYER_RADIUS + 10; const BOSS_HIT_DAMAGE = 25; const BOSS_SMASH_RANGE = 100; const BOSS_SMASH_DAMAGE = 35; const BOSS_SMASH_WINDUP = 800; const BOSS_SMASH_EFFECT_DURATION = 300; const BOSS_SPIN_RANGE = PLAINS_BOSS_RADIUS + 20; const BOSS_SPIN_DAMAGE = 15; const BOSS_SPIN_DURATION = 1200; const BOSS_SPIN_DAMAGE_INTERVAL = 300;
const FOREST_WOLF_RADIUS = 50; const FOREST_WOLF_BODY_LENGTH = 120; const FOREST_WOLF_BODY_WIDTH = 40; const FOREST_WOLF_HEAD_RADIUS = 30; const FOREST_WOLF_LEG_RADIUS = 10; const FOREST_WOLF_HEALTH = 200; const FOREST_WOLF_SPEED_MULT = 1.25; const FOREST_WOLF_CONTACT_DAMAGE = 90; const FOREST_WOLF_ENEMY_CONTACT_DAMAGE = 90; const FOREST_WOLF_CORNER_THRESHOLD_SQ = 100 * 100; const FOREST_WOLF_TREE_DESTROY_RADIUS = FOREST_WOLF_RADIUS + 10;
const JUNGLE_BOSS_RADIUS = 50; const JUNGLE_BOSS_HEALTH = PLAINS_BOSS_HEALTH * 2; const JUNGLE_BOSS_ATTACK_COOLDOWN = 2000; const JUNGLE_BOSS_PROJECTILE_SPEED = 6; const JUNGLE_BOSS_PROJECTILE_RANGE = 1000 * 100; const JUNGLE_BOSS_PROJECTILE_RADIUS = 8; const JUNGLE_BOSS_PROJECTILE_COLOR = '#1E90FF'; const JUNGLE_BOSS_PROJECTILE_DAMAGE = 50;

// --- Monster Settings ---
const MONSTER_SPEED = 1.8;
const MONSTER_DETECT_RANGE = 250;
const MONSTER_ATTACK_RANGE = PLAYER_RADIUS + 5;
const MONSTER_HIT_BUFFER = 5; // Extra distance for contact damage check
const MONSTER_ATTACK_COOLDOWN = 1000;
const MONSTER_DAMAGE = 10;
const INITIAL_MONSTER_COUNT = 1000;
const NIGHTLY_MONSTER_SPAWN_COUNT = 100;
const MAX_MONSTER_COUNT = 5000;
const FOREST_TREE_TARGET = 1200;
const GOLD_COIN_DROP_CHANCE = 1 / 50;

// --- Undead Minion Settings ---
const UNDEAD_RADIUS = 8;
const UNDEAD_COLOR = '#E0E0E0';
const UNDEAD_BASE_HEALTH_MULT = 0.8;
const UNDEAD_SPEED = 1.5;
const UNDEAD_ATTACK_RANGE = MONSTER_ATTACK_RANGE;
const UNDEAD_HIT_BUFFER = MONSTER_HIT_BUFFER;
const UNDEAD_ATTACK_COOLDOWN = 1200;
const UNDEAD_DAMAGE = 6;

// --- Summoned Slime Settings ---
const SUMMONED_SLIME_RADIUS = 9;
const SUMMONED_SLIME_COLOR = '#32CD32';
const SUMMONED_SLIME_HEALTH_MULT = 1.0;
const SUMMONED_SLIME_SPEED = 1.6;
const SUMMONED_SLIME_DETECT_RANGE_SQ = (MONSTER_DETECT_RANGE * 0.9) ** 2;
const SUMMONED_SLIME_ATTACK_RANGE = MONSTER_ATTACK_RANGE;
const SUMMONED_SLIME_HIT_BUFFER = MONSTER_HIT_BUFFER;
const SUMMONED_SLIME_ATTACK_COOLDOWN = 1100;
const SUMMONED_SLIME_DAMAGE = 8;
const SUMMON_FOLLOW_DISTANCE_SQ = (PLAYER_RADIUS + SUMMONED_SLIME_RADIUS + 25)**2;
const SUMMON_AGGRO_RANGE_SQ = (MONSTER_DETECT_RANGE * 1.2) ** 2;

// --- Pet Settings ---
const PET_FOLLOW_DISTANCE = PLAYER_RADIUS + 15;
const PET_RADIUS = 10;
const PET_FROG_HEAL_AMOUNT = 10;
const PET_FROG_HEAL_COOLDOWN = 30000; // 30 seconds
const PET_CAT_ATTACK_COOLDOWN = 1500;
const PET_CAT_PROJECTILE_SPEED = 7;
const PET_CAT_PROJECTILE_RANGE = 300;
const PET_CAT_PROJECTILE_RADIUS = 4;
const PET_CAT_PROJECTILE_DAMAGE = 5;
const PET_BEETLE_BLOCK_COOLDOWN = 10000; // 10 seconds
const PET_DOG_ATTACK_RANGE = PLAYER_RADIUS + PET_RADIUS + 10;
const PET_DOG_ATTACK_COOLDOWN = 800;
const PET_DOG_DAMAGE = 7;
const PET_BIRD_PICKUP_RANGE_SQ = (PLAYER_RADIUS + PET_RADIUS + 30)**2;

// --- Item Data ---
const ITEM_DATA = {
    'tree':        { color: '#654321', name: 'Tree', isPlaceable: false, health: 50, radius: 15, shape: 'circle', isSolid: true, isAttackable: true },
    'rock':        { color: '#808080', name: 'Rock', isPlaceable: false, health: 150, radius: 12, shape: 'circle', isSolid: true, isAttackable: true },
    'cactus':      { color: '#2E8B57', name: 'Cactus', isPlaceable: false, isSolid: true, isAttackable: true, radius: 10, health: 100, shape: 'cactus' },
    'bone_tree':   { color: '#EEDFCC', name: 'Bone Tree', isPlaceable: false, isSolid: true, isAttackable: true, radius: 13, health: 160, shape: 'tree', variant: 'bone'},
    'wood':         { color: '#A0522D', name: 'Wood', isPlaceable: false, shape: 'rect' },
    'stone':        { color: '#778899', name: 'Stone', isPlaceable: false, shape: 'circle' },
    'plant_fiber':  { color: '#9ACD32', name: 'Plant Fiber', isPlaceable: false, shape: 'line' },
    'monster_goop': { color: '#90EE90', name: 'Monster Goop', isPlaceable: false, shape: 'circle' },
    'gold_coin':    { color: '#FFD700', name: 'Gold Coin', isPlaceable: false, shape: 'circle' },
    'dust':         { color: '#C2B280', name: 'Dust', isPlaceable: false, shape: 'circle'},
    'stick':        { color: '#B8860B', name: 'Stick', isPlaceable: false, shape: 'line' },
    'iron_ore':     { color: '#8A867D', name: 'Iron Ore', isPlaceable: false, shape: 'circle' },
    'cobalt_ore':   { color: '#2040C0', name: 'Cobalt Ore', isPlaceable: false, shape: 'circle' },
    'mithril_ore':  { color: '#60D090', name: 'Mithril Ore', isPlaceable: false, shape: 'circle' },
    'adamantite_ore':{ color: '#B01010', name: 'Adamantite Ore', isPlaceable: false, shape: 'circle' },
    'wood_plank':   { color: '#DEB887', name: 'Wooden Plank', isPlaceable: true, solidRadius: PLACE_GRID_SIZE / 2, shape: 'rect', isSolid: true, isAttackable: true, health: 50 },
    'stone_block':  { color: '#696969', name: 'Stone Block', isPlaceable: true, solidRadius: PLACE_GRID_SIZE / 2, shape: 'rect', isSolid: true, isAttackable: true, health: 150 },
    'workbench':    { color: '#D2691E', name: 'Workbench', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect', isSolid: true, isAttackable: true, health: 100 },
    'icky_bed':     { color: '#556B2F', name: 'Icky Bed', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect', isSolid: true, isAttackable: true, health: 80 },
    'torch':        { color: '#FFA500', name: 'Torch', isPlaceable: true, isSolid: true, isAttackable: true, solidRadius: 5, health: 10, lightRadius: 120, shape: 'torch' },
    'item_upgrader_t1': { color: '#708090', name: 'Item Upgrader T1', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect', isSolid: true, isAttackable: true, health: 200 },
    'healing_salve':{ color: '#FFC0CB', name: 'Healing Salve', isPlaceable: false, isUsable: true, shape: 'circle' },
    'mystical_orb': { color: '#8A2BE2', name: 'Mystical Orb', isPlaceable: false, isUsable: true, shape: 'circle' },
    'wood_sword':   { color: '#D2B48C', name: 'Wooden Sword', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER, shape: 'sword' },
    'wood_axe':     { color: '#8B4513', name: 'Wooden Axe', isPlaceable: false, type: 'tool', toolType: 'axe', gatherMultiplier: AXE_MULTIPLIER, target: 'tree', shape: 'axe' },
    'wood_pickaxe': { color: '#A0522D', name: 'Wooden Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER, target: 'rock', shape: 'pickaxe', toolTier: 0 },
    'stone_sword':  { color: '#A9A9A9', name: 'Stone Sword', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER * 1.5, shape: 'sword' },
    'stone_axe':    { color: '#808080', name: 'Stone Axe', isPlaceable: false, type: 'tool', toolType: 'axe', gatherMultiplier: AXE_MULTIPLIER * 1.5, target: 'tree', shape: 'axe' },
    'stone_pickaxe':{ color: '#696969', name: 'Stone Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 1.5, target: 'rock', shape: 'pickaxe', toolTier: 1 },
    'iron_pickaxe': { color: '#A19D94', name: 'Iron Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 2.0, target: 'rock', shape: 'pickaxe', toolTier: 2 },
    'cobalt_pickaxe':{ color: '#3E64FF', name: 'Cobalt Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 2.7, target: 'rock', shape: 'pickaxe', toolTier: 3 },
    'mithril_pickaxe':{ color: '#93E9BE', name: 'Mithril Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 3.5, target: 'rock', shape: 'pickaxe', toolTier: 4 },
    'adamantite_pickaxe':{ color: '#E41B17', name: 'Adamantite Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 4.5, target: 'rock', shape: 'pickaxe', toolTier: 5 },
    'wooden_bow':   { color: '#CD853F', name: 'Wooden Bow', isPlaceable: false, type: 'tool', toolType: 'bow', shape: 'bow', range: 400, damage: 45 },
    'stone_reinforced_bow': { color: '#A58D71', name: 'Stone-Reinforced Bow', isPlaceable: false, type: 'tool', toolType: 'bow', shape: 'bow', range: 450, damage: 66 },
    'bone_scythe':  { color: '#F5F5DC', name: 'Bone Scythe', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER * 2, shape: 'sword'},
    'fishing_rod':  { color: '#C0C0C0', name: 'Fishing Rod', isPlaceable: false, type: 'tool', toolType: 'fishing_rod', shape: 'line' },
};

// --- Boss -> Wall Tier Mapping ---
const BOSS_WALL_TIER_MAP = { 'plains_boss': 1, };

// --- Weapon Choice Data ---
const CLASS_WEAPON_CHOICES = {
    knight: [
        { id: 'knight_greatsword', name: "Guardian's Greatsword", desc: "+25% Sword DMG, -10% Move Speed", effects: { weaponDamageMult: 1.25, weaponMoveSpeedMult: 0.90 } },
        { id: 'knight_bastion', name: "Bastion Blade", desc: "+30 Max HP, +5% Sword DMG", effects: { bonusMaxHealth: 30, weaponDamageMult: 1.05 } },
    ],
    archer: [
        { id: 'archer_longbow', name: "Swiftwood Longbow", desc: "+20% Bow DMG, +10% Range, -5% Move Speed", effects: { weaponDamageMult: 1.20, weaponRangeMult: 1.10, weaponMoveSpeedMult: 0.95 } },
        { id: 'archer_shortbow', name: "Hunter's Shortbow", desc: "+20% Bow Attack Speed, -10% Bow DMG", effects: { weaponAttackSpeedMult: 0.80, weaponDamageMult: 0.90 } },
    ],
    scout: [
        { id: 'scout_daggers', name: "Twin Daggers", desc: "+15% Atk Speed, -10% DMG", effects: { weaponAttackSpeedMult: 0.85, weaponDamageMult: 0.90 } },
        { id: 'scout_cloak', name: "Shadow Cloak", desc: "+10% Move Speed, +5 HP", effects: { weaponMoveSpeedMult: 1.10, bonusMaxHealth: 5 } }
    ],
     tank: [
         { id: 'tank_hammer', name: "Earthshaker Maul", desc: "+40 Melee DMG, -25% Atk Speed", effects: { bonusMeleeDamage: 40, weaponAttackSpeedMult: 1.25 } },
         { id: 'tank_shield', name: "Aegis Wall", desc: "+75 Max HP, -10% Move Speed", effects: { bonusMaxHealth: 75, weaponMoveSpeedMult: 0.90 } }
     ],
     vampire: [
        { id: 'vampire_rapier', name: "Blood drinker Rapier", desc: "+5% Lifesteal, +10% Atk Speed", effects: { bonusLifesteal: 0.05, weaponAttackSpeedMult: 0.90 } }, // Lifesteal is absolute value added
        { id: 'vampire_charm', name: "Nocturnal Charm", desc: "Night Speed +15%, Day Speed Penalty +10%", effects: { bonusNightSpeedMult: 1.15, bonusDaySpeedPenaltyMult: 0.90 } } // Multiplies penalty
     ],
    necromancer: [
        { id: 'necro_staff', name: "Soul Siphon Staff", desc: "Kills grant +1 HP, -5% DMG", effects: { weaponOnKillHeal: 1, weaponDamageMult: 0.95 } }, // Need on-kill hook
        { id: 'necro_tome', name: "Tome of Binding", desc: "+1 Max Undead, Undead HP -10%", effects: { bonusMaxSummons: 1, bonusUndeadHealthMult: 0.90 } } // Note: Necro uses bonusMaxSummons for Undead
    ],
    summoner: [
        { id: 'summon_catalyst', name: "Growth Catalyst", desc: "+40% Summon HP, +10% Summon DMG", effects: { bonusSummonHealthMult: 1.40, bonusSummonDamageMult: 1.10 } }, // Needs new damage mult property
        { id: 'summon_focus', name: "Swarm Focus", desc: "+1 Max Summon, -15% Summon HP", effects: { bonusMaxSummons: 1, bonusSummonHealthMult: 0.85 } }
    ],
     default: [
         { id: 'generic_sword', name: "Slightly Better Sword", desc: "+5 Melee DMG", effects: { bonusMeleeDamage: 5 } },
         { id: 'generic_boots', name: "Slightly Faster Boots", desc: "+5% Move Speed", effects: { weaponMoveSpeedMult: 1.05 } },
     ]
};

// --- Pet Data ---
const PET_DATA = {
    frog: { name: "Frog", color: '#228B22', radius: 8 },
    cat:  { name: "Cat", color: '#FFA500', radius: 9 },
    beetle: { name: "Beetle", color: '#8B4513', radius: 10 },
    bird: { name: "Bird", color: '#ADD8E6', radius: 7 },
    dog: { name: "Dog", color: '#D2B48C', radius: 11 },
};


// --- Game State ---
let mouseCanvasX = 0; let mouseCanvasY = 0;
let worldMouseX = 0; let worldMouseY = 0;
let keysPressed = {};
let resources = []; let monsters = []; let solidObjects = []; let bosses = [];
let walls = [];
let projectiles = [];
let droppedItems = [];
let undeadMinions = [];
let summonedSlimes = [];
let gameTime = 0; let dayCount = 1; let isNight = false;
let currentNightOpacity = 0;
let isGameOver = false; let isCraftingMenuOpen = false; let isUpgraderUIOpen = false;
let selectedUpgradeInput = { slotIndex: -1, source: null };
let cameraX = 0; let cameraY = 0;
let isMinimapVisible = true;
let gameHasStarted = false;
let forestWolfDefeated = false;
let gamePaused = false;
let isMouseDown = false;

// --- Player Object ---
const player = {
    x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2, radius: PLAYER_RADIUS, id: 'player',
    health: PLAYER_MAX_HEALTH, maxHealth: PLAYER_MAX_HEALTH, hunger: PLAYER_MAX_HUNGER,
    level: 1, currentXP: 0, xpToNextLevel: BASE_XP_FOR_LEVEL_2,
    monsterKillCount: 0, hasChosenLevel3Perk: false, pet: null,
    className: null, speedMultiplier: 1.0, swordMultiplierBoost: 1.0, bowMultiplierBoost: 1.0, lifesteal: 0, daySpeedPenalty: 1.0,
    // Perks
    bonusMaxHealth: 0, bonusSwordDamage: 0, bonusMeleeDamage: 0, bonusMovementSpeedMult: 1.0, bonusBowAttackSpeedMult: 1.0, bonusLifesteal: 0, bonusNightSpeedMult: 1.0, bonusDaySpeedPenaltyMult: 1.0, bonusNecromancyChance: 0, bonusUndeadHealthMult: 1.0, bonusMaxSummons: 0, bonusSummonHealthMult: 1.0, bonusSummonDamageMult: 1.0, // Added summon damage perk mult
    // Weapon Choice Effects
    chosenWeaponId: null, weaponAttackSpeedMult: 1.0, weaponDamageMult: 1.0, weaponMoveSpeedMult: 1.0, weaponRangeMult: 1.0, weaponOnKillHeal: 0, // Added weapon range/kill heal
    // Pet Timers/States
    lastPetHealTime: 0, beetleBlockCooldownTime: 0,
    // Rest
    angle: 0, isAttacking: false, attackTimer: 0, lastAttackTime: 0, isInteracting: false, interactTimer: 0,
    inventorySlots: new Array(INVENTORY_COLS * INVENTORY_ROWS).fill(null), hotbarSlots: new Array(HOTBAR_SIZE).fill(null),
    selectedHotbarSlotIndex: 0, equippedItemType: null, selectedInventoryItem: null,
    respawnX: WORLD_WIDTH / 2, respawnY: WORLD_HEIGHT / 2, lastBowShotTime: 0,
};

// --- Define Recipes ---
const recipes = [ /* ... recipes ... */ ];

// --- Define Upgrader Recipes ---
const UPGRADER_RECIPES = { /* ... */ };

// --- Utility Functions ---
function distanceSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
function distance(x1, y1, x2, y2) { return Math.sqrt(distanceSq(x1, y1, x2, y2)); }
function normalizeAngle(angle) { while (angle <= -Math.PI) angle += 2 * Math.PI; while (angle > Math.PI) angle -= 2 * Math.PI; return angle; }
function clampCamera() { const camLeft = player.x - canvas.width / 2; const camTop = player.y - canvas.height / 2; const camRight = player.x + canvas.width / 2; const camBottom = player.y + canvas.height / 2; cameraX = player.x; cameraY = player.y; if (camLeft < 0) cameraX = canvas.width / 2; if (camRight > WORLD_WIDTH) cameraX = WORLD_WIDTH - canvas.width / 2; if (camTop < 0) cameraY = canvas.height / 2; if (camBottom > WORLD_HEIGHT) cameraY = WORLD_HEIGHT - canvas.height / 2; }
function canvasToWorld(canvasX, canvasY) { const worldOriginX = cameraX - canvas.width / 2; const worldOriginY = cameraY - canvas.height / 2; return { x: canvasX + worldOriginX, y: canvasY + worldOriginY }; }
function getBiomeAt(x, y) { if (x < BIOME_BOUNDS.ROCKY_X_END && y < BIOME_BOUNDS.ROCKY_Y_END) return 'rocky'; if (x > BIOME_BOUNDS.SWAMP_X_START && y < BIOME_BOUNDS.SWAMP_Y_END) return 'swamp'; if (x < BIOME_BOUNDS.VOLCANO_X_END && y > BIOME_BOUNDS.VOLCANO_Y_START) return 'volcano'; if (x > BIOME_BOUNDS.BADLANDS_X_START && y > BIOME_BOUNDS.BADLANDS_Y_START) return 'badlands'; if (y < BIOME_BOUNDS.FROSTLANDS_Y_END) return 'frostlands'; if (y > BIOME_BOUNDS.DESERT_Y_START) return 'desert'; if (x < BIOME_BOUNDS.FOREST_X_END) return 'forest'; if (x > BIOME_BOUNDS.JUNGLE_X_START) return 'jungle'; return 'plains'; }
function formatTime(milliseconds) { if (milliseconds < 0) milliseconds = 0; const totalSeconds = Math.floor(milliseconds / 1000); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }

// --- Line Segment Intersection Helper ---
function segmentsIntersect(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    function orientation(px, py, qx, qy, rx, ry) { const val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy); if (val === 0) return 0; return (val > 0) ? 1 : 2; }
    function onSegment(px, py, qx, qy, rx, ry) { return (qx <= Math.max(px, rx) && qx >= Math.min(px, rx) && qy <= Math.max(py, ry) && qy >= Math.min(py, ry)); }
    const o1=orientation(p1x, p1y, p2x, p2y, p3x, p3y), o2=orientation(p1x, p1y, p2x, p2y, p4x, p4y), o3=orientation(p3x, p3y, p4x, p4y, p1x, p1y), o4=orientation(p3x, p3y, p4x, p4y, p2x, p2y);
    if (o1!==o2 && o3!==o4) return true; if (o1===0 && onSegment(p1x,p1y,p3x,p3y,p2x,p2y)) return true; if (o2===0 && onSegment(p1x,p1y,p4x,p4y,p2x,p2y)) return true; if (o3===0 && onSegment(p3x,p3y,p1x,p1y,p4x,p4y)) return true; if (o4===0 && onSegment(p3x,p3y,p2x,p2y,p4x,p4y)) return true; return false;
}

// --- Line of Sight Check ---
function isLineObstructed(p1x, p1y, p2x, p2y, wallArray) {
    for (const wall of wallArray) { if (!wall.isWall) continue; const wx = wall.x, wy = wall.y, ww = wall.width, wh = wall.height; const tl={x:wx,y:wy}, tr={x:wx+ww,y:wy}, bl={x:wx,y:wy+wh}, br={x:wx+ww,y:wy+wh}; if (segmentsIntersect(p1x,p1y,p2x,p2y, tl.x,tl.y, tr.x,tr.y)) return true; if (segmentsIntersect(p1x,p1y,p2x,p2y, bl.x,bl.y, br.x,br.y)) return true; if (segmentsIntersect(p1x,p1y,p2x,p2y, tl.x,tl.y, bl.x,bl.y)) return true; if (segmentsIntersect(p1x,p1y,p2x,p2y, tr.x,tr.y, br.x,br.y)) return true; } return false;
}

// --- Helper to Pick Forest Corner ---
function pickNewForestCornerTarget(wolf) {
    const corners = [ { x: 0, y: BIOME_BOUNDS.FROSTLANDS_Y_END }, { x: BIOME_BOUNDS.FOREST_X_END, y: BIOME_BOUNDS.FROSTLANDS_Y_END }, { x: 0, y: BIOME_BOUNDS.DESERT_Y_START }, { x: BIOME_BOUNDS.FOREST_X_END, y: BIOME_BOUNDS.DESERT_Y_START } ];
    let availableCorners = corners; if (wolf.targetCorner) { availableCorners = corners.filter(c => c.x !== wolf.targetCorner.x || c.y !== wolf.targetCorner.y); if (availableCorners.length === 0) availableCorners = corners; }
    const bestCorner = availableCorners[Math.floor(Math.random() * availableCorners.length)]; const offsetX = (Math.random() - 0.5) * WALL_THICKNESS * 3; const offsetY = (Math.random() - 0.5) * WALL_THICKNESS * 3;
    wolf.targetCorner = { x: Math.max(0 + wolf.radius, Math.min(BIOME_BOUNDS.FOREST_X_END - wolf.radius, bestCorner.x + offsetX)), y: Math.max(BIOME_BOUNDS.FROSTLANDS_Y_END + wolf.radius, Math.min(BIOME_BOUNDS.DESERT_Y_START - wolf.radius, bestCorner.y + offsetY)) };
    console.log(`Wolf ${wolf.id} targeting new corner: (${Math.round(wolf.targetCorner.x)}, ${Math.round(wolf.targetCorner.y)})`); wolf.lastCornerChangeTime = Date.now();
}

// --- XP and Leveling & Perk Functions ---
function calculateXPForNextLevel(currentLevel) { if (currentLevel < 1) return BASE_XP_FOR_LEVEL_2; const required = Math.floor(BASE_XP_FOR_LEVEL_2 * Math.pow(currentLevel, XP_LEVEL_EXPONENT)); return Math.max(BASE_XP_FOR_LEVEL_2, required); }
function gainXP(amount) { if (isGameOver || amount <= 0 || !gameHasStarted) return; player.currentXP += amount; console.log(`%cGained ${amount} XP! Current: ${player.currentXP}/${player.xpToNextLevel}`, "color: lightgreen;"); let leveledUp = false; while (player.currentXP >= player.xpToNextLevel) { leveledUp = true; player.level++; player.currentXP -= player.xpToNextLevel; player.xpToNextLevel = calculateXPForNextLevel(player.level); console.log(`%cLEVEL UP! Reached Level ${player.level}!`, "color: yellow; font-size: 1.2em; font-weight: bold;"); console.log(`%cNext level requires ${player.xpToNextLevel} XP. Current XP: ${player.currentXP}`, "color: lightblue;"); } if (leveledUp && player.level === 3 && !player.hasChosenLevel3Perk) { showLevel3PerkMenu(); } if (leveledUp && player.level === 5 && !player.pet) { showPetChoiceMenu(); } updateUI(); }
function showLevel3PerkMenu() { if (!levelPerkOverlay || !perkChoice1Button || !perkChoice2Button || !perkDescription) return; console.log("Showing Level 3 Perk Menu"); gamePaused = true; let choice1Text = "Perk 1"; let choice2Text = "Perk 2"; let descText = "Choose your path!"; switch (player.className) { case 'knight': choice1Text = "+20 Max HP"; choice2Text = "+15 Sword Damage"; descText = "Strengthen your Resolve or your Blade?"; break; case 'archer': choice1Text = "+10% Move Speed"; choice2Text = "+10% Bow Attack Speed"; descText = "Become Swifter or Shoot Faster?"; break; case 'scout': choice1Text = "+10 Max HP"; choice2Text = "+15 Melee Damage (All)"; descText = "Bolster your Health or Enhance All Melee Strikes?"; break; case 'tank': choice1Text = "+50 Max HP"; choice2Text = "+20 Melee Damage / -15% Speed"; descText = "Become an Immovable Object or a Destructive Force?"; break; case 'vampire': choice1Text = "+2.5 Lifesteal"; choice2Text = "+15% Move Speed"; descText = "Enhance your Vampiric Drain or gain Celerity?"; break; case 'necromancer': choice1Text = "Kills needed per Undead -1"; choice2Text = "+20% Undead Health"; descText = "Improve your Necrotic Rituals or Fortify your Minions?"; break; case 'summoner': choice1Text = "+1 Max Slime"; choice2Text = "+25% Slime Health"; descText = "Expand your Legion or Empower your existing Summons?"; break; default: console.warn("Unknown class for perk menu:", player.className); choice1Text = "Generic Perk 1"; choice2Text = "Generic Perk 2"; break; } perkDescription.textContent = descText; perkChoice1Button.textContent = choice1Text; perkChoice2Button.textContent = choice2Text; perkChoice1Button.replaceWith(perkChoice1Button.cloneNode(true)); perkChoice2Button.replaceWith(perkChoice2Button.cloneNode(true)); const newChoice1Button = document.getElementById('perkChoice1Button'); const newChoice2Button = document.getElementById('perkChoice2Button'); newChoice1Button.addEventListener('click', () => applyPerkChoice(1), { once: true }); newChoice2Button.addEventListener('click', () => applyPerkChoice(2), { once: true }); levelPerkOverlay.style.display = 'flex'; }
function applyPerkChoice(choiceIndex) { if (player.hasChosenLevel3Perk || !gameHasStarted) return; console.log(`Applying Perk Choice ${choiceIndex} for class ${player.className}`); switch (player.className) { case 'knight': if (choiceIndex === 1) { player.bonusMaxHealth += 20; } else { player.bonusSwordDamage += 15; } break; case 'archer': if (choiceIndex === 1) { player.bonusMovementSpeedMult *= 1.10; } else { player.bonusBowAttackSpeedMult *= 0.90; } break; case 'scout': if (choiceIndex === 1) { player.bonusMaxHealth += 10; } else { player.bonusMeleeDamage += 15; } break; case 'tank': if (choiceIndex === 1) { player.bonusMaxHealth += 50; } else { player.bonusMeleeDamage += 20; player.bonusMovementSpeedMult *= 0.85; } break; case 'vampire': if (choiceIndex === 1) { player.bonusLifesteal += 2.5; } else { player.bonusMovementSpeedMult *= 1.15; } break; case 'necromancer': if (choiceIndex === 1) { CLASS_DATA.necromancer.killsToSummon = Math.max(1, (CLASS_DATA.necromancer.killsToSummon || NECROMANCER_KILLS_TO_SUMMON) -1); console.log("Necromancer kills needed reduced to:", CLASS_DATA.necromancer.killsToSummon);} else { player.bonusUndeadHealthMult *= 1.20; } break; case 'summoner': if (choiceIndex === 1) { player.bonusMaxSummons += 1; } else { player.bonusSummonHealthMult *= 1.25; } break; } player.hasChosenLevel3Perk = true; levelPerkOverlay.style.display = 'none'; gamePaused = false; player.maxHealth += player.bonusMaxHealth; player.health += player.bonusMaxHealth; player.bonusMaxHealth = 0; updateUI(); console.log("Perk applied. Player stats updated."); }

// --- Weapon Choice Functions ---
function showWeaponChoiceMenu() { if (!weaponChoiceOverlay || gamePaused) return; console.log("Showing Weapon Choice Menu for class:", player.className); gamePaused = true; const choices = CLASS_WEAPON_CHOICES[player.className] || CLASS_WEAPON_CHOICES.default; weaponChoiceTitle.textContent = "Choose Your Weapon"; weapon1Name.textContent = choices[0].name; weapon1Desc.textContent = choices[0].desc; weapon2Name.textContent = choices[1].name; weapon2Desc.textContent = choices[1].desc; weaponChoice1Button.dataset.weaponId = choices[0].id; weaponChoice2Button.dataset.weaponId = choices[1].id; weaponChoice1Button.replaceWith(weaponChoice1Button.cloneNode(true)); weaponChoice2Button.replaceWith(weaponChoice2Button.cloneNode(true)); document.getElementById('weaponChoice1Button').addEventListener('click', handleWeaponChoice, { once: true }); document.getElementById('weaponChoice2Button').addEventListener('click', handleWeaponChoice, { once: true }); weaponChoiceOverlay.style.display = 'flex'; }
function handleWeaponChoice(event) { const chosenWeaponId = event.target.dataset.weaponId; console.log("Weapon chosen:", chosenWeaponId); let chosenWeaponData = null; for (const classKey in CLASS_WEAPON_CHOICES) { const weapon = CLASS_WEAPON_CHOICES[classKey].find(w => w.id === chosenWeaponId); if (weapon) { chosenWeaponData = weapon; break; } } if (chosenWeaponData) { applyWeaponEffects(chosenWeaponData); player.chosenWeaponId = chosenWeaponId; const orbSlotIndex = player.inventorySlots.findIndex(slot => slot && slot.type === 'mystical_orb') ?? player.hotbarSlots.findIndex(slot => slot && slot.type === 'mystical_orb'); if (orbSlotIndex !== -1) { if (player.inventorySlots[orbSlotIndex]?.type === 'mystical_orb') removeFromInventory('mystical_orb', 1); else decrementHotbarItem(orbSlotIndex); } else { console.warn("Mystical Orb not found after choosing weapon?"); } } else { console.error("Could not find chosen weapon data for ID:", chosenWeaponId); } weaponChoiceOverlay.style.display = 'none'; gamePaused = false; updateUI(); }
function applyWeaponEffects(weaponData) { console.log("Applying effects for:", weaponData.name); player.weaponAttackSpeedMult = 1.0; player.weaponDamageMult = 1.0; player.weaponMoveSpeedMult = 1.0; player.weaponRangeMult = 1.0; player.weaponOnKillHeal = 0; for (const effect in weaponData.effects) { console.log(` - Applying ${effect}: ${weaponData.effects[effect]}`); switch (effect) { case 'weaponDamageMult': player.weaponDamageMult *= weaponData.effects[effect]; break; case 'weaponAttackSpeedMult': player.weaponAttackSpeedMult *= weaponData.effects[effect]; break; case 'weaponMoveSpeedMult': player.bonusMovementSpeedMult *= weaponData.effects[effect]; break; case 'bonusMaxHealth': player.maxHealth += weaponData.effects[effect]; player.health += weaponData.effects[effect]; break; case 'bonusMeleeDamage': player.bonusMeleeDamage += weaponData.effects[effect]; break; case 'weaponRangeMult': player.weaponRangeMult *= weaponData.effects[effect]; break; case 'weaponOnKillHeal': player.weaponOnKillHeal += weaponData.effects[effect]; break; } } player.health = Math.min(player.health, player.maxHealth); }

// --- Pet Choice Functions ---
function showPetChoiceMenu() { if (!petChoiceOverlay || gamePaused || player.pet) return; console.log("Showing Pet Choice Menu"); gamePaused = true; petChoice1Button.textContent = PET_DATA.frog.name; petChoice2Button.textContent = PET_DATA.cat.name; petChoice3Button.textContent = PET_DATA.beetle.name; petChoice4Button.textContent = PET_DATA.bird.name; petChoice5Button.textContent = PET_DATA.dog.name; const buttons = [petChoice1Button, petChoice2Button, petChoice3Button, petChoice4Button, petChoice5Button]; const petTypes = ['frog', 'cat', 'beetle', 'bird', 'dog']; buttons.forEach((button, index) => { const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button); newButton.addEventListener('click', () => applyPetChoice(petTypes[index]), { once: true }); }); petChoiceOverlay.style.display = 'flex'; }
function applyPetChoice(petType) { if (player.pet || !gameHasStarted) return; console.log("Pet chosen:", petType); const petBaseData = PET_DATA[petType]; player.pet = { type: petType, name: petBaseData.name, color: petBaseData.color, radius: petBaseData.radius, x: player.x - player.radius - PET_RADIUS, y: player.y, target: null, lastAttackTime: 0, lastHealTime: 0, blockReady: true, lastBlockTime: 0, projectileCooldown: 0 }; petChoiceOverlay.style.display = 'none'; gamePaused = false; updateUI(); }

// --- Item Handling Functions ---
function findFirstEmptyInventorySlot() { return player.inventorySlots.findIndex(slot => slot === null); }
function findItemStackableInventorySlot(itemType) { return player.inventorySlots.findIndex(slot => slot !== null && slot.type === itemType && slot.count < MAX_STACK_SIZE); }
function addDroppedItem(x, y, type, count = 1) { for (let i = 0; i < count; i++) { const offsetX = (Math.random() - 0.5) * 15; const offsetY = (Math.random() - 0.5) * 15; droppedItems.push({ id: `item_${Date.now()}_${Math.random()}`, x: x + offsetX, y: y + offsetY, type: type, radius: DROPPED_ITEM_RADIUS, spawnTime: Date.now() }); } }
function addToInventory(itemType, count = 1) { let rem=count; while(rem>0){const idx=findItemStackableInventorySlot(itemType); if(idx!==-1){const slot=player.inventorySlots[idx]; const add=Math.min(rem,MAX_STACK_SIZE-slot.count); slot.count+=add; rem-=add;}else{break;}} while(rem>0){const idx=findFirstEmptyInventorySlot(); if(idx!==-1){const add=Math.min(rem,MAX_STACK_SIZE); player.inventorySlots[idx]={type:itemType, count:add}; rem-=add;}else{console.warn(`Inv full! Cannot add ${rem} ${itemType}.`); rem=0; break;}} if(isCraftingMenuOpen){populateCraftingMenu(isNearWorkbench(), isNearUpgrader());} updateMainHotbarVisuals();}
function removeFromInventory(itemType, count = 1) { let rem=count; let removed=0; for(let i=0; i<player.inventorySlots.length && rem>0; i++){const slot=player.inventorySlots[i]; if(slot && slot.type===itemType){const remSlot=Math.min(rem,slot.count); slot.count-=remSlot; rem-=remSlot; removed+=remSlot; if(slot.count<=0){player.inventorySlots[i]=null;}}} /* Check hotbar if needed */ if(removed>0){if(isCraftingMenuOpen){populateCraftingMenu(isNearWorkbench(), isNearUpgrader());} updateMainHotbarVisuals();} return rem <= 0; }
function getTotalItemCount(itemType) { const invCount=player.inventorySlots.reduce((t,s)=>(s&&s.type===itemType?t+s.count:t),0); const hotbarCount=player.hotbarSlots.reduce((t,s)=>(s&&s.type===itemType?t+s.count:t),0); return invCount+hotbarCount; }

// --- Crafting Functions ---
function canCraft(recipe) { for (const itemId in recipe.input) { if (getTotalItemCount(itemId) < recipe.input[itemId]) return false; } return true; }
function doCraft(recipeId) { const recipe = recipes.find(r => r.id === recipeId); if (!recipe) return; if (canCraft(recipe)) { let success = true; const ingredientsToRemove = { ...recipe.input }; for (const itemId in ingredientsToRemove) { if (!removeFromInventory(itemId, ingredientsToRemove[itemId])) { success = false; break; } } if (success) { addToInventory(recipe.output.type, recipe.output.count); console.log(`%cCrafted ${recipe.output.count}x ${recipe.output.type}!`, 'color: cyan; font-weight: bold;'); if (isCraftingMenuOpen) populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } else { console.error(`Crafting failed for ${recipe.name} due to ingredient removal issue.`); } } else { console.log(`Cannot craft ${recipe.name} - missing ingredients.`); } }

// --- UI Interaction ('E' Menu - Item Moving) ---
function handleInventorySlotClick(index) { const clickedSlot = player.inventorySlots[index]; const selected = player.selectedInventoryItem; if (selected) { const originalSourceSlot = selected.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; originalSourceSlot[selected.index] = clickedSlot; player.inventorySlots[index] = { type: selected.type, count: selected.count }; player.selectedInventoryItem = null; } else if (clickedSlot) { player.selectedInventoryItem = { index: index, type: clickedSlot.type, count: clickedSlot.count, source: 'inventory' }; } populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); updateMainHotbarVisuals(); }
function handleHotbarSlotClick(index) { const clickedSlot = player.hotbarSlots[index]; const selected = player.selectedInventoryItem; if (selected) { const originalSourceSlot = selected.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; originalSourceSlot[selected.index] = clickedSlot; player.hotbarSlots[index] = { type: selected.type, count: selected.count }; player.selectedInventoryItem = null; } else if (clickedSlot) { player.selectedInventoryItem = { index: index, type: clickedSlot.type, count: clickedSlot.count, source: 'hotbar' }; } populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); updateMainHotbarVisuals(); updateEquippedItem(); }
function drawItemShape(ctx, itemType, size) { const itemData = ITEM_DATA[itemType]; if (!itemData) { ctx.fillStyle='magenta'; ctx.fillRect(size*0.1,size*0.1,size*0.8,size*0.8); ctx.strokeStyle='black'; ctx.lineWidth=1; ctx.strokeRect(size*0.1,size*0.1,size*0.8,size*0.8); ctx.beginPath();ctx.moveTo(size*0.1,size*0.1);ctx.lineTo(size*0.9,size*0.9);ctx.moveTo(size*0.9,size*0.1);ctx.lineTo(size*0.1,size*0.9);ctx.stroke(); return; } ctx.save(); ctx.translate(size/2, size/2); ctx.fillStyle=itemData.color||'#FFF'; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; const scale=size/30; ctx.scale(scale,scale); const shapeSize=18; switch(itemData.shape){ case 'line': ctx.beginPath();ctx.moveTo(0,-shapeSize*0.6);ctx.lineTo(0,shapeSize*0.6);ctx.lineWidth=3*scale>1?3:1/scale;ctx.stroke();break; case 'rect': ctx.fillRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);ctx.strokeRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);break; case 'torch': { const sH=shapeSize*1.0,sW=shapeSize*0.2,fH=shapeSize*0.5; ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-sW/2,sH*0.1,sW,sH*0.9); ctx.fillStyle=itemData.color;ctx.beginPath();ctx.ellipse(0,-sH*0.25,sW*1.5,fH,0,0,Math.PI*2);ctx.fill(); break;} case 'sword': { const swH=shapeSize*1.3,swW=shapeSize*0.15,gW=shapeSize*0.4; ctx.fillStyle='#444';ctx.fillRect(-swW*1.2,swH*0.2,swW*2.4,swH*0.2); ctx.fillStyle='#888';ctx.fillRect(-gW/2,swH*0.1,gW,swW*2); ctx.fillStyle=itemData.color;ctx.beginPath();ctx.moveTo(0,-swH*0.4);ctx.lineTo(-swW,swH*0.1);ctx.lineTo(swW,swH*0.1);ctx.closePath();ctx.fill();ctx.stroke(); break;} case 'axe': case 'pickaxe': { const hH=shapeSize*1.2,hW=shapeSize*0.15,hdW=shapeSize*0.6,hdH=shapeSize*0.4; ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-hW/2,-hH/2+hdH/2,hW,hH);ctx.strokeRect(-hW/2,-hH/2+hdH/2,hW,hH); ctx.fillStyle=itemData.color;ctx.fillRect(-hdW/2,-hH/2,hdW,hdH);ctx.strokeRect(-hdW/2,-hH/2,hdW,hdH); break;} case 'bow': ctx.beginPath();ctx.moveTo(0,-shapeSize*0.6);ctx.quadraticCurveTo(-shapeSize*0.7,0,0,shapeSize*0.6);ctx.quadraticCurveTo(shapeSize*0.7,0,0,-shapeSize*0.6); ctx.moveTo(-shapeSize*0.1,-shapeSize*0.5);ctx.lineTo(-shapeSize*0.1,shapeSize*0.5);ctx.lineWidth=1*scale>0.5?1:0.5/scale;ctx.strokeStyle='#eee';ctx.stroke(); ctx.lineWidth=3*scale>1?3:1/scale;ctx.strokeStyle='rgba(0,0,0,0.6)';ctx.stroke();ctx.fill();break; case 'cactus': const cW=shapeSize*0.4,cH=shapeSize*1.3; ctx.fillRect(-cW/2,-cH/2,cW,cH);ctx.fillRect(-cW*1.2,-cH*0.1,cW*2.4,cW*0.6);ctx.strokeStyle='darkgreen';ctx.strokeRect(-cW/2,-cH/2,cW,cH);break; case 'circle': default: ctx.beginPath();ctx.arc(0,0,shapeSize*0.4,0,Math.PI*2);ctx.fill();ctx.stroke();break; } ctx.restore(); }
function populateCraftingMenu(isNearWorkbench, isNearUpgrader) { if (!craftingMenuDiv) return; const invGrid=document.getElementById('inventoryGrid');const hotbarGrid=document.getElementById('hotbarGrid');const playerRecipeList=document.getElementById('recipeList');const workbenchCtxDiv=document.getElementById('workbenchContext');const upgraderCtxDiv=document.getElementById('upgraderContext');const workbenchRecipeList=document.getElementById('workbenchRecipeList'); if (!invGrid||!hotbarGrid||!playerRecipeList||!workbenchCtxDiv||!upgraderCtxDiv||!workbenchRecipeList) { console.error("Missing UI elements for combined crafting menu!"); return; } invGrid.style.setProperty('--inventory-cols',INVENTORY_COLS); hotbarGrid.style.setProperty('--hotbar-size',HOTBAR_SIZE); const createSlotCanvas=(item)=>{const canvas=document.createElement('canvas');canvas.width=40;canvas.height=40;canvas.classList.add('item-icon');const itemCtx=canvas.getContext('2d');if(item&&item.type){drawItemShape(itemCtx,item.type,canvas.width);}return canvas;}; invGrid.innerHTML=''; player.inventorySlots.forEach((item,index)=>{const slotDiv=document.createElement('div');slotDiv.classList.add('inventory-slot');slotDiv.dataset.index=index; if(item){const itemData=ITEM_DATA[item.type]||{name:item.type};slotDiv.title=itemData.name;slotDiv.appendChild(createSlotCanvas(item));if(item.count>1){const countSpan=document.createElement('span');countSpan.classList.add('item-count');countSpan.textContent=item.count;slotDiv.appendChild(countSpan);}} if(player.selectedInventoryItem&&player.selectedInventoryItem.source==='inventory'&&player.selectedInventoryItem.index===index){slotDiv.classList.add('selected-for-move');if(item)slotDiv.style.opacity='0.5';} slotDiv.addEventListener('click',()=>handleInventorySlotClick(index)); invGrid.appendChild(slotDiv);}); hotbarGrid.innerHTML=''; player.hotbarSlots.forEach((item,index)=>{const slotDiv=document.createElement('div');slotDiv.classList.add('hotbar-menu-slot');slotDiv.dataset.index=index; if(item){const itemData=ITEM_DATA[item.type]||{name:item.type};slotDiv.title=itemData.name;slotDiv.appendChild(createSlotCanvas(item));if(item.count>1){const countSpan=document.createElement('span');countSpan.classList.add('item-count');countSpan.textContent=item.count;slotDiv.appendChild(countSpan);}} if(player.selectedInventoryItem&&player.selectedInventoryItem.source==='hotbar'&&player.selectedInventoryItem.index===index){slotDiv.classList.add('selected-for-move');if(item)slotDiv.style.opacity='0.5';} slotDiv.addEventListener('click',()=>handleHotbarSlotClick(index)); hotbarGrid.appendChild(slotDiv);}); playerRecipeList.innerHTML=''; const playerRecipes=recipes.filter(r=>!r.requiresWorkbench); if(playerRecipes.length===0){playerRecipeList.innerHTML=`<li>No player recipes available.</li>`;} else {playerRecipes.forEach(recipe=>{const li=document.createElement('li');const canCurrentlyCraft=canCraft(recipe);let ingredientsHTML=''; for(const itemId in recipe.input){const req=recipe.input[itemId];const owned=getTotalItemCount(itemId);const missingCls=owned<req?'missing':'';const itemName=(ITEM_DATA[itemId]?.name||itemId).replace(/_/g,' ');ingredientsHTML+=`<span class="ingredient ${missingCls}">${itemName}: ${owned}/${req}</span>`;} li.innerHTML=`<div><strong>${recipe.name}</strong><div class="recipe-details">${ingredientsHTML}</div></div><button data-recipe-id="${recipe.id}" ${canCurrentlyCraft?'':'disabled'}>Craft</button>`; const craftBtn=li.querySelector('button');if(craftBtn){craftBtn.addEventListener('click',()=>{doCraft(recipe.id);});} playerRecipeList.appendChild(li);});} workbenchRecipeList.innerHTML=''; if(isNearWorkbench){populateWorkbenchRecipes(workbenchRecipeList);} if(isNearUpgrader){populateUpgraderUI();}else{const upIn=document.getElementById('upgraderInputSlot');const upMat=document.getElementById('upgraderMaterialSlot');const upOut=document.getElementById('upgraderOutputSlot');const upBtn=document.getElementById('upgradeItemButton');if(upIn)upIn.innerHTML='';if(upMat)upMat.innerHTML='';if(upOut)upOut.innerHTML='';if(upBtn)upBtn.disabled=true;selectedUpgradeInput={slotIndex:-1,source:null};} }
function toggleCraftingMenu() { if (!gameHasStarted) return; isCraftingMenuOpen = !isCraftingMenuOpen; if (isCraftingMenuOpen) { gamePaused = true; const nearUpgrader = isNearUpgrader(); const nearWorkbench = !nearUpgrader && isNearWorkbench(); let context = 'player'; let title = 'Crafting'; let activeClass = ''; if (nearUpgrader) { context = 'upgrader'; title = 'Item Upgrader'; activeClass = 'upgrader-active'; } else if (nearWorkbench) { context = 'workbench'; title = 'Workbench Crafting'; activeClass = 'workbench-active'; } populateCraftingMenu(nearWorkbench, nearUpgrader); craftingMenuDiv.className = 'active ' + activeClass; craftingMenuDiv.style.display = 'flex'; craftingMenuTitle.textContent = title; } else { craftingMenuDiv.style.display = 'none'; craftingMenuDiv.className = ''; if (player.selectedInventoryItem) { player.selectedInventoryItem = null; } if (selectedUpgradeInput.slotIndex !== -1) selectedUpgradeInput = { slotIndex: -1, source: null }; gamePaused = false; } }
craftingMenuDiv.addEventListener('click', (event) => { if (event.target === craftingMenuDiv && isCraftingMenuOpen) { toggleCraftingMenu(); } });
function isNearWorkbench() { for (const obj of solidObjects) { if (obj.isPlaced && obj.type === 'workbench' && distanceSq(player.x,player.y,obj.x,obj.y)<INTERACT_RANGE_SQ && distanceSq(player.x,player.y,obj.x,obj.y)>(player.radius+obj.radius-5)**2) return true; } return false; }
function isNearUpgrader() { for (const obj of solidObjects) { if (obj.isPlaced && obj.type === 'item_upgrader_t1' && distanceSq(player.x,player.y,obj.x,obj.y)<INTERACT_RANGE_SQ && distanceSq(player.x,player.y,obj.x,obj.y)>(player.radius+obj.radius-5)**2) return true; } return false; }
function findUpgradeableTool() { const types=['wood_sword','wood_axe','wood_pickaxe','wooden_bow']; for(let i=0;i<player.hotbarSlots.length;i++){const item=player.hotbarSlots[i];if(item&&types.includes(item.type)&&UPGRADER_RECIPES[item.type]){return {item,index:i,source:'hotbar'};}} for(let i=0;i<player.inventorySlots.length;i++){const item=player.inventorySlots[i];if(item&&types.includes(item.type)&&UPGRADER_RECIPES[item.type]){return {item,index:i,source:'inventory'};}} return null; }
function populateWorkbenchRecipes(listElement) { if(!listElement) return; listElement.innerHTML=''; const availableRecipes=recipes.filter(r=>r.requiresWorkbench===true); if(availableRecipes.length===0){listElement.innerHTML=`<li>No workbench recipes available yet.</li>`;}else{availableRecipes.forEach(recipe=>{const li=document.createElement('li');const canCurrentlyCraft=canCraft(recipe);let ingredientsHTML=''; for(const itemId in recipe.input){const req=recipe.input[itemId];const owned=getTotalItemCount(itemId);const missingCls=owned<req?'missing':'';const itemName=(ITEM_DATA[itemId]?.name||itemId).replace(/_/g,' ');ingredientsHTML+=`<span class="ingredient ${missingCls}">${itemName}: ${owned}/${req}</span>`;} li.innerHTML=`<div><strong>${recipe.name}</strong><div class="recipe-details">${ingredientsHTML}</div></div><button data-recipe-id="${recipe.id}" ${canCurrentlyCraft?'':'disabled'}>Craft</button>`; const craftBtn=li.querySelector('button');if(craftBtn){craftBtn.addEventListener('click',()=>{doCraft(recipe.id);});} listElement.appendChild(li);});}}
function populateUpgraderUI() { const inputSlotDiv=document.getElementById('upgraderInputSlot'); const materialSlotDiv=document.getElementById('upgraderMaterialSlot'); const outputSlotDiv=document.getElementById('upgraderOutputSlot'); const upgradeBtn=document.getElementById('upgradeItemButton'); if(!inputSlotDiv||!materialSlotDiv||!outputSlotDiv||!upgradeBtn){console.error("Missing Upgrader UI elements");return;} const createSlotCanvas=(item)=>{const c=document.createElement('canvas');c.width=40;c.height=40;c.classList.add('item-icon');const ctx=c.getContext('2d');if(item&&item.type){drawItemShape(ctx,item.type,c.width);}return c;}; inputSlotDiv.innerHTML='(Click Tool)';inputSlotDiv.style.opacity='0.5';inputSlotDiv.classList.remove('has-item'); materialSlotDiv.innerHTML='(Material)';materialSlotDiv.style.opacity='0.5';materialSlotDiv.classList.remove('has-item'); outputSlotDiv.innerHTML='(Result)';outputSlotDiv.style.opacity='0.5';outputSlotDiv.classList.remove('has-item'); upgradeBtn.disabled=true; if(!inputSlotDiv.dataset.listenerAdded){inputSlotDiv.addEventListener('click',handleUpgraderInputClick);inputSlotDiv.dataset.listenerAdded='true';} let currentInputItem=null; if(selectedUpgradeInput.slotIndex!==-1&&selectedUpgradeInput.source){const srcArr=selectedUpgradeInput.source==='inventory'?player.inventorySlots:player.hotbarSlots;currentInputItem=srcArr[selectedUpgradeInput.slotIndex];} if(currentInputItem){inputSlotDiv.innerHTML='';inputSlotDiv.appendChild(createSlotCanvas(currentInputItem));inputSlotDiv.style.opacity='1';inputSlotDiv.classList.add('has-item');const upgradeRecipe=UPGRADER_RECIPES[currentInputItem.type];if(upgradeRecipe){materialSlotDiv.innerHTML='';const materialItem={type:upgradeRecipe.material,count:upgradeRecipe.materialCount};materialSlotDiv.appendChild(createSlotCanvas(materialItem));const countSpanMat=document.createElement('span');countSpanMat.classList.add('item-count');countSpanMat.textContent=upgradeRecipe.materialCount;materialSlotDiv.appendChild(countSpanMat);materialSlotDiv.style.opacity='1';materialSlotDiv.classList.add('has-item');outputSlotDiv.innerHTML='';const outputItem={type:upgradeRecipe.output,count:1};outputSlotDiv.appendChild(createSlotCanvas(outputItem));outputSlotDiv.style.opacity='1';outputSlotDiv.classList.add('has-item');const hasMats=getTotalItemCount(upgradeRecipe.material)>=upgradeRecipe.materialCount;upgradeBtn.disabled=!hasMats;}else{outputSlotDiv.innerHTML='(Invalid)';upgradeBtn.disabled=true;}}else{upgradeBtn.disabled=true;} }
function handleUpgraderInputClick() { const selected=player.selectedInventoryItem; if(selected){const itemType=selected.type;if(UPGRADER_RECIPES[itemType]){selectedUpgradeInput.slotIndex=selected.index;selectedUpgradeInput.source=selected.source;player.selectedInventoryItem=null;populateCraftingMenu(false,true);}}else if(selectedUpgradeInput.slotIndex!==-1){selectedUpgradeInput={slotIndex:-1,source:null};populateCraftingMenu(false,true);} }
function doUpgrade() { if(selectedUpgradeInput.slotIndex===-1||!selectedUpgradeInput.source){console.warn("No tool selected to upgrade.");return;} const srcArr=selectedUpgradeInput.source==='inventory'?player.inventorySlots:player.hotbarSlots;const toolToUpgrade=srcArr[selectedUpgradeInput.slotIndex]; if(!toolToUpgrade){console.error("Selected tool disappeared?");selectedUpgradeInput={slotIndex:-1,source:null};populateCraftingMenu(false,true);return;} const upgradeRecipe=UPGRADER_RECIPES[toolToUpgrade.type]; if(!upgradeRecipe){console.error("Upgrade recipe inconsistency.");return;} if(getTotalItemCount(upgradeRecipe.material)>=upgradeRecipe.materialCount){const removedMat=removeFromInventory(upgradeRecipe.material,upgradeRecipe.materialCount); let removedTool=false; if(selectedUpgradeInput.source==='inventory'){player.inventorySlots[selectedUpgradeInput.slotIndex]=null;removedTool=true;}else if(selectedUpgradeInput.source==='hotbar'){player.hotbarSlots[selectedUpgradeInput.slotIndex]=null;removedTool=true;updateMainHotbarVisuals();updateEquippedItem();} if(removedMat&&removedTool){addToInventory(upgradeRecipe.output,1);console.log(`%cUpgraded to ${upgradeRecipe.name}!`, "color: lightblue; font-weight: bold;");selectedUpgradeInput={slotIndex:-1,source:null};populateCraftingMenu(false,true);}else{console.error("Failed to remove resources during upgrade attempt.");}}else{console.warn(`Not enough ${upgradeRecipe.material} (button click).`);} }
const integratedUpgradeButton = document.getElementById('upgradeItemButton'); if (integratedUpgradeButton) integratedUpgradeButton.addEventListener('click', doUpgrade);
function updateMainHotbarVisuals() { mainHotbarSlots.forEach((slotDiv,index)=>{const item=player.hotbarSlots[index];const existingIcon=slotDiv.querySelector('.item-icon');const existingCount=slotDiv.querySelector('.item-count');if(existingIcon)slotDiv.removeChild(existingIcon);if(existingCount)slotDiv.removeChild(existingCount);let numSpan=slotDiv.querySelector('span');if(!numSpan){numSpan=document.createElement('span');numSpan.style.opacity='0.5';numSpan.style.position='absolute';numSpan.style.top='5px';numSpan.style.left='5px';numSpan.style.zIndex='-1';numSpan.textContent=`${index+1}`;slotDiv.appendChild(numSpan);} if(item){const itemCanvas=document.createElement('canvas');itemCanvas.width=35;itemCanvas.height=35;itemCanvas.classList.add('item-icon');itemCanvas.style.pointerEvents='none';const itemCtx=itemCanvas.getContext('2d');if(item.type){drawItemShape(itemCtx,item.type,itemCanvas.width);} slotDiv.appendChild(itemCanvas);if(item.count>1){const countSpan=document.createElement('span');countSpan.classList.add('item-count');countSpan.textContent=item.count;slotDiv.appendChild(countSpan);}}}); }

// --- Collision Detection ---
function checkCollision(entityRadius, potentialX, potentialY, ignoreId = null, checkAgainst = [...solidObjects, ...monsters, ...bosses, ...undeadMinions, ...summonedSlimes, player]) {
    for (const solid of checkAgainst) {
        if (solid && solid.id !== ignoreId && (solid.isWall || solid.health > 0 || solid.id === player.id)) { // Include player collision check
            if (solid.isWall) { const cx=Math.max(solid.x,Math.min(potentialX,solid.x+solid.width)); const cy=Math.max(solid.y,Math.min(potentialY,solid.y+solid.height)); if(distanceSq(potentialX,potentialY,cx,cy)<entityRadius*entityRadius) return solid; }
            else if (typeof solid.radius==='number') { if(distanceSq(potentialX,potentialY,solid.x,solid.y)<(entityRadius+solid.radius)**2) return solid; }
        }
    } return null;
}

// --- Initialization Functions ---
function createWalls() { walls = []; solidObjects = solidObjects.filter(obj => !obj.isWall); console.log("Creating biome walls..."); const add=(id,x,y,w,h,tier)=>{const wall={id:id,x:x,y:y,width:w,height:h,color:WALL_COLOR,isWall:true,tier:tier,isSolid:true,isAttackable:false, health: Infinity}; walls.push(wall);solidObjects.push(wall);}; add('wall_f_p',BIOME_BOUNDS.FOREST_X_END-WALL_THICKNESS/2,BIOME_BOUNDS.FROSTLANDS_Y_END,WALL_THICKNESS,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END,1); add('wall_j_p',BIOME_BOUNDS.JUNGLE_X_START-WALL_THICKNESS/2,BIOME_BOUNDS.FROSTLANDS_Y_END,WALL_THICKNESS,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END,1); add('wall_r_f',BIOME_BOUNDS.ROCKY_X_END-WALL_THICKNESS/2,0,WALL_THICKNESS,BIOME_BOUNDS.ROCKY_Y_END,2); add('wall_s_f',BIOME_BOUNDS.SWAMP_X_START-WALL_THICKNESS/2,0,WALL_THICKNESS,BIOME_BOUNDS.SWAMP_Y_END,2); add('wall_v_d',BIOME_BOUNDS.VOLCANO_X_END-WALL_THICKNESS/2,BIOME_BOUNDS.VOLCANO_Y_START,WALL_THICKNESS,WORLD_HEIGHT-BIOME_BOUNDS.VOLCANO_Y_START,3); add('wall_b_d',BIOME_BOUNDS.BADLANDS_X_START-WALL_THICKNESS/2,BIOME_BOUNDS.BADLANDS_Y_START,WALL_THICKNESS,WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START,3); add('wall_fr_pl',BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.FROSTLANDS_Y_END-WALL_THICKNESS/2,BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END,WALL_THICKNESS,4); add('wall_d_pl',BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.DESERT_Y_START-WALL_THICKNESS/2,BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END,WALL_THICKNESS,4); add('wall_r_fo',0,BIOME_BOUNDS.ROCKY_Y_END-WALL_THICKNESS/2,BIOME_BOUNDS.ROCKY_X_END,WALL_THICKNESS,4); add('wall_s_j',BIOME_BOUNDS.SWAMP_X_START,BIOME_BOUNDS.SWAMP_Y_END-WALL_THICKNESS/2,WORLD_WIDTH-BIOME_BOUNDS.SWAMP_X_START,WALL_THICKNESS,4); add('wall_v_fo',0,BIOME_BOUNDS.VOLCANO_Y_START-WALL_THICKNESS/2,BIOME_BOUNDS.VOLCANO_X_END,WALL_THICKNESS,4); add('wall_b_j',BIOME_BOUNDS.BADLANDS_X_START,BIOME_BOUNDS.BADLANDS_Y_START-WALL_THICKNESS/2,WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START,WALL_THICKNESS,4); console.log(`Created ${walls.length} wall segments.`); }
function spawnInitialResources() { resources=[]; solidObjects=[]; let resCount=0, treeCount=0, rockCount=0, boneCount=0, attempts=0; const MAX_ATT=15000; console.log(`Spawning ${FOREST_TREE_TARGET} trees...`); attempts=0; while(treeCount<FOREST_TREE_TARGET&&attempts<MAX_ATT*2){attempts++;const x=Math.random()*BIOME_BOUNDS.FOREST_X_END,y=BIOME_BOUNDS.FROSTLANDS_Y_END+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); if(getBiomeAt(x,y)!=='forest')continue; const d=ITEM_DATA['tree'], r=d?.radius||15, h=d?.health||50; const res={id:`res_t_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:'tree',color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false,variant:null}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);treeCount++;resCount++;}} console.log(`Spawned ${treeCount} forest trees.`); console.log(`Spawning 1500 rocks...`); attempts=0; let count=0; while(count<1500&&attempts<MAX_ATT*1.5){attempts++;const x=Math.random()*BIOME_BOUNDS.ROCKY_X_END,y=Math.random()*BIOME_BOUNDS.ROCKY_Y_END; if(getBiomeAt(x,y)!=='rocky')continue; const d=ITEM_DATA['rock'], r=d?.radius||12, h=d?.health||150; const res={id:`res_r_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:'rock',color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);count++;resCount++;}} console.log(`Spawned ${count} rocky rocks.`); console.log(`Spawning 300 bone trees...`); attempts=0; count=0; while(count<300&&attempts<MAX_ATT){attempts++;const x=BIOME_BOUNDS.BADLANDS_X_START+Math.random()*(WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START),y=BIOME_BOUNDS.BADLANDS_Y_START+Math.random()*(WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START); if(getBiomeAt(x,y)!=='badlands')continue; const d=ITEM_DATA['bone_tree'], r=d?.radius||13, h=d?.health||80; const res={id:`res_b_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:'bone_tree',color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false,variant:'bone'}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);count++;resCount++;}} console.log(`Spawned ${count} bone trees.`); console.log("Spawning other resources..."); const TARGET_OTHER=2000; attempts=0; const MAX_OTHER_ATT=TARGET_OTHER*15; let tempOther=0; while(tempOther<TARGET_OTHER&&attempts<MAX_OTHER_ATT){attempts++;const x=Math.random()*WORLD_WIDTH,y=Math.random()*WORLD_HEIGHT;const biome=getBiomeAt(x,y); if(biome==='rocky'||biome==='badlands'||biome==='forest')continue; if((x>JUNGLE_LAKE.x&&x<JUNGLE_LAKE.x+JUNGLE_LAKE.width&&y>JUNGLE_LAKE.y&&y<JUNGLE_LAKE.y+JUNGLE_LAKE.height)||lavaPools.some(p=>x>p.x&&x<p.x+p.width&&y>p.y&&y<p.y+p.height)||(x<ISLAND_PADDING/2||x>WORLD_WIDTH-ISLAND_PADDING/2||y<ISLAND_PADDING/2||y>WORLD_HEIGHT-ISLAND_PADDING/2))continue; const data=BIOME_DATA[biome];const mult=data.spawnMultiplier||1;const chance=0.05;if(Math.random()>chance*mult)continue; const rand=Math.random();let type=null,variant=null;let treeD=data.treeDensity,rockD=data.rockDensity,cactusD=data.cactusDensity; if(biome==='volcano'||biome==='swamp')treeD=0; const totalD=treeD+rockD+cactusD; if(totalD>0){const treeC=treeD/totalD;const rockC=rockD/totalD; if(rand<treeC){type='tree';if(biome==='frostlands')variant='snowy';}else if(rand<treeC+rockC){type='rock';}else if(cactusD>0&&biome==='desert'){type='cactus';}} if(type){const d=ITEM_DATA[type];const r=d?.radius||(type==='tree'?(12+Math.random()*6):(10+Math.random()*4));const h=d?.health||(type==='tree'?50:150);const res={id:`res_${type}_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:type,color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false,variant:variant}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);tempOther++;resCount++;}}} if(attempts>=MAX_OTHER_ATT)console.warn("Max attempts spawning other resources."); console.log(`Total resources spawned: ${resCount}`); }
function spawnInitialMonsters() { monsters = []; let attempts=0; const MAX_ATT=INITIAL_MONSTER_COUNT*5; console.log(`Spawning ${INITIAL_MONSTER_COUNT} monsters...`); let count=0; while(count<INITIAL_MONSTER_COUNT&&attempts<MAX_ATT){attempts++;const x=Math.random()*WORLD_WIDTH, y=Math.random()*WORLD_HEIGHT; if((x>JUNGLE_LAKE.x&&x<JUNGLE_LAKE.x+JUNGLE_LAKE.width&&y>JUNGLE_LAKE.y&&y<JUNGLE_LAKE.y+JUNGLE_LAKE.height)||lavaPools.some(p=>x>p.x&&x<p.x+p.width&&y>p.y&&y<p.y+p.height)||(x<ISLAND_PADDING/2||x>WORLD_WIDTH-ISLAND_PADDING/2||y<ISLAND_PADDING/2||y>WORLD_HEIGHT-ISLAND_PADDING/2)||distanceSq(x,y,player.x,player.y)<(200*200)||checkCollision(10,x,y,null,solidObjects)) continue; const h=50; const mon={id:`mon_${Date.now()}_${Math.random()}`,x:x,y:y,radius:10+Math.random()*5,type:'slime',color:'#DC143C',maxHealth:h*2,health:h*2,flashUntil:0,state:'idle',attackCooldown:MONSTER_ATTACK_COOLDOWN,lastAttackTime:0,target:null,isAttackable:true,isSolid:false}; monsters.push(mon); count++;} if(attempts>=MAX_ATT&&count<INITIAL_MONSTER_COUNT){console.warn(`Max spawn attempts for monsters. Spawned: ${count}`);} console.log(`Spawned ${count} actual monsters.`); }
function spawnBosses() { bosses=[]; const baseBossHealth=PLAINS_BOSS_HEALTH;const plainsEdgeBuffer=50;let spawnX_plains,spawnY_plains;let attempts_plains=0;const MAX_BOSS_SPAWN_ATTEMPTS=50;do{spawnX_plains=BIOME_BOUNDS.FOREST_X_END+plainsEdgeBuffer+Math.random()*(BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END-2*plainsEdgeBuffer);spawnY_plains=BIOME_BOUNDS.FROSTLANDS_Y_END+plainsEdgeBuffer+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END-2*plainsEdgeBuffer);attempts_plains++;}while(checkCollision(PLAINS_BOSS_RADIUS,spawnX_plains,spawnY_plains,null,solidObjects)&&attempts_plains<MAX_BOSS_SPAWN_ATTEMPTS);if(attempts_plains>=MAX_BOSS_SPAWN_ATTEMPTS){console.error("Could not find valid spawn location for Plains Boss!");spawnX_plains=WORLD_CENTER_X;spawnY_plains=WORLD_CENTER_Y;} const plainsBoss={id:`boss_plains_${Date.now()}`,x:spawnX_plains,y:spawnY_plains,radius:PLAINS_BOSS_RADIUS,type:'plains_boss',color:'#665A48',angle:0,maxHealth:baseBossHealth,health:baseBossHealth,flashUntil:0,state:'patrolling',attackCooldown:PLAINS_BOSS_ATTACK_COOLDOWN,lastAttackTime:0,attackTarget:null,speed:PLAINS_BOSS_SPEED,detectRangeSq:PLAINS_BOSS_DETECT_RANGE_SQ,attackRange_hit:BOSS_HIT_RANGE,attackRange_smash:BOSS_SMASH_RANGE,attackRange_spin:BOSS_SPIN_RANGE,patrolTargetX:null,patrolTargetY:null,attackAnimationTimer:0,attackChoiceCooldown:PLAINS_BOSS_ATTACK_CHOICE_COOLDOWN,lastAttackChoiceTime:0,currentAttack:null,smashLanded:false,lastSpinDamageTime:0,isAttackable:true,isSolid:true,isPlaced:false,isBoss:true}; bosses.push(plainsBoss);solidObjects.push(plainsBoss);console.log("Spawned Plains Boss at",Math.round(spawnX_plains),Math.round(spawnY_plains)); const forestEdgeBuffer=80;let spawnX_wolf,spawnY_wolf;let attempts_wolf=0;do{spawnX_wolf=forestEdgeBuffer+Math.random()*(BIOME_BOUNDS.FOREST_X_END-2*forestEdgeBuffer);spawnY_wolf=BIOME_BOUNDS.FROSTLANDS_Y_END+forestEdgeBuffer+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END-2*forestEdgeBuffer);attempts_wolf++;}while(checkCollision(FOREST_WOLF_RADIUS,spawnX_wolf,spawnY_wolf,null,solidObjects)&&attempts_wolf<MAX_BOSS_SPAWN_ATTEMPTS);if(attempts_wolf>=MAX_BOSS_SPAWN_ATTEMPTS){console.error("Could not find valid spawn location for Forest Wolf! Placing near center of forest.");spawnX_wolf=BIOME_BOUNDS.FOREST_X_END/2;spawnY_wolf=(BIOME_BOUNDS.FROSTLANDS_Y_END+BIOME_BOUNDS.DESERT_Y_START)/2;} const forestWolf={id:`boss_wolf_${Date.now()}`,x:spawnX_wolf,y:spawnY_wolf,radius:FOREST_WOLF_RADIUS,type:'forest_wolf',color:'#696969',angle:Math.random()*Math.PI*2,maxHealth:FOREST_WOLF_HEALTH,health:FOREST_WOLF_HEALTH,flashUntil:0,state:'moving_to_corner',speedMultiplier:FOREST_WOLF_SPEED_MULT,contactDamage:FOREST_WOLF_CONTACT_DAMAGE,targetCorner:null,lastCornerChangeTime:0,isAttackable:true,isSolid:true,isPlaced:false,isBoss:true}; bosses.push(forestWolf);solidObjects.push(forestWolf);console.log("Spawned Forest Wolf at",Math.round(spawnX_wolf),Math.round(spawnY_wolf));}
function spawnJungleBoss() { if(!forestWolfDefeated||bosses.some(b=>b.type==='jungle_boss'))return; console.log("Spawning Jungle Lake Boss..."); const spawnX=JUNGLE_LAKE.x+JUNGLE_LAKE.width/2; const spawnY=JUNGLE_LAKE.y+JUNGLE_LAKE.height/2; if(checkCollision(JUNGLE_BOSS_RADIUS,spawnX,spawnY,null,solidObjects)){console.error("Cannot spawn Jungle Boss - Lake center blocked?"); return;} const jungleBoss={id:`boss_jungle_${Date.now()}`,x:spawnX,y:spawnY,radius:JUNGLE_BOSS_RADIUS,type:'jungle_boss',color:'#008B8B',angle:0,maxHealth:JUNGLE_BOSS_HEALTH,health:JUNGLE_BOSS_HEALTH,flashUntil:0,state:'active',attackCooldown:JUNGLE_BOSS_ATTACK_COOLDOWN,lastAttackTime:0,projectileDamage:JUNGLE_BOSS_PROJECTILE_DAMAGE,isAttackable:true,isSolid:true,isPlaced:false,isBoss:true,lakeBounds:{...JUNGLE_LAKE}}; bosses.push(jungleBoss);solidObjects.push(jungleBoss);console.log("Spawned Jungle Lake Boss at",Math.round(spawnX),Math.round(spawnY)); }

// --- Input Handling ---
function handleSpacebarPress() { if (player.className === 'summoner') { trySummonSlime(); } else if (player.className === 'necromancer') { trySummonUndead(); } }
document.addEventListener('keydown', (event) => { if (isGameOver || !gameHasStarted || gamePaused) return; const key=event.key.toLowerCase(); const code=event.code; if(key==='e'){toggleCraftingMenu();keysPressed[key]=false;return;} if(key==='escape'){if(isCraftingMenuOpen){toggleCraftingMenu();} keysPressed[key]=false;return;} if(isCraftingMenuOpen) return; if(key==='m'){isMinimapVisible=!isMinimapVisible;console.log(`Minimap toggled: ${isMinimapVisible?'ON':'OFF'}`);keysPressed[key]=false;event.preventDefault();return;} if(code==='Space'){handleSpacebarPress();event.preventDefault();keysPressed[' ']=false; return;} keysPressed[key]=true; if(!isNaN(parseInt(key))&&parseInt(key)>=1&&parseInt(key)<=HOTBAR_SIZE){selectHotbar(parseInt(key)-1);} });
document.addEventListener('keyup', (event) => { keysPressed[event.key.toLowerCase()] = false; if(event.code === 'Space') keysPressed[' '] = false;});
canvas.addEventListener('mousemove', (event) => { if(isGameOver||!gameHasStarted||gamePaused)return; const rect=canvas.getBoundingClientRect(); mouseCanvasX=event.clientX-rect.left; mouseCanvasY=event.clientY-rect.top; const worldCoords=canvasToWorld(mouseCanvasX,mouseCanvasY); worldMouseX=worldCoords.x; worldMouseY=worldCoords.y; });
canvas.addEventListener('mousedown', (event) => { if(isGameOver||isCraftingMenuOpen||!gameHasStarted||gamePaused)return; if(event.button===0){isMouseDown = true;} else if(event.button===2){if(!player.isInteracting&&!player.isAttacking){player.isInteracting=true;player.interactTimer=Date.now();tryInteract();}} });
canvas.addEventListener('mouseup', (event) => { if (event.button === 0) { isMouseDown = false; } });
canvas.addEventListener('mouseleave', () => { isMouseDown = false; });
closeCraftingButton.addEventListener('click', ()=>{if(player.selectedInventoryItem){player.selectedInventoryItem=null;} if(selectedUpgradeInput.slotIndex!==-1)selectedUpgradeInput={slotIndex:-1,source:null}; toggleCraftingMenu();});
craftingMenuDiv.addEventListener('click', (event) => { if (event.target === craftingMenuDiv && isCraftingMenuOpen) { toggleCraftingMenu(); } });
canvas.addEventListener('contextmenu', (event) => event.preventDefault());

// --- Action Functions ---
function findNearestObject(x, y, rangeSq, filterFn = () => true) { let closest=null,minDistSq=rangeSq; for(const obj of solidObjects){if(obj.isPlaced&&filterFn(obj)){const dSq=distanceSq(x,y,obj.x,obj.y);if(dSq<minDistSq&&dSq<(obj.radius+PLAYER_RADIUS)**2){minDistSq=dSq;closest=obj;}}} return closest; }
function decrementHotbarItem(index) { const slot=player.hotbarSlots[index]; if(!slot)return false; slot.count--; if(slot.count<=0){player.hotbarSlots[index]=null;} updateMainHotbarVisuals();updateEquippedItem();if(isCraftingMenuOpen){populateCraftingMenu(isNearWorkbench(),isNearUpgrader());} return true;}
function tryAttack() { if (!gameHasStarted || gamePaused) return; const now = Date.now(); const equippedItemSlot = player.hotbarSlots[player.selectedHotbarSlotIndex]; const equippedItemType = equippedItemSlot ? equippedItemSlot.type : null; const equippedItemData = equippedItemType ? ITEM_DATA[equippedItemType] : null; if (equippedItemData && equippedItemData.type === 'tool' && equippedItemData.toolType === 'bow') { const currentBowCooldown = BOW_COOLDOWN * player.bonusBowAttackSpeedMult * player.weaponAttackSpeedMult; if (now - player.lastBowShotTime >= currentBowCooldown) { player.isAttacking = true; player.attackTimer = now; player.lastBowShotTime = now; const speed = PROJECTILE_SPEED, range = (equippedItemData.range || PROJECTILE_RANGE) * (player.weaponRangeMult || 1), dmg = ((equippedItemData.damage || 10) * player.bowMultiplierBoost) * player.weaponDamageMult; const proj = { id: `proj_${player.id}_${now}`, ownerId: player.id, x: player.x + Math.cos(player.angle) * (player.radius + 5), y: player.y + Math.sin(player.angle) * (player.radius + 5), vx: Math.cos(player.angle) * speed, vy: Math.sin(player.angle) * speed, damage: dmg, range: range, traveled: 0, radius: PROJECTILE_RADIUS, color: '#F5F5DC', type: 'arrow_projectile' }; projectiles.push(proj); console.log(`Fired arrow (Dmg:${dmg.toFixed(1)})`); } else { /* No need to set attacking to false here for hold-down */ } return; } if (now - player.lastAttackTime < MELEE_ATTACK_COOLDOWN * player.weaponAttackSpeedMult) { if(isMouseDown) { player.isAttacking = true; player.attackTimer = now;} return; } player.isAttacking = true; player.attackTimer = now; player.lastAttackTime = now; let bestTarget = null, minDistSq = (ATTACK_RANGE + player.radius)**2; const attackables = [...monsters, ...resources, ...bosses, ...undeadMinions, ...summonedSlimes]; const ax = player.x + Math.cos(player.angle) * player.radius, ay = player.y + Math.sin(player.angle) * player.radius; for (const target of attackables) { if (!target || target.health <= 0 || !target.isAttackable) continue; let hit = false; if (target.isWall) { const cx = Math.max(target.x, Math.min(ax, target.x + target.width)), cy = Math.max(target.y, Math.min(ay, target.y + target.height)); if (distanceSq(ax, ay, cx, cy) < ATTACK_RANGE ** 2) hit = true; } else if (typeof target.radius === 'number') { const dSq = distanceSq(ax, ay, target.x, target.y); if (dSq < minDistSq && dSq < (target.radius + ATTACK_RANGE) ** 2) hit = true; } if (hit) { const angleTo = Math.atan2(target.y - player.y, target.x - player.x); const angleDiff = Math.abs(normalizeAngle(player.angle - angleTo)); if (angleDiff < ATTACK_SWING_ARC / 2 + 0.5) { if (target.isWall) { bestTarget = target; } else { const dSq = distanceSq(ax, ay, target.x, target.y); if (dSq < minDistSq) { minDistSq = dSq; bestTarget = target; } } } } } if (bestTarget) { if (bestTarget.isWall) { console.log("Hit wall"); return; } const targetIsEnemy = monsters.some(m => m.id === bestTarget.id) || bosses.some(b => b.id === bestTarget.id); const targetIsMonster = monsters.some(m => m.id === bestTarget.id); bestTarget.flashUntil = now + FLASH_DURATION; let damage = 0, canDmg = true; const targetIsBoss = bosses.some(b => b.id === bestTarget.id); const targetIsTree = bestTarget.type === 'tree'; const targetIsRock = bestTarget.type === 'rock'; const targetIsCactus = bestTarget.type === 'cactus'; const targetIsBone = bestTarget.type === 'bone_tree'; const targetIsPlaced = bestTarget.isPlaced; const targetIsUndead = bestTarget.type === 'undead_minion'; const targetIsSummon = bestTarget.type === 'summoned_slime'; if (equippedItemData && equippedItemData.type === 'tool') { if ((targetIsEnemy || targetIsUndead || targetIsSummon) && equippedItemData.toolType === 'sword') { damage = (BASE_ATTACK_POWER * equippedItemData.damageMultiplier * player.swordMultiplierBoost + player.bonusSwordDamage + player.bonusMeleeDamage) * player.weaponDamageMult; console.log(`Sword on ${bestTarget.type || 'res'} (Dmg:${damage.toFixed(1)})`); } else if ((targetIsTree || targetIsBone) && equippedItemData.toolType === 'axe') { damage = BASE_GATHER_POWER * equippedItemData.gatherMultiplier; } else if (targetIsRock && equippedItemData.toolType === 'pickaxe') { damage = BASE_GATHER_POWER * equippedItemData.gatherMultiplier; } else if (targetIsCactus && equippedItemData.toolType === 'axe') { damage = BASE_GATHER_POWER * equippedItemData.gatherMultiplier; } else if (targetIsPlaced && (equippedItemData.toolType === 'axe' || equippedItemData.toolType === 'pickaxe')) { damage = BASE_GATHER_POWER * 2.0; } else { damage = BASE_ATTACK_POWER / 2; } } else { damage = ((targetIsEnemy || targetIsUndead || targetIsSummon) ? BASE_ATTACK_POWER : BASE_GATHER_POWER) + player.bonusMeleeDamage; damage *= player.weaponDamageMult; if (targetIsRock) { damage = BASE_GATHER_POWER / 3; } } if (canDmg && damage > 0) { bestTarget.health -= damage; const totalLifesteal = player.lifesteal + player.bonusLifesteal; if (targetIsEnemy && totalLifesteal > 0) { const hBef = player.health; player.health = Math.min(player.maxHealth, player.health + totalLifesteal); if (player.health > hBef) updateUI(); } if (bestTarget.health <= 0) { console.log(`%cDestroyed ${bestTarget.type || 'res'}!`, 'color:orange;font-weight:bold;'); const dropX = bestTarget.x, dropY = bestTarget.y; let drops = []; if (targetIsMonster && player.className === 'necromancer') { player.monsterKillCount++; console.log(`Necro Kills:${player.monsterKillCount}/${CLASS_DATA.necromancer.killsToSummon}`); } if(targetIsEnemy && player.weaponOnKillHeal > 0) { player.health = Math.min(player.maxHealth, player.health + player.weaponOnKillHeal); updateUI(); } if (targetIsTree) { drops.push({ type: 'wood', count: 1 + Math.floor(Math.random() * 3) }); if (Math.random() < 0.2) drops.push({ type: 'plant_fiber', count: 1 }); } else if (targetIsRock) { drops.push({ type: 'stone', count: 1 + Math.floor(Math.random() * 2) }); } else if (targetIsCactus) { drops.push({ type: 'plant_fiber', count: 1 + Math.floor(Math.random() * 2) }); } else if (targetIsBone) { drops.push({ type: 'dust', count: 1 + Math.floor(Math.random() * 3) }); if (Math.random() < 0.02) { drops.push({ type: 'bone_scythe', count: 1 }); console.log("%cDrops Bone Scythe!", "color:magenta;font-weight:bold;"); } } else if (targetIsMonster) { drops.push({ type: 'monster_goop', count: 1 + Math.floor(Math.random() * 4) }); if (Math.random() < GOLD_COIN_DROP_CHANCE) drops.push({ type: 'gold_coin', count: 1 }); if (Math.random() < 0.02) drops.push({ type: 'healing_salve', count: 1 }); gainXP(MONSTER_XP_REWARD); } else if (targetIsBoss && bestTarget.type === 'plains_boss') { drops.push({ type: 'gold_coin', count: 10 + Math.floor(Math.random() * 16) }); drops.push({ type: 'stone', count: 5 + Math.floor(Math.random() * 11) }); drops.push({ type: 'iron_ore', count: 15 }); if (Math.random() < 0.1) drops.push({ type: 'healing_salve', count: 2 }); gainXP(PLAINS_BOSS_XP_REWARD); const tier = BOSS_WALL_TIER_MAP[bestTarget.type]; if (tier !== undefined) { const wc = walls.length; walls = walls.filter(w => w.tier !== tier); solidObjects = solidObjects.filter(s => !(s.isWall && s.tier === tier)); const rem = wc - walls.length; if (rem > 0) console.log(`%cTier ${tier} walls (${rem}) gone!`, 'color:blue;font-weight:bold;'); else console.log(`%cNo Tier ${tier} walls found.`, 'color:gray;'); } else { console.warn(`No wall tier map for ${bestTarget.type}`); } } else if (targetIsBoss && bestTarget.type === 'forest_wolf') { gainXP(PLAINS_BOSS_XP_REWARD * 0.75); drops.push({ type: 'mystical_orb', count: 1 }); if (!forestWolfDefeated) { forestWolfDefeated = true; console.log("%cForest Wolf defeated! The lake stirs...", "color: cyan; font-weight: bold;"); spawnJungleBoss(); } } else if (targetIsBoss && bestTarget.type === 'jungle_boss') { gainXP(PLAINS_BOSS_XP_REWARD * 1.5); console.log("%cJungle Boss Defeated!", "color: blue; font-weight: bold;"); /* Drops? */ } else if (targetIsPlaced) { drops.push({ type: bestTarget.type, count: 1 }); } drops.forEach(d => addDroppedItem(dropX, dropY, d.type, d.count)); if (bestTarget.isSolid) solidObjects = solidObjects.filter(s => s.id !== bestTarget.id); if (targetIsMonster) monsters = monsters.filter(m => m.id !== bestTarget.id); else if (targetIsBoss) { bosses = bosses.filter(b => b.id !== bestTarget.id); solidObjects = solidObjects.filter(s => s.id !== bestTarget.id); } else if (targetIsUndead) undeadMinions = undeadMinions.filter(u => u.id !== bestTarget.id); else if (targetIsSummon) summonedSlimes = summonedSlimes.filter(s => s.id !== bestTarget.id); else resources = resources.filter(r => r.id !== bestTarget.id); } } } }
function tryInteract() { if (!gameHasStarted || gamePaused) return; const item = player.hotbarSlots[player.selectedHotbarSlotIndex]; const type = item ? item.type : null; const data = type ? ITEM_DATA[type] : null; if (item && data && data.isUsable) { if (type === 'healing_salve') { if (player.health < player.maxHealth) { player.health = Math.min(player.maxHealth, player.health + HEAL_AMOUNT); decrementHotbarItem(player.selectedHotbarSlotIndex); console.log(`Used Salve. HP: ${player.health.toFixed(0)}`); return; } else { console.log("Health full."); return; } } else if (type === 'mystical_orb') { console.log("Using Mystical Orb..."); if (player.chosenWeaponId) { console.log("Weapon already chosen."); return; } showWeaponChoiceMenu(); decrementHotbarItem(player.selectedHotbarSlotIndex); // Consume orb when menu opens
            return; } return; } const nearby = findNearestObject(player.x, player.y, INTERACT_RANGE_SQ, (obj) => ITEM_DATA[obj.type]?.isInteractable); if (nearby) { if (nearby.type === 'icky_bed') { player.respawnX = nearby.x; player.respawnY = nearby.y; console.log(`%cSpawn set!`, 'color:yellow;'); nearby.flashUntil = Date.now() + 200; return; } return; } if (item && data && data.isPlaceable) { const gx = Math.round(worldMouseX / PLACE_GRID_SIZE) * PLACE_GRID_SIZE, gy = Math.round(worldMouseY / PLACE_GRID_SIZE) * PLACE_GRID_SIZE; if (distanceSq(player.x, player.y, gx, gy) > PLACE_RANGE_SQ) return; const r = data.solidRadius || PLACE_GRID_SIZE / 2; if (checkCollision(r - 1, gx, gy, null, solidObjects)) return; if (distanceSq(player.x, player.y, gx, gy) < (player.radius + r) ** 2) return; const placed = { id: `placed_${Date.now()}_${Math.random()}`, x: gx, y: gy, radius: r, type: type, color: data.color, maxHealth: data.health || 100, health: data.health || 100, flashUntil: 0, isAttackable: data.isAttackable ?? true, isSolid: data.isSolid ?? true, isPlaced: true, lightRadius: data.lightRadius || 0, isInteractable: data.isInteractable || false }; resources.push(placed); if (placed.isSolid) solidObjects.push(placed); decrementHotbarItem(player.selectedHotbarSlotIndex); console.log(`Placed ${type} at (${gx},${gy})`); return; } }
function selectHotbar(index) { if(index<0||index>=HOTBAR_SIZE)return; player.selectedHotbarSlotIndex=index; mainHotbarSlots.forEach((slot,i)=>{slot.classList.toggle('selected',i===index);}); updateEquippedItem(); }
function updateEquippedItem() { const slot=player.hotbarSlots[player.selectedHotbarSlotIndex]; player.equippedItemType=slot?slot.type:null; }

// --- Update Functions ---
function applyDamageToPlayer(amount, source = "unknown") {
    if (player.pet?.type === 'beetle' && player.pet.blockReady) {
        console.log("%cBeetle blocked damage!", "color: brown; font-weight: bold;");
        player.pet.blockReady = false;
        player.pet.lastBlockTime = Date.now();
        // Add visual effect for block?
        return; // Damage negated
    }

    player.health -= amount;
    player.health = Math.max(0, player.health);
    console.log(`Player hit by ${source} for ${amount}. HP: ${player.health.toFixed(0)}`);

    // Visual feedback
    document.getElementById('gameContainer').style.boxShadow = 'inset 0 0 30px 10px rgba(255,0,0,0.5)';
    setTimeout(()=> { document.getElementById('gameContainer').style.boxShadow = ''; }, 150);

    updateUI();
}
function updatePlayer(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted||gamePaused)return; let dx=0,dy=0; let mag=0; if(keysPressed['w'])dy-=1; if(keysPressed['s'])dy+=1; if(keysPressed['a'])dx-=1; if(keysPressed['d'])dx+=1; mag=Math.sqrt(dx*dx+dy*dy); let speed=PLAYER_SPEED*player.speedMultiplier*player.bonusMovementSpeedMult*player.weaponMoveSpeedMult; if(!isNight&&player.daySpeedPenalty<1.0){speed*=player.daySpeedPenalty;} if(isNight&&player.bonusNightSpeedMult>1.0){speed*=player.bonusNightSpeedMult;} if(mag>0){dx=(dx/mag)*speed; dy=(dy/mag)*speed;}else{dx=0;dy=0;} let px=player.x+dx,py=player.y+dy; let collided=checkCollision(player.radius,px,py,player.id,[...solidObjects,...monsters,...bosses,...undeadMinions, ...summonedSlimes]); if (collided && collided.type === 'forest_wolf') { applyDamageToPlayer(collided.contactDamage, 'Forest Wolf'); } if(collided){px=player.x+dx;py=player.y;collided=checkCollision(player.radius,px,py,player.id,[...solidObjects,...monsters,...bosses,...undeadMinions, ...summonedSlimes]);if(collided){if (collided.type === 'forest_wolf'){} px=player.x;py=player.y+dy;collided=checkCollision(player.radius,px,py,player.id,[...solidObjects,...monsters,...bosses,...undeadMinions, ...summonedSlimes]);if(collided){if (collided.type === 'forest_wolf'){} px=player.x;py=player.y;}}} player.x=px;player.y=py; player.x=Math.max(player.radius,Math.min(WORLD_WIDTH-player.radius,player.x));player.y=Math.max(player.radius,Math.min(WORLD_HEIGHT-player.radius,player.y)); for(let i=droppedItems.length-1;i>=0;i--){const item=droppedItems[i];if(distanceSq(player.x,player.y,item.x,item.y)<ITEM_PICKUP_RANGE_SQ){addToInventory(item.type,1);droppedItems.splice(i,1);}} const aimX=worldMouseX-player.x,aimY=worldMouseY-player.y;player.angle=Math.atan2(aimY,aimX); const now=Date.now(); if(player.isAttacking && !isMouseDown && player.equippedItemType && ITEM_DATA[player.equippedItemType]?.toolType !== 'bow' && now - player.attackTimer > ATTACK_DURATION) { player.isAttacking = false; } if(player.isInteracting&&now-player.interactTimer>INTERACT_DURATION)player.isInteracting=false; if(player.health<=0&&!isGameOver){isGameOver=true;console.error("Player Died!");deathMessageDiv.style.display='block';const deathX=player.x,dY=player.y; if (player.className === 'summoner') { console.log("Summoner died, removing minions."); summonedSlimes = []; } setTimeout(()=>{const slots=[...player.inventorySlots.map((it,idx)=>it?{item:it,index:idx,source:'inventory'}:null),...player.hotbarSlots.map((it,idx)=>it?{item:it,index:idx,source:'hotbar'}:null)].filter(Boolean);if(slots.length>0){const rIdx=Math.floor(Math.random()*slots.length);const slotDrop=slots[rIdx];const dropped=slotDrop.item;if(dropped){console.log(`%cDrop ${dropped.count}x ${dropped.type} from ${slotDrop.source} ${slotDrop.index} on death!`,"color:orange");addDroppedItem(dX,dY,dropped.type,dropped.count);if(slotDrop.source==='inventory')player.inventorySlots[slotDrop.index]=null;else player.hotbarSlots[slotDrop.index]=null;if(isCraftingMenuOpen)populateCraftingMenu(isNearWorkbench(),isNearUpgrader());updateMainHotbarVisuals();}} player.health=player.maxHealth;player.x=player.respawnX;player.y=player.respawnY;player.isAttacking=false;player.isInteracting=false;clampCamera();updateUI();deathMessageDiv.style.display='none';isGameOver=false;},2000);} }
function updateMonsters(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted||gamePaused)return; const now=Date.now(); monsters.forEach(monster=>{if(monster.health<=0)return; let potentialTarget=null,targetDistSq=Infinity,targetIsPlayer=false; const distPlayerSq=distanceSq(monster.x,monster.y,player.x,player.y); if(distPlayerSq<MONSTER_DETECT_RANGE**2){if(!isLineObstructed(monster.x,monster.y,player.x,player.y,walls)){potentialTarget=player;targetDistSq=distPlayerSq;targetIsPlayer=true;}} for(const minion of undeadMinions){if(minion.health<=0)continue; const distMinionSq=distanceSq(monster.x,monster.y,minion.x,minion.y); if(distMinionSq<MONSTER_DETECT_RANGE**2&&distMinionSq<targetDistSq){if(!isLineObstructed(monster.x,monster.y,minion.x,minion.y,walls)){potentialTarget=minion;targetDistSq=distMinionSq;targetIsPlayer=false;}}} for(const slime of summonedSlimes){if(slime.health<=0)continue; const distToSlimeSq=distanceSq(monster.x,monster.y,slime.x,slime.y);if(distToSlimeSq<MONSTER_DETECT_RANGE**2&&distToSlimeSq<targetDistSq){if(!isLineObstructed(monster.x,monster.y,slime.x,slime.y,walls)){potentialTarget=slime;targetDistSq=distToSlimeSq;targetIsPlayer=false;}}} if(potentialTarget){monster.target=potentialTarget; const stopChasingRangeSq = (MONSTER_ATTACK_RANGE + monster.radius + potentialTarget.radius)**2; if(targetDistSq<=stopChasingRangeSq)monster.state='attacking'; else monster.state='chasing';}else{monster.state='idle';monster.target=null;} let dx=0,dy=0; if((monster.state==='chasing'||monster.state==='attacking')&&monster.target&&monster.target.health>0){const angle=Math.atan2(monster.target.y-monster.y,monster.target.x-monster.x);dx=Math.cos(angle)*MONSTER_SPEED;dy=Math.sin(angle)*MONSTER_SPEED;} if(dx!==0||dy!==0){let px=monster.x+dx,py=monster.y+dy; const others=monsters.filter(m=>m.id!==monster.id); let collided=checkCollision(monster.radius,px,py,monster.id,[...solidObjects,...others,...bosses,player,...undeadMinions, ...summonedSlimes]); if (collided && collided.type === 'forest_wolf') { console.log(`Monster ${monster.id} hit by Forest Wolf!`); monster.health -= FOREST_WOLF_ENEMY_CONTACT_DAMAGE; monster.flashUntil = now + FLASH_DURATION; if (monster.health <= 0) { console.log(`Monster ${monster.id} killed by wolf collision.`); } } if(!collided){monster.x=px;monster.y=py;}else{px=monster.x+dx;py=monster.y;collided=checkCollision(monster.radius,px,py,monster.id,[...solidObjects,...others,...bosses,player,...undeadMinions, ...summonedSlimes]);if(collided&&collided.type==='forest_wolf'){monster.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE/2;monster.flashUntil=now+FLASH_DURATION;} if(!collided){monster.x=px;}else{px=monster.x;py=monster.y+dy;collided=checkCollision(monster.radius,px,py,monster.id,[...solidObjects,...others,...bosses,player,...undeadMinions, ...summonedSlimes]);if(collided&&collided.type==='forest_wolf'){monster.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE/2;monster.flashUntil=now+FLASH_DURATION;} if(!collided){monster.y=py;}}}} if(monster.state==='attacking'&&monster.target&&monster.target.health>0){if(now-monster.lastAttackTime>monster.attackCooldown){const contactDistanceSq = (monster.radius + monster.target.radius + MONSTER_HIT_BUFFER)**2; const currentDistToTargetSq = distanceSq(monster.x, monster.y, monster.target.x, monster.target.y); if(currentDistToTargetSq <= contactDistanceSq) { monster.lastAttackTime=now; if(monster.target.id===player.id){applyDamageToPlayer(MONSTER_DAMAGE,`Monster ${monster.id}`);}else{monster.target.health-=MONSTER_DAMAGE;monster.target.health=Math.max(0,monster.target.health);monster.target.flashUntil=now+FLASH_DURATION;console.log(`Monster ${monster.id} *hits* ${monster.target.id}. Target HP: ${monster.target.health.toFixed(0)}`);}}}} monster.x=Math.max(monster.radius,Math.min(WORLD_WIDTH-monster.radius,monster.x));monster.y=Math.max(monster.radius,Math.min(WORLD_HEIGHT-monster.radius,monster.y)); if(monster.health<=0){console.log(`Monster ${monster.id} removed.`);}}); const initialMonsterCount=monsters.length;monsters=monsters.filter(m=>m.health>0); }
function updateBosses(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted||gamePaused)return; const now=Date.now(); const originalResourceCount = resources.length; resources = resources.filter(r => r.health > 0); if (resources.length < originalResourceCount) { solidObjects = solidObjects.filter(s => !s.isPlaced || s.health > 0); bosses.forEach(b => { if (b.isSolid && !solidObjects.some(so => so.id === b.id)) solidObjects.push(b); }); walls.forEach(w => { if (!solidObjects.some(so => so.id === w.id)) solidObjects.push(w); }); resources.forEach(r => { if(r.isPlaced && r.isSolid && !solidObjects.some(so => so.id === r.id) && r.health > 0) solidObjects.push(r); }); } for(let i=bosses.length-1;i>=0;i--){const boss=bosses[i];if(boss.health<=0){console.log(`Boss ${boss.id} removed due to zero health.`);solidObjects=solidObjects.filter(s=>s.id!==boss.id);bosses.splice(i,1);continue;} if(boss.type==='plains_boss'){let potentialTarget=null,targetDistSq=Infinity,targetIsPlayer=false; const distPlayerSq=distanceSq(boss.x,boss.y,player.x,player.y); if(distPlayerSq<boss.detectRangeSq){if(!isLineObstructed(boss.x,boss.y,player.x,player.y,walls)){potentialTarget=player;targetDistSq=distPlayerSq;targetIsPlayer=true;}} for(const minion of undeadMinions){if(minion.health<=0)continue; const distMinionSq=distanceSq(boss.x,boss.y,minion.x,minion.y); if(distMinionSq<boss.detectRangeSq&&distMinionSq<targetDistSq){if(!isLineObstructed(boss.x,boss.y,minion.x,minion.y,walls)){potentialTarget=minion;targetDistSq=distMinionSq;targetIsPlayer=false;}}} for(const slime of summonedSlimes){if(slime.health<=0)continue; const distToSlimeSq=distanceSq(boss.x,boss.y,slime.x,slime.y);if(distToSlimeSq<boss.detectRangeSq&&distToSlimeSq<targetDistSq){if(!isLineObstructed(boss.x,boss.y,slime.x,slime.y,walls)){potentialTarget=slime;targetDistSq=distToSlimeSq;targetIsPlayer=false;}}} boss.attackTarget=potentialTarget; if(!boss.state.startsWith('attacking')){if(potentialTarget){boss.angle=Math.atan2(potentialTarget.y-boss.y,potentialTarget.x-boss.x);const targetRadius=(potentialTarget.radius||PLAYER_RADIUS);const hitRangeSq=(boss.attackRange_hit+boss.radius+targetRadius)**2;const smashRangeSq=(boss.attackRange_smash+boss.radius+targetRadius)**2;const spinRangeSq=(boss.attackRange_spin+boss.radius+targetRadius)**2;const inHitRange=targetDistSq<hitRangeSq;const inSmashRange=targetDistSq<smashRangeSq;const inSpinRange=targetDistSq<spinRangeSq;if(inHitRange||inSmashRange||inSpinRange){if(now-boss.lastAttackChoiceTime>boss.attackChoiceCooldown&&now-boss.lastAttackTime>boss.attackCooldown){let possible=[];if(inHitRange)possible.push('hit');if(inSmashRange)possible.push('smash');if(inSpinRange)possible.push('spin');if(possible.length>0){boss.currentAttack=possible[Math.floor(Math.random()*possible.length)];console.log("Plains Boss chose:",boss.currentAttack);boss.state=`attacking_${boss.currentAttack}`;boss.attackAnimationTimer=0;boss.lastAttackTime=now;if(boss.currentAttack==='smash')boss.smashLanded=false;if(boss.currentAttack==='spin')boss.lastSpinDamageTime=0;}}else{boss.state='chasing';}}else{boss.state='chasing';}}else{boss.state='patrolling';boss.patrolTargetX=null;}} if(boss.state==='chasing'&&boss.attackTarget){let dx=Math.cos(boss.angle)*boss.speed,dy=Math.sin(boss.angle)*boss.speed;let px=boss.x+dx,py=boss.y+dy;const others=bosses.filter(b=>b.id!==boss.id);let collided=checkCollision(boss.radius,px,py,boss.id,[...solidObjects,...others,...monsters,player,...undeadMinions,...summonedSlimes]);if(!collided){boss.x=px;boss.y=py;}else{/* Sliding */}}else if(boss.state==='patrolling'){if(boss.patrolTargetX===null||distanceSq(boss.x,boss.y,boss.patrolTargetX,boss.patrolTargetY)<50**2){const buf=100;boss.patrolTargetX=BIOME_BOUNDS.FOREST_X_END+buf+Math.random()*(BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END-2*buf);boss.patrolTargetY=BIOME_BOUNDS.FROSTLANDS_Y_END+buf+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END-2*buf);}if(boss.patrolTargetX!==null){const angle=Math.atan2(boss.patrolTargetY-boss.y,boss.patrolTargetX-boss.x);boss.angle=angle;let dx=Math.cos(angle)*boss.speed,dy=Math.sin(angle)*boss.speed;let px=boss.x+dx,py=boss.y+dy;const others=bosses.filter(b=>b.id!==boss.id);let collided=checkCollision(boss.radius,px,py,boss.id,[...solidObjects,...others,...monsters,player,...undeadMinions,...summonedSlimes]);if(!collided){boss.x=px;boss.y=py;}else{/* Sliding */}}}else if(boss.state==='attacking_hit'){boss.attackAnimationTimer+=deltaTime;if(boss.attackAnimationTimer>=ATTACK_DURATION/2&&boss.attackAnimationTimer<ATTACK_DURATION&&boss.attackTarget){const hitRangeCheckSq=(boss.radius+(boss.attackTarget.radius||PLAYER_RADIUS)+10)**2;if(distanceSq(boss.x,boss.y,boss.attackTarget.x,boss.attackTarget.y)<hitRangeCheckSq){ if(boss.attackTarget.id === player.id) { applyDamageToPlayer(BOSS_HIT_DAMAGE, 'Plains Boss Hit'); } else { boss.attackTarget.health=Math.max(0,boss.attackTarget.health-BOSS_HIT_DAMAGE); boss.attackTarget.flashUntil=now+FLASH_DURATION; console.log(`Boss hit ${boss.attackTarget.id}! HP:${boss.attackTarget.health.toFixed(0)}`); } }boss.attackAnimationTimer=ATTACK_DURATION;}if(boss.attackAnimationTimer>=ATTACK_DURATION){boss.state='chasing';boss.currentAttack=null;}}else if(boss.state==='attacking_smash'){boss.attackAnimationTimer+=deltaTime;if(boss.attackAnimationTimer>=BOSS_SMASH_WINDUP&&!boss.smashLanded&&boss.attackTarget){boss.smashLanded=true;const smashRangeCheckSq=(BOSS_SMASH_RANGE+boss.radius+(boss.attackTarget.radius||PLAYER_RADIUS)-PLAYER_RADIUS)**2;if(distanceSq(boss.x,boss.y,boss.attackTarget.x,boss.attackTarget.y)<smashRangeCheckSq){if(boss.attackTarget.id === player.id) { applyDamageToPlayer(BOSS_SMASH_DAMAGE, 'Plains Boss Smash'); } else { boss.attackTarget.health=Math.max(0,boss.attackTarget.health-BOSS_SMASH_DAMAGE); boss.attackTarget.flashUntil=now+FLASH_DURATION; console.log(`Boss smash ${boss.attackTarget.id}! HP:${boss.attackTarget.health.toFixed(0)}`); } }}if(boss.attackAnimationTimer>=BOSS_SMASH_WINDUP+BOSS_SMASH_EFFECT_DURATION){boss.state='chasing';boss.currentAttack=null;}}else if(boss.state==='attacking_spin'){boss.attackAnimationTimer+=deltaTime;if(now-boss.lastSpinDamageTime>BOSS_SPIN_DAMAGE_INTERVAL&&boss.attackTarget){const spinRangeCheckSq=(BOSS_SPIN_RANGE+boss.radius+(boss.attackTarget.radius||PLAYER_RADIUS)-PLAYER_RADIUS)**2;if(distanceSq(boss.x,boss.y,boss.attackTarget.x,boss.attackTarget.y)<spinRangeCheckSq){if(boss.attackTarget.id === player.id) { applyDamageToPlayer(BOSS_SPIN_DAMAGE, 'Plains Boss Spin'); } else { boss.attackTarget.health=Math.max(0,boss.attackTarget.health-BOSS_SPIN_DAMAGE); boss.attackTarget.flashUntil=now+FLASH_DURATION; console.log(`Boss spin ${boss.attackTarget.id}! HP:${boss.attackTarget.health.toFixed(0)}`); }}boss.lastSpinDamageTime=now;}if(boss.attackAnimationTimer>=BOSS_SPIN_DURATION){boss.state='chasing';boss.currentAttack=null;}}} else if(boss.type==='forest_wolf'){if(boss.state==='moving_to_corner'){if(!boss.targetCorner||distanceSq(boss.x,boss.y,boss.targetCorner.x,boss.targetCorner.y)<FOREST_WOLF_CORNER_THRESHOLD_SQ){if(now-boss.lastCornerChangeTime>1000){pickNewForestCornerTarget(boss);}}if(boss.targetCorner){const angleToTarget=Math.atan2(boss.targetCorner.y-boss.y,boss.targetCorner.x-boss.x);boss.angle=angleToTarget;const wolfSpeed=PLAYER_SPEED*boss.speedMultiplier;const dx=Math.cos(angleToTarget)*wolfSpeed;const dy=Math.sin(angleToTarget)*wolfSpeed;let potentialX=boss.x+dx;let potentialY=boss.y+dy;let destroyedTree=false;for(let j=resources.length-1;j>=0;j--){const res=resources[j];if(res.type==='tree'&&res.health>0){if(distanceSq(potentialX,potentialY,res.x,res.y)<(FOREST_WOLF_TREE_DESTROY_RADIUS+res.radius)**2){console.log(`Wolf ${boss.id} destroyed tree ${res.id}`);res.health=0;addDroppedItem(res.x,res.y,'wood',1+Math.floor(Math.random()*2));destroyedTree=true;}}} const otherBosses=bosses.filter(b=>b.id!==boss.id); let checkList = [...solidObjects.filter(o => !o.isPlaced || o.type !== 'tree'), player, ...otherBosses, ...monsters, ...undeadMinions, ...summonedSlimes]; let collidedWith=checkCollision(boss.radius,potentialX,potentialY,boss.id, checkList); checkList.forEach(entity => { if (entity && entity.id !== boss.id && entity.health > 0 && !entity.isWall && entity.type !== 'forest_wolf') { if(distanceSq(potentialX, potentialY, entity.x, entity.y) < (boss.radius + entity.radius)**2) { let damageToDeal = (entity.id === player.id) ? FOREST_WOLF_CONTACT_DAMAGE : FOREST_WOLF_ENEMY_CONTACT_DAMAGE; if(entity.id === player.id) { applyDamageToPlayer(damageToDeal, 'Forest Wolf Collision'); } else { console.log(`Wolf ${boss.id} damaging ${entity.id || entity.type} on contact!`); entity.health -= damageToDeal; entity.flashUntil = now + FLASH_DURATION; if (entity.health <= 0) { console.log(`${entity.type || entity.id} killed by wolf collision.`); } } } } }); collidedWith=checkCollision(boss.radius,potentialX,potentialY,boss.id,[...solidObjects.filter(o=>!o.isPlaced||o.type!=='tree'),player,...otherBosses,...monsters,...undeadMinions,...summonedSlimes]);if(!collidedWith){boss.x=potentialX;boss.y=potentialY;}else{let slideX=boss.x+dx;let slideY=boss.y;collidedWith=checkCollision(boss.radius,slideX,slideY,boss.id,[...solidObjects.filter(o=>!o.isPlaced||o.type!=='tree'),player,...otherBosses,...monsters,...undeadMinions,...summonedSlimes]);if(!collidedWith){boss.x=slideX;}else{slideX=boss.x;slideY=boss.y+dy;collidedWith=checkCollision(boss.radius,slideX,slideY,boss.id,[...solidObjects.filter(o=>!o.isPlaced||o.type!=='tree'),player,...otherBosses,...monsters,...undeadMinions,...summonedSlimes]);if(!collidedWith){boss.y=slideY;}}}}}boss.x=Math.max(boss.radius,Math.min(WORLD_WIDTH-boss.radius,boss.x));boss.y=Math.max(boss.radius,Math.min(WORLD_HEIGHT-boss.radius,boss.y));} else if(boss.type === 'jungle_boss'){boss.attackTarget=player;const bounds=boss.lakeBounds;let targetX=boss.x;let targetY=boss.y;if(boss.x<bounds.x+boss.radius)targetX=bounds.x+boss.radius+1;if(boss.x>bounds.x+bounds.width-boss.radius)targetX=bounds.x+bounds.width-boss.radius-1;if(boss.y<bounds.y+boss.radius)targetY=bounds.y+boss.radius+1;if(boss.y>bounds.y+bounds.height-boss.radius)targetY=bounds.y+bounds.height-boss.radius-1;if(targetX!==boss.x||targetY!==boss.y){const angleToCenter=Math.atan2(targetY-boss.y,targetX-boss.x);const moveSpeed=0.5;boss.x+=Math.cos(angleToCenter)*moveSpeed;boss.y+=Math.sin(angleToCenter)*moveSpeed;} boss.x=Math.max(boss.radius,Math.min(WORLD_WIDTH-boss.radius,boss.x));boss.y=Math.max(boss.radius,Math.min(WORLD_HEIGHT-boss.radius,boss.y));if(boss.attackTarget&&boss.attackTarget.health>0){const angleToPlayer=Math.atan2(player.y-boss.y,player.x-boss.x);boss.angle=angleToPlayer;if(now-boss.lastAttackTime>=boss.attackCooldown){console.log(`Jungle Boss firing projectile!`);const projX=boss.x+Math.cos(boss.angle)*(boss.radius+JUNGLE_BOSS_PROJECTILE_RADIUS+2);const projY=boss.y+Math.sin(boss.angle)*(boss.radius+JUNGLE_BOSS_PROJECTILE_RADIUS+2);const projectile={id:`proj_${boss.id}_${now}`,ownerId:boss.id,sourceType:'jungle_boss',x:projX,y:projY,vx:Math.cos(boss.angle)*JUNGLE_BOSS_PROJECTILE_SPEED,vy:Math.sin(boss.angle)*JUNGLE_BOSS_PROJECTILE_SPEED,damage:boss.projectileDamage,range:JUNGLE_BOSS_PROJECTILE_RANGE,traveled:0,radius:JUNGLE_BOSS_PROJECTILE_RADIUS,color:JUNGLE_BOSS_PROJECTILE_COLOR,type:'boss_projectile'};projectiles.push(projectile);boss.lastAttackTime=now;}}} boss.x=Math.max(boss.radius,Math.min(WORLD_WIDTH-boss.radius,boss.x));boss.y=Math.max(boss.radius,Math.min(WORLD_HEIGHT-boss.radius,boss.y));} }
function updateUndeadMinions(deltaTime) { if(!gameHasStarted||undeadMinions.length===0||gamePaused)return; const now=Date.now(); for(let i=undeadMinions.length-1;i>=0;i--){const minion=undeadMinions[i];if(minion.health<=0){undeadMinions.splice(i,1);continue;} let potentialTarget=null,potentialTargetType=null,minDistSq=Infinity; if (!minion.attackTarget || minion.attackTarget.health <= 0) { minion.attackTarget=null; const enemies=[...monsters,...bosses]; for(const enemy of enemies){if(enemy.health<=0)continue; if(!isLineObstructed(minion.x,minion.y,enemy.x,enemy.y,walls)){const distSq=distanceSq(minion.x,minion.y,enemy.x,enemy.y);if(distSq<minDistSq){minDistSq=distSq; potentialTarget=enemy; potentialTargetType=monsters.some(m=>m.id===enemy.id)?'monster':'boss';}}} if(potentialTarget) { minion.attackTarget = potentialTarget; minion.targetType = potentialTargetType; console.log(`Undead ${minion.id} acquired new target: ${minion.targetType} ${minion.attackTarget.id}`); } } if(minion.attackTarget && minion.attackTarget.health > 0) { const currentDistSq = distanceSq(minion.x, minion.y, minion.attackTarget.x, minion.attackTarget.y); const attackRangeCheckSq = (minion.attackRange + minion.radius + minion.attackTarget.radius)**2; if (currentDistSq <= attackRangeCheckSq) minion.state = 'attacking'; else minion.state = 'chasing'; } else { minion.state = 'idle'; minion.attackTarget = null; minion.targetType = null; } let dx=0,dy=0;const target=minion.attackTarget; if(minion.state==='chasing'&&target&&target.health>0){const angle=Math.atan2(target.y-minion.y,target.x-minion.x);dx=Math.cos(angle)*minion.speed;dy=Math.sin(angle)*minion.speed;}else if(minion.state==='attacking'&&target&&target.health>0){const angle=Math.atan2(target.y-minion.y,target.x-minion.x);dx=Math.cos(angle)*minion.speed;dy=Math.sin(angle)*minion.speed;const contactDistSq=(minion.radius+target.radius+UNDEAD_HIT_BUFFER)**2;if(now-minion.lastAttackTime>=minion.attackCooldown&&distanceSq(minion.x,minion.y,target.x,target.y)<=contactDistSq){target.health-=minion.damage;target.flashUntil=now+FLASH_DURATION;minion.lastAttackTime=now;console.log(`Undead ${minion.id} hits ${minion.targetType} ${target.id}. Target HP:${target.health.toFixed(0)}`);if(target.health<=0){minion.state='idle';minion.attackTarget=null;minion.targetType=null; console.log(`Undead minion ${minion.id} killed ${target.type||target.id}`); if(target.type==='slime'){ monsters=monsters.filter(m=>m.id!==target.id); gainXP(MONSTER_XP_REWARD * MINION_KILL_XP_MULTIPLIER); } else if(target.isBoss){ let xpGainMult = 0.3; if (target.type === 'plains_boss') { addDroppedItem(target.x, target.y, 'gold_coin', 5); xpGainMult = 0.5; const tier=BOSS_WALL_TIER_MAP[target.type];if(tier!==undefined){const wc=walls.length;walls=walls.filter(w=>w.tier!==tier);solidObjects=solidObjects.filter(s=>!(s.isWall&&s.tier===tier));const rem=wc-walls.length;if(rem>0)console.log(`%cTier ${tier} walls (${rem}) gone (Minion Kill)!`,'color:purple;font-weight:bold;');}} else if (target.type === 'forest_wolf') { xpGainMult = 0.3; if (!forestWolfDefeated) { forestWolfDefeated = true; console.log("%cWolf defeated by minion! Lake stirs...","color:cyan;font-weight:bold;"); spawnJungleBoss(); } } else if (target.type === 'jungle_boss') { xpGainMult = 0.75; console.log("%cJungle Boss defeated by minion!", "color: blue; font-weight: bold;"); } gainXP(PLAINS_BOSS_XP_REWARD * xpGainMult); bosses = bosses.filter(b => b.id !== target.id); solidObjects = solidObjects.filter(s => s.id !== target.id); } }}} if(dx!==0||dy!==0){let px=minion.x+dx,py=minion.y+dy;const others=undeadMinions.filter(u=>u.id!==minion.id);let collided=checkCollision(minion.radius,px,py,minion.id,[...solidObjects,player,...monsters,...bosses,...others, ...summonedSlimes]);if(collided&&collided.type==='forest_wolf'){console.log(`Undead ${minion.id} hit by Forest Wolf!`);minion.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE;minion.flashUntil=now+FLASH_DURATION;if(minion.health<=0){console.log(`Undead ${minion.id} killed by wolf collision.`);}}if(!collided){minion.x=px;minion.y=py;}else{px=minion.x+dx;py=minion.y;collided=checkCollision(minion.radius,px,py,minion.id,[...solidObjects,player,...monsters,...bosses,...others, ...summonedSlimes]);if(collided&&collided.type==='forest_wolf'){minion.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE/2;minion.flashUntil=now+FLASH_DURATION;}if(!collided){minion.x=px;}else{px=minion.x;py=minion.y+dy;collided=checkCollision(minion.radius,px,py,minion.id,[...solidObjects,player,...monsters,...bosses,...others, ...summonedSlimes]);if(collided&&collided.type==='forest_wolf'){minion.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE/2;minion.flashUntil=now+FLASH_DURATION;}if(!collided){minion.y=py;}}}minion.x=Math.max(minion.radius,Math.min(WORLD_WIDTH-minion.radius,minion.x));minion.y=Math.max(minion.radius,Math.min(WORLD_HEIGHT-minion.radius,minion.y));}} }
function updateSummonedSlimes(deltaTime) { if(!gameHasStarted||summonedSlimes.length===0||gamePaused)return; const now=Date.now(); for(let i=summonedSlimes.length-1;i>=0;i--){const slime=summonedSlimes[i];if(slime.health<=0){summonedSlimes.splice(i,1);continue;} let potentialTarget=null,potentialTargetType=null,minDistSq=SUMMON_AGGRO_RANGE_SQ; const enemies=[...monsters,...bosses]; for(const enemy of enemies){if(enemy.health<=0)continue; const distSq=distanceSq(slime.x,slime.y,enemy.x,enemy.y);if(distSq<minDistSq){if(!isLineObstructed(slime.x,slime.y,enemy.x,enemy.y,walls)){minDistSq=distSq;potentialTarget=enemy;potentialTargetType=monsters.some(m=>m.id===enemy.id)?'monster':'boss';}}} if(potentialTarget){slime.attackTarget=potentialTarget;slime.targetType=potentialTargetType;const distToTargetSq=minDistSq;const attackRangeCheckSq=(slime.attackRange+slime.radius+potentialTarget.radius)**2;if(distToTargetSq<=attackRangeCheckSq)slime.state='attacking';else slime.state='chasing';}else{slime.state='following';slime.attackTarget=null;slime.targetType=null;} let dx=0,dy=0;const target=slime.attackTarget; if(slime.state==='chasing'&&target&&target.health>0){const angle=Math.atan2(target.y-slime.y,target.x-slime.x);dx=Math.cos(angle)*slime.speed;dy=Math.sin(angle)*slime.speed;}else if(slime.state==='attacking'&&target&&target.health>0){const angle=Math.atan2(target.y-slime.y,target.x-slime.x);dx=Math.cos(angle)*slime.speed;dy=Math.sin(angle)*slime.speed;const contactDistSq=(slime.radius+target.radius+SUMMONED_SLIME_HIT_BUFFER)**2;if(now-slime.lastAttackTime>=slime.attackCooldown&&distanceSq(slime.x,slime.y,target.x,target.y)<=contactDistSq){target.health-=slime.damage*player.bonusSummonDamageMult;target.flashUntil=now+FLASH_DURATION;slime.lastAttackTime=now;console.log(`SummonSlime ${slime.id} hits ${slime.targetType} ${target.id}. Target HP:${target.health.toFixed(0)}`);if(target.health<=0){slime.state='following';slime.attackTarget=null;slime.targetType=null; console.log(`Summoned slime ${slime.id} killed ${target.type||target.id}`);if(target.type==='slime'){monsters=monsters.filter(m=>m.id!==target.id); gainXP(MONSTER_XP_REWARD * MINION_KILL_XP_MULTIPLIER);}else if(target.isBoss){let xpGainMult = 0.3;if(target.type==='plains_boss'){addDroppedItem(target.x,target.y,'gold_coin',5);xpGainMult=0.5;const tier=BOSS_WALL_TIER_MAP[target.type];if(tier!==undefined){const wc=walls.length;walls=walls.filter(w=>w.tier!==tier);solidObjects=solidObjects.filter(s=>!(s.isWall&&s.tier===tier));const rem=wc-walls.length;if(rem>0)console.log(`%cTier ${tier} walls (${rem}) gone (Summon Kill)!`,'color:purple;font-weight:bold;');}}else if(target.type==='forest_wolf'){xpGainMult=0.3;if(!forestWolfDefeated){forestWolfDefeated=true;console.log("%cWolf defeated by summon! Lake stirs...","color:cyan;font-weight:bold;");spawnJungleBoss();}}else if(target.type==='jungle_boss'){xpGainMult=0.75;console.log("%cJungle Boss defeated by summon!","color:blue;font-weight:bold;");}gainXP(PLAINS_BOSS_XP_REWARD*xpGainMult);bosses=bosses.filter(b=>b.id!==target.id);solidObjects=solidObjects.filter(s=>s.id!==target.id);}}}}else if(slime.state==='following'){const distToPlayerSq=distanceSq(slime.x,slime.y,player.x,player.y);if(distToPlayerSq>SUMMON_FOLLOW_DISTANCE_SQ){const angleToPlayer=Math.atan2(player.y-slime.y,player.x-slime.x);dx=Math.cos(angleToPlayer)*slime.speed*0.8;dy=Math.sin(angleToPlayer)*slime.speed*0.8;}} if(dx!==0||dy!==0){let px=slime.x+dx,py=slime.y+dy;const otherSlimes=summonedSlimes.filter(s=>s.id!==slime.id);let collided=checkCollision(slime.radius,px,py,slime.id,[...solidObjects,...monsters,...bosses,...otherSlimes,...undeadMinions]);if(collided&&collided.type==='forest_wolf'){console.log(`Summoned Slime ${slime.id} hit by Forest Wolf!`);slime.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE;slime.flashUntil=now+FLASH_DURATION;if(slime.health<=0){console.log(`Summoned Slime ${slime.id} killed by wolf collision.`);}}if(!collided){slime.x=px;slime.y=py;}else{px=slime.x+dx;py=slime.y;collided=checkCollision(slime.radius,px,py,slime.id,[...solidObjects,...monsters,...bosses,...otherSlimes,...undeadMinions]);if(collided&&collided.type==='forest_wolf'){slime.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE/2;slime.flashUntil=now+FLASH_DURATION;}if(!collided){slime.x=px;}else{px=slime.x;py=slime.y+dy;collided=checkCollision(slime.radius,px,py,slime.id,[...solidObjects,...monsters,...bosses,...otherSlimes,...undeadMinions]);if(collided&&collided.type==='forest_wolf'){slime.health-=FOREST_WOLF_ENEMY_CONTACT_DAMAGE/2;slime.flashUntil=now+FLASH_DURATION;}if(!collided){slime.y=py;}}}slime.x=Math.max(slime.radius,Math.min(WORLD_WIDTH-slime.radius,slime.x));slime.y=Math.max(slime.radius,Math.min(WORLD_HEIGHT-slime.radius,slime.y));}} }
function updateProjectiles(deltaTime) { if (!gameHasStarted||gamePaused) return; for (let i=projectiles.length-1; i>=0; i--) { const proj=projectiles[i]; const speed=PROJECTILE_SPEED*(deltaTime/(1000/60)); const mx=proj.vx/PROJECTILE_SPEED*speed, my=proj.vy/PROJECTILE_SPEED*speed, moveDist=Math.sqrt(mx*mx+my*my); proj.x+=mx; proj.y+=my; proj.traveled+=moveDist; if (proj.traveled>proj.range || proj.x<0 || proj.x>WORLD_WIDTH || proj.y<0 || proj.y>WORLD_HEIGHT) { projectiles.splice(i,1); continue; } const solidHit=checkCollision(proj.radius,proj.x,proj.y,proj.ownerId,solidObjects.filter(o=>o.id!==proj.ownerId)); if(solidHit&&solidHit.id!==player.id){if(solidHit.isWall){projectiles.splice(i,1);continue;} if(solidHit.isAttackable&&ITEM_DATA[solidHit.type]?.health){solidHit.health-=proj.damage;solidHit.flashUntil=Date.now()+FLASH_DURATION;if(solidHit.health<=0){/*...*/}} if(solidHit.type!=='plains_boss'&&solidHit.type!=='forest_wolf'&&solidHit.type!=='jungle_boss'){projectiles.splice(i,1);continue;}} if(!projectiles[i])continue; if(proj.ownerId!==player.id){const distSqPlayer=distanceSq(proj.x,proj.y,player.x,player.y);if(distSqPlayer<(proj.radius+player.radius)**2){applyDamageToPlayer(proj.damage, proj.sourceType || 'Projectile'); projectiles.splice(i,1);continue;}} if(!projectiles[i])continue; if(proj.ownerId===player.id){for(let j=monsters.length-1;j>=0;j--){const mon=monsters[j];if(distanceSq(proj.x,proj.y,mon.x,mon.y)<(proj.radius+mon.radius)**2){mon.health-=proj.damage;mon.flashUntil=Date.now()+FLASH_DURATION;if(mon.health<=0){console.log(`%cDestroyed monster w/ proj!`,'color:orange;');addDroppedItem(mon.x,mon.y,'monster_goop',1+Math.floor(Math.random()*4));if(Math.random()<GOLD_COIN_DROP_CHANCE)addDroppedItem(mon.x,mon.y,'gold_coin',1);monsters.splice(j,1);gainXP(MONSTER_XP_REWARD); if(player.className === 'necromancer') player.monsterKillCount++;} projectiles.splice(i,1);break;}}} if(!projectiles[i])continue; if(proj.ownerId===player.id){for(let j=bosses.length-1;j>=0;j--){const boss=bosses[j];if(distanceSq(proj.x,proj.y,boss.x,boss.y)<(proj.radius+boss.radius)**2){boss.health-=proj.damage;boss.flashUntil=Date.now()+FLASH_DURATION;console.log(`Proj hit boss ${boss.id}, HP:${boss.health.toFixed(0)}`);if(boss.health<=0){console.log(`%cDestroyed boss ${boss.id} w/ proj!`,'color:red;font-weight:bold;');if(boss.type==='plains_boss'){addDroppedItem(boss.x,boss.y,'gold_coin',10+Math.floor(Math.random()*16));addDroppedItem(boss.x,boss.y,'stone',5+Math.floor(Math.random()*11));addDroppedItem(boss.x,boss.y,'iron_ore',15);if(Math.random()<0.1)addDroppedItem(boss.x,boss.y,'healing_salve',2);gainXP(PLAINS_BOSS_XP_REWARD);const tier=BOSS_WALL_TIER_MAP[boss.type];if(tier!==undefined){const wc=walls.length;walls=walls.filter(w=>w.tier!==tier);solidObjects=solidObjects.filter(s=>!(s.isWall&&s.tier===tier));const rem=wc-walls.length;if(rem>0)console.log(`%cTier ${tier} walls (${rem}) gone (Player Kill)!`,'color:blue;font-weight:bold;');}else{console.warn(`No wall tier map for ${boss.type}`);}}else if(boss.type==='forest_wolf'){gainXP(PLAINS_BOSS_XP_REWARD*0.75); drops.push({ type: 'mystical_orb', count: 1 }); if(!forestWolfDefeated){forestWolfDefeated=true;console.log("%cWolf defeated! Lake stirs...","color:cyan;font-weight:bold;");spawnJungleBoss();}}else if(boss.type==='jungle_boss'){gainXP(PLAINS_BOSS_XP_REWARD*1.5);console.log("%cJungle Boss Defeated!","color:blue;font-weight:bold;");}bosses.splice(j,1);solidObjects=solidObjects.filter(s=>s.id!==boss.id);}projectiles.splice(i,1);break;}}} if(!projectiles[i])continue; /* Pets are not hit by projectiles */ } }
function updateWorld(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted||gamePaused)return; gameTime+=deltaTime; const cycleTime=gameTime%DAY_LENGTH, cyclePercent=cycleTime/DAY_LENGTH; const newDay=Math.floor(gameTime/DAY_LENGTH)+1; if(newDay>dayCount){dayCount=newDay;console.log(`Day ${dayCount}`);} const wasNight=isNight; let targetOp=0,phase="Day",timeLeft=0,transitionDur=TRANSITION_DURATION_PERCENT*DAY_LENGTH,nextPhaseStart=SUNSET_START_PERCENT; if(cyclePercent>=0&&cyclePercent<SUNSET_START_PERCENT){isNight=false;phase="Day";targetOp=0;nextPhaseStart=SUNSET_START_PERCENT;} else if(cyclePercent>=SUNSET_START_PERCENT&&cyclePercent<NIGHT_START_PERCENT){isNight=true;phase="Sunset";const tp=(cyclePercent-SUNSET_START_PERCENT)/TRANSITION_DURATION_PERCENT;targetOp=tp*MAX_NIGHT_OPACITY;nextPhaseStart=NIGHT_START_PERCENT;} else if(cyclePercent>=NIGHT_START_PERCENT&&cyclePercent<SUNRISE_START_PERCENT){isNight=true;phase="Night";targetOp=MAX_NIGHT_OPACITY;nextPhaseStart=SUNRISE_START_PERCENT;} else {isNight=false;phase="Sunrise";const tp=(cyclePercent-SUNRISE_START_PERCENT)/TRANSITION_DURATION_PERCENT;targetOp=(1-tp)*MAX_NIGHT_OPACITY;nextPhaseStart=1.0;} timeLeft=(nextPhaseStart*DAY_LENGTH)-cycleTime;if(nextPhaseStart===1.0)timeLeft=DAY_LENGTH-cycleTime;else if(timeLeft<-10)timeLeft+=DAY_LENGTH; if(Math.abs(currentNightOpacity-targetOp)>0.005){const speed=deltaTime/(transitionDur/2);if(currentNightOpacity<targetOp)currentNightOpacity=Math.min(currentNightOpacity+speed,targetOp);else if(currentNightOpacity>targetOp)currentNightOpacity=Math.max(currentNightOpacity-speed,targetOp);}else{currentNightOpacity=targetOp;} currentNightOpacity=Math.max(0,Math.min(MAX_NIGHT_OPACITY,currentNightOpacity)); if(timeUIDiv)timeUIDiv.innerHTML=`<span>Phase: ${phase}</span><br><span>~ Left: ${formatTime(timeLeft)}</span>`; if(isNight&&!wasNight){console.log("Night begins! Spawning monsters...");const count=monsters.length,space=MAX_MONSTER_COUNT-count,toSpawn=Math.min(NIGHTLY_MONSTER_SPAWN_COUNT,space);if(toSpawn>0){const h=50;let spawned=0,attempts=0,MAX_ATT=toSpawn*5;while(spawned<toSpawn&&attempts<MAX_ATT){attempts++;const x=Math.random()*WORLD_WIDTH,y=Math.random()*WORLD_HEIGHT;if((x>JUNGLE_LAKE.x&&x<JUNGLE_LAKE.x+JUNGLE_LAKE.width&&y>JUNGLE_LAKE.y&&y<JUNGLE_LAKE.y+JUNGLE_LAKE.height)||lavaPools.some(p=>x>p.x&&x<p.x+p.width&&y>p.y&&y<p.y+p.height)||(x<ISLAND_PADDING/2||x>WORLD_WIDTH-ISLAND_PADDING/2||y<ISLAND_PADDING/2||y>WORLD_HEIGHT-ISLAND_PADDING/2)||distanceSq(x,y,player.x,player.y)<(MONSTER_DETECT_RANGE*1.5)**2||checkCollision(10,x,y,null,solidObjects))continue;const mon={id:`mon_${Date.now()}_${Math.random()}`,x:x,y:y,radius:10+Math.random()*5,type:'slime',color:'#DC143C',maxHealth:h*2,health:h*2,flashUntil:0,state:'idle',attackCooldown:MONSTER_ATTACK_COOLDOWN,lastAttackTime:0,target:null,isAttackable:true,isSolid:false};monsters.push(mon);spawned++;}if(attempts>=MAX_ATT&&spawned<toSpawn)console.warn("Max attempts for nightly spawn.");console.log(`Spawned ${spawned} new slimes. Total:${monsters.length}`);}} }
function updateUI() { healthValueSpan.textContent=Math.floor(player.health); maxHealthValueSpan.textContent=Math.floor(player.maxHealth); hungerValueSpan.textContent=Math.floor(player.hunger); dayValueSpan.textContent=dayCount; levelValueSpan.textContent=player.level; xpValueSpan.textContent=`${player.currentXP}/${player.xpToNextLevel}`; if(gameHasStarted&&minionInfoBar){if(player.className==='necromancer'){minionInfoBar.style.display='block';const killsNeeded=CLASS_DATA.necromancer.killsToSummon;minionInfoBar.textContent=`Undead: ${undeadMinions.length}/${MAX_UNDEAD_MINIONS} | Kills: ${player.monsterKillCount%killsNeeded}/${killsNeeded}`;}else if(player.className==='summoner'){minionInfoBar.style.display='block';const currentMaxSlimes=MAX_SUMMONED_SLIMES+player.bonusMaxSummons;minionInfoBar.textContent=`Slimes: ${summonedSlimes.length}/${currentMaxSlimes}`;}else{minionInfoBar.style.display='none';}}else if(minionInfoBar){minionInfoBar.style.display='none';} let debugSpeedPenalty=(!isNight&&player.daySpeedPenalty<1.0)?` DaySpeed:x${player.daySpeedPenalty.toFixed(2)}`:''; let necroKills = player.className === 'necromancer' ? ` NKills:${player.monsterKillCount}` : ''; debugDiv.textContent=`World:(${Math.round(player.x)},${Math.round(player.y)})|Mouse:(${Math.round(worldMouseX)},${Math.round(worldMouseY)})|Res:${resources.length}|Mon:${monsters.length}|Undead:${undeadMinions.length}|Summon:${summonedSlimes.length}|Boss:${bosses.length}|Items:${droppedItems.length}|Proj:${projectiles.length}|SpeedM:${(PLAYER_SPEED*player.speedMultiplier*player.bonusMovementSpeedMult*player.weaponMoveSpeedMult).toFixed(2)}${debugSpeedPenalty}${necroKills}`; }
function update(deltaTime) { if (isGameOver || !gameHasStarted || gamePaused) return; if (!deltaTime || deltaTime > 500) deltaTime = 16; if(isMouseDown && !player.isInteracting && !isCraftingMenuOpen) { if(player.equippedItemType && ITEM_DATA[player.equippedItemType]?.toolType !== 'bow') { player.isAttacking = true; player.attackTimer = Date.now(); } tryAttack(); } else { if(player.equippedItemType && ITEM_DATA[player.equippedItemType]?.toolType !== 'bow' && player.isAttacking && Date.now() - player.attackTimer > ATTACK_DURATION) { player.isAttacking = false; } } updatePlayer(deltaTime); updateMonsters(deltaTime); updateBosses(deltaTime); updateUndeadMinions(deltaTime); updateSummonedSlimes(deltaTime); updatePets(deltaTime); // Added Pet update
    updateProjectiles(deltaTime); updateWorld(deltaTime); clampCamera(); updateUI(); }

// --- Undead Minion Functions ---
function spawnUndeadMinion(x, y) { const baseSlimeHealth=50*2; const undeadHealth=baseSlimeHealth*UNDEAD_BASE_HEALTH_MULT*player.bonusUndeadHealthMult; const minion={id:`undead_${Date.now()}_${Math.random()}`,ownerId:player.id,x:x+(Math.random()-0.5)*10,y:y+(Math.random()-0.5)*10,radius:UNDEAD_RADIUS,type:'undead_minion',color:UNDEAD_COLOR,maxHealth:undeadHealth,health:undeadHealth,flashUntil:0,speed:UNDEAD_SPEED,state:'idle',attackTarget:null,targetType:null,wanderTargetX:null,wanderTargetY:null,lastWanderChange:0,attackCooldown:UNDEAD_ATTACK_COOLDOWN,lastAttackTime:0,damage:UNDEAD_DAMAGE,detectRangeSq:Infinity, attackRange:UNDEAD_ATTACK_RANGE,isSolid:false,isAttackable:true}; undeadMinions.push(minion); console.log(`Spawned undead ${minion.id} (HP: ${Math.floor(undeadHealth)})`); }
// updateUndeadMinions defined earlier
function drawUndeadMinions() { if(!gameHasStarted||undeadMinions.length===0)return; const now=Date.now(); ctx.save(); undeadMinions.forEach(minion=>{ctx.save();ctx.translate(minion.x,minion.y); if(minion.health<minion.maxHealth&&minion.health>0){const bw=minion.radius*1.8,bh=3,barY=-minion.radius-bh-2; ctx.fillStyle='#444';ctx.fillRect(-bw/2,barY,bw,bh); ctx.fillStyle='#BBB';ctx.fillRect(-bw/2,barY,bw*(minion.health/minion.maxHealth),bh);} ctx.fillStyle=(minion.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFF':minion.color; ctx.beginPath();ctx.arc(0,0,minion.radius,0,Math.PI*2);ctx.fill(); ctx.strokeStyle="#555";ctx.lineWidth=1;ctx.stroke(); ctx.restore();}); ctx.restore(); }

// --- Summoner Ability Functions ---
function trySummonSlime() { const currentMaxSlimes = MAX_SUMMONED_SLIMES + player.bonusMaxSummons; if (summonedSlimes.length >= currentMaxSlimes) { console.log("Max summoned slimes reached. Removing oldest..."); const oldestSlime = summonedSlimes.shift(); } console.log("Attempting to summon slime..."); const spawnDist = player.radius + SUMMONED_SLIME_RADIUS + 5; const spawnX = player.x + Math.cos(player.angle) * spawnDist; const spawnY = player.y + Math.sin(player.angle) * spawnDist; spawnSummonedSlime(spawnX, spawnY); }
function spawnSummonedSlime(x, y) { const baseSlimeHealth = 50 * 2; const slimeHealth = baseSlimeHealth * SUMMONED_SLIME_HEALTH_MULT * player.bonusSummonHealthMult; const slime = { id: `sum_slime_${Date.now()}_${Math.random()}`, ownerId: player.id, x: x, y: y, radius: SUMMONED_SLIME_RADIUS, type: 'summoned_slime', color: SUMMONED_SLIME_COLOR, maxHealth: slimeHealth, health: slimeHealth, flashUntil: 0, speed: SUMMONED_SLIME_SPEED, state: 'following', attackTarget: null, targetType: null, wanderTargetX: null, wanderTargetY: null, lastWanderChange: 0, attackCooldown: SUMMONED_SLIME_ATTACK_COOLDOWN, lastAttackTime: 0, damage: SUMMONED_SLIME_DAMAGE * player.bonusSummonDamageMult, detectRangeSq: SUMMONED_SLIME_DETECT_RANGE_SQ, attackRange: SUMMONED_SLIME_ATTACK_RANGE, isSolid: false, isAttackable: true }; summonedSlimes.push(slime); console.log(`Summoned slime ${slime.id} (HP: ${Math.floor(slimeHealth)})`); }
// updateSummonedSlimes defined earlier
function drawSummonedSlimes() { if(!gameHasStarted||summonedSlimes.length===0)return; const now=Date.now(); ctx.save(); summonedSlimes.forEach(slime=>{ctx.save();ctx.translate(slime.x,slime.y); if(slime.health<slime.maxHealth&&slime.health>0){const bw=slime.radius*1.8,bh=3,barY=-slime.radius-bh-2;ctx.fillStyle='#004d00';ctx.fillRect(-bw/2,barY,bw,bh);ctx.fillStyle='#32CD32';ctx.fillRect(-bw/2,barY,bw*(slime.health/slime.maxHealth),bh);} ctx.fillStyle=(slime.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFFFFF':slime.color;ctx.beginPath();ctx.arc(0,0,slime.radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle="#006400";ctx.lineWidth=1;ctx.stroke();ctx.restore();}); ctx.restore(); }

// --- Necromancer Ability Functions ---
function trySummonUndead() { const killsNeeded = CLASS_DATA.necromancer.killsToSummon; if (player.monsterKillCount >= killsNeeded) { if (undeadMinions.length < MAX_UNDEAD_MINIONS) { console.log("Necromancer summoning undead..."); const spawnDist = player.radius + UNDEAD_RADIUS + 5; const spawnX = player.x + Math.cos(player.angle) * spawnDist; const spawnY = player.y + Math.sin(player.angle) * spawnDist; spawnUndeadMinion(spawnX, spawnY); player.monsterKillCount -= killsNeeded; console.log(`Kills remaining for next summon: ${killsNeeded - (player.monsterKillCount % killsNeeded)}`); updateUI(); } else { console.log("Max undead minions reached."); } } else { console.log(`Necromancer needs ${killsNeeded - player.monsterKillCount} more kills to summon.`); } }
// spawnUndeadMinion defined earlier

// --- Handle Spacebar Press ---
function handleSpacebarPress() { if (player.className === 'summoner') { trySummonSlime(); } else if (player.className === 'necromancer') { trySummonUndead(); } }

// --- Event Listeners for Class Selection ---
classSelect.addEventListener('change', ()=>{startGameButton.disabled=!(classSelect.value&&CLASS_DATA[classSelect.value]);});
startGameButton.addEventListener('click', ()=>{const selectedClass=classSelect.value; if(!selectedClass||!CLASS_DATA[selectedClass]){alert("Select class!");return;} applyClassStats(selectedClass); classSelectionOverlay.style.display='none'; initializeGame();});




// --- Pet Update and Draw ---
function updatePets(deltaTime) {
    if (!player.pet || gamePaused) return;
    const now = Date.now();
    const pet = player.pet;

    // --- Common Logic: Follow player ---
    let targetX = player.x - Math.cos(player.angle + Math.PI) * (player.radius + pet.radius + 5); // Target slightly behind player
    let targetY = player.y - Math.sin(player.angle + Math.PI) * (player.radius + pet.radius + 5);
    let dx = 0, dy = 0;
    const distSqToTarget = distanceSq(pet.x, pet.y, targetX, targetY);
    const followStopDistSq = (PET_FOLLOW_DISTANCE * 0.8)**2; // Threshold to stop following

    if (distSqToTarget > followStopDistSq) {
        const angleToTarget = Math.atan2(targetY - pet.y, targetX - pet.x);
        // Pet matches player's modified speed
        const petSpeed = PLAYER_SPEED * player.speedMultiplier * player.bonusMovementSpeedMult * player.weaponMoveSpeedMult;
        dx = Math.cos(angleToTarget) * petSpeed;
        dy = Math.sin(angleToTarget) * petSpeed;
    }

    // --- Pet Specific Logic ---
    let petTarget = null; // For attack pets
    let minDistSq = Infinity;

    switch (pet.type) {
        case 'frog':
            if (now - player.lastPetHealTime > PET_FROG_HEAL_COOLDOWN) {
                if (player.health < player.maxHealth) {
                    player.health = Math.min(player.maxHealth, player.health + PET_FROG_HEAL_AMOUNT);
                    console.log(`%cFrog healed player for ${PET_FROG_HEAL_AMOUNT} HP!`, 'color: lightgreen');
                    player.lastPetHealTime = now;
                    updateUI();
                    // Add visual effect? e.g., flash pet green
                    pet.flashUntil = now + 200;
                }
            }
            break;
        case 'cat':
        case 'dog':
            // Find nearest visible enemy
            const attackPetDetectRangeSq = (MONSTER_DETECT_RANGE * 1.1)**2; // Slightly more than monsters
            const enemies = [...monsters, ...bosses];
            for (const enemy of enemies) {
                if (enemy.health <= 0) continue;
                const dSq = distanceSq(pet.x, pet.y, enemy.x, enemy.y);
                if (dSq < attackPetDetectRangeSq && dSq < minDistSq) {
                    if (!isLineObstructed(pet.x, pet.y, enemy.x, enemy.y, walls)) {
                        minDistSq = dSq;
                        petTarget = enemy;
                    }
                }
            }
            pet.target = petTarget; // Store target on pet object

            if (pet.target) {
                const angleToEnemy = Math.atan2(pet.target.y - pet.y, pet.target.x - pet.x);
                // Override follow movement if target found
                const petSpeed = PLAYER_SPEED * player.speedMultiplier * player.bonusMovementSpeedMult * player.weaponMoveSpeedMult;
                dx = Math.cos(angleToEnemy) * petSpeed;
                dy = Math.sin(angleToEnemy) * petSpeed;

                if (pet.type === 'cat') {
                    // Cat shoots projectile
                    if (now - pet.lastAttackTime > PET_CAT_ATTACK_COOLDOWN) {
                         console.log(`Cat ${pet.name} firing at ${pet.target.id}`);
                         pet.lastAttackTime = now;
                         const projX = pet.x + Math.cos(angleToEnemy) * (pet.radius + PET_CAT_PROJECTILE_RADIUS + 1);
                         const projY = pet.y + Math.sin(angleToEnemy) * (pet.radius + PET_CAT_PROJECTILE_RADIUS + 1);
                         const projectile = {
                             id: `proj_pet_${pet.type}_${now}`, ownerId: player.id, // Attribute kill to player
                             sourceType: 'pet_cat', x: projX, y: projY,
                             vx: Math.cos(angleToEnemy) * PET_CAT_PROJECTILE_SPEED, vy: Math.sin(angleToEnemy) * PET_CAT_PROJECTILE_SPEED,
                             damage: PET_CAT_PROJECTILE_DAMAGE, range: PET_CAT_PROJECTILE_RANGE, traveled: 0,
                             radius: PET_CAT_PROJECTILE_RADIUS, color: '#FF8C00', // Orange-ish
                             type: 'pet_projectile'
                         };
                         projectiles.push(projectile);
                    }
                } else { // Dog Melee
                    const dogAttackRangeSq = (PET_DOG_ATTACK_RANGE + pet.radius + pet.target.radius)**2;
                    const dogHitRangeSq = (pet.radius + pet.target.radius + MONSTER_HIT_BUFFER)**2;
                    if (minDistSq <= dogAttackRangeSq) { // Stop moving if in range
                        dx = 0; dy = 0;
                        if (now - pet.lastAttackTime > PET_DOG_ATTACK_COOLDOWN) {
                             if(minDistSq <= dogHitRangeSq) { // Only damage if close enough
                                 pet.lastAttackTime = now;
                                 pet.target.health -= PET_DOG_DAMAGE;
                                 pet.target.health = Math.max(0, pet.target.health);
                                 pet.target.flashUntil = now + FLASH_DURATION;
                                 console.log(`Dog ${pet.name} bites ${pet.target.id}. Target HP: ${pet.target.health.toFixed(0)}`);
                                 if (pet.target.health <= 0) {
                                     console.log(`Dog ${pet.name} killed ${pet.target.type || pet.target.id}`);
                                     gainXP((target.isBoss ? PLAINS_BOSS_XP_REWARD : MONSTER_XP_REWARD) * MINION_KILL_XP_MULTIPLIER); // Give player XP
                                     if(pet.target.isBoss) { /* Handle boss death by pet */ }
                                     // Remove target from appropriate array
                                     if (monsters.some(m => m.id === pet.target.id)) monsters = monsters.filter(m => m.id !== pet.target.id);
                                     else if (bosses.some(b => b.id === pet.target.id)) { bosses = bosses.filter(b => b.id !== pet.target.id); solidObjects = solidObjects.filter(s => s.id !== pet.target.id); }
                                     pet.target = null; // Lose target
                                 }
                             }
                        }
                    }
                }
            }
            break;
        case 'beetle':
             if (!pet.blockReady && now - pet.lastBlockTime > PET_BEETLE_BLOCK_COOLDOWN) {
                 pet.blockReady = true;
                 console.log("Beetle block ready!");
                 pet.flashUntil = now + 150; // Visual cue: flash when ready
             }
            break;
         case 'bird':
             for (let j = droppedItems.length - 1; j >= 0; j--) {
                 const item = droppedItems[j];
                 if (distanceSq(pet.x, pet.y, item.x, item.y) < PET_BIRD_PICKUP_RANGE_SQ) {
                     console.log("Bird picked up:", item.type);
                     addToInventory(item.type, 1);
                     droppedItems.splice(j, 1);
                     pet.flashUntil = now + 100; // Visual cue: flash on pickup
                     break;
                 }
             }
             break;
    }

    // Final Movement & Collision (Phase through non-walls/non-placed-solids)
    if (dx !== 0 || dy !== 0) {
        let potentialX = pet.x + dx; let potentialY = pet.y + dy;
        // Pets only collide with walls and maybe placed solid objects (not resources, enemies, etc.)
        const petCollisionCheckList = [...walls, ...solidObjects.filter(o => o.isPlaced)];
        let collidedWith = checkCollision(pet.radius, potentialX, potentialY, player.id, petCollisionCheckList);

        if (!collidedWith) { pet.x = potentialX; pet.y = potentialY; }
        else { // Sliding logic (simple version)
             potentialX = pet.x + dx; potentialY = pet.y;
             if (!checkCollision(pet.radius, potentialX, potentialY, player.id, petCollisionCheckList)) { pet.x = potentialX; }
             else { potentialX = pet.x; potentialY = pet.y + dy; if (!checkCollision(pet.radius, potentialX, potentialY, player.id, petCollisionCheckList)) { pet.y = potentialY; } }
        }
         pet.x = Math.max(pet.radius, Math.min(WORLD_WIDTH - pet.radius, pet.x));
         pet.y = Math.max(pet.radius, Math.min(WORLD_HEIGHT - pet.radius, pet.y));
    }
}

function drawPets() {
    if (!player.pet || gamePaused) return;
    const pet = player.pet;
    const now = Date.now();
    ctx.save();
    ctx.translate(pet.x, pet.y);

    // Basic body
    ctx.fillStyle = (pet.flashUntil > now && Math.floor(now / 50) % 2 === 0) ? '#FFF' : pet.color;
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, pet.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Add simple features
    ctx.fillStyle = 'black';
    if (pet.type === 'frog' || pet.type === 'cat' || pet.type === 'dog') { // Eyes
        ctx.beginPath(); ctx.arc(-pet.radius * 0.4, -pet.radius * 0.2, 2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(pet.radius * 0.4, -pet.radius * 0.2, 2, 0, Math.PI * 2); ctx.fill();
    } else if (pet.type === 'beetle') { // Antennae
        ctx.beginPath(); ctx.moveTo(0, -pet.radius); ctx.lineTo(-3, -pet.radius - 4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -pet.radius); ctx.lineTo(3, -pet.radius - 4); ctx.stroke();
        if(!pet.blockReady){ // Cooldown visual
            ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
            ctx.beginPath(); ctx.arc(0, 0, pet.radius+1, 0, Math.PI * 2); ctx.fill();
        }
    } else if (pet.type === 'bird') { // Beak
        ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(0, -pet.radius * 0.5); ctx.lineTo(pet.radius, 0); ctx.lineTo(0, pet.radius * 0.5); ctx.closePath(); ctx.fill();
    }

    ctx.restore();
}

// --- Draw Functions ---
function drawWorldBackground() { ctx.save(); ctx.fillStyle=BIOME_DATA.desert.color;ctx.fillRect(0,BIOME_BOUNDS.DESERT_Y_START,WORLD_WIDTH,WORLD_HEIGHT-BIOME_BOUNDS.DESERT_Y_START); ctx.fillStyle=BIOME_DATA.frostlands.color;ctx.fillRect(0,0,WORLD_WIDTH,BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=BIOME_DATA.forest.color;ctx.fillRect(0,BIOME_BOUNDS.FROSTLANDS_Y_END,BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=BIOME_DATA.jungle.color;ctx.fillRect(BIOME_BOUNDS.JUNGLE_X_START,BIOME_BOUNDS.FROSTLANDS_Y_END,WORLD_WIDTH-BIOME_BOUNDS.JUNGLE_X_START,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=BIOME_DATA.rocky.color;ctx.fillRect(0,0,BIOME_BOUNDS.ROCKY_X_END,BIOME_BOUNDS.ROCKY_Y_END); ctx.fillStyle=BIOME_DATA.swamp.color;ctx.fillRect(BIOME_BOUNDS.SWAMP_X_START,0,WORLD_WIDTH-BIOME_BOUNDS.SWAMP_X_START,BIOME_BOUNDS.SWAMP_Y_END); ctx.fillStyle=BIOME_DATA.volcano.color;ctx.fillRect(0,BIOME_BOUNDS.VOLCANO_Y_START,BIOME_BOUNDS.VOLCANO_X_END,WORLD_HEIGHT-BIOME_BOUNDS.VOLCANO_Y_START); ctx.fillStyle=BIOME_DATA.badlands.color;ctx.fillRect(BIOME_BOUNDS.BADLANDS_X_START,BIOME_BOUNDS.BADLANDS_Y_START,WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START,WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START); ctx.fillStyle=BIOME_DATA.plains.color;ctx.fillRect(BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.FROSTLANDS_Y_END,BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=JUNGLE_LAKE.color;ctx.fillRect(JUNGLE_LAKE.x,JUNGLE_LAKE.y,JUNGLE_LAKE.width,JUNGLE_LAKE.height); lavaPools.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x,p.y,p.width,p.height);}); ctx.restore(); }
function drawBiomeWalls() { ctx.save();ctx.fillStyle=WALL_COLOR;ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=1;walls.forEach(w=>{ctx.fillRect(w.x,w.y,w.width,w.height);ctx.strokeRect(w.x,w.y,w.width,w.height);});ctx.restore(); }
function drawResources() { const now=Date.now();resources.forEach(res=>{ctx.save();ctx.translate(res.x,res.y);if(res.isAttackable&&res.health<res.maxHealth&&res.health>0){const bw=res.radius*1.5,bh=5,by=-res.radius-bh-3;ctx.fillStyle='#666';ctx.fillRect(-bw/2,by,bw,bh);let hc='#DDD';if(res.type==='tree'||res.type==='bone_tree')hc='#228B22';else if(res.type==='rock')hc='#A9A9A9';else if(res.isPlaced)hc='#4682B4';ctx.fillStyle=hc;ctx.fillRect(-bw/2,by,bw*(res.health/res.maxHealth),bh);}const baseColor=res.color||ITEM_DATA[res.type]?.color||'magenta';ctx.fillStyle=(res.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFF':baseColor;if(res.type==='workbench'||res.type==='stone_block'||res.type==='wood_plank'||res.type==='icky_bed'||res.type==='item_upgrader_t1'){ctx.fillRect(-res.radius,-res.radius,res.radius*2,res.radius*2);ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=1;ctx.strokeRect(-res.radius,-res.radius,res.radius*2,res.radius*2);}else if(res.type==='torch'){const sh=res.radius*3,sw=res.radius*0.6,fh=res.radius*1.5;ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-sw/2,-sh/2+fh*0.4,sw,sh);ctx.fillStyle=baseColor;ctx.beginPath();ctx.ellipse(0,-sh/2,sw*1.2,fh,0,0,Math.PI*2);ctx.fill();}else if(res.type==='cactus'){const cw=res.radius*0.6,ch=res.radius*2;ctx.fillStyle=baseColor;ctx.fillRect(-cw/2,-ch/2,cw,ch);ctx.fillRect(-cw*1.5,-ch*0.1,cw*2.5,cw*0.8);ctx.strokeStyle='darkgreen';ctx.lineWidth=1;ctx.strokeRect(-cw/2,-ch/2,cw,ch);}else if(res.type==='tree'||res.type==='bone_tree'){ctx.beginPath();ctx.arc(0,0,res.radius,0,Math.PI*2);ctx.fillStyle=res.variant==='bone'?'#DDD':baseColor;ctx.fill();ctx.fillStyle=res.variant==='bone'?'#999':'#A0522D';const tw=res.radius*0.4,th=res.radius*0.6;ctx.fillRect(-tw/2,0,tw,th);if(res.variant==='snowy'){ctx.fillStyle='rgba(255,255,255,0.8)';ctx.beginPath();ctx.arc(0,-res.radius*0.3,res.radius*0.9,0,Math.PI*2);ctx.fill();}}else{ctx.beginPath();ctx.arc(0,0,res.radius,0,Math.PI*2);ctx.fill();if(res.type==='rock'){ctx.strokeStyle='rgba(0,0,0,0.3)';ctx.lineWidth=1;ctx.stroke();}}ctx.restore();}); }
function drawMonsters() { const now=Date.now();monsters.forEach(mon=>{ctx.save();ctx.translate(mon.x,mon.y);if(mon.health<mon.maxHealth&&mon.health>0){const bw=mon.radius*1.5,bh=4,by=-mon.radius-bh-2;ctx.fillStyle='#550000';ctx.fillRect(-bw/2,by,bw,bh);ctx.fillStyle='#FF0000';ctx.fillRect(-bw/2,by,bw*(mon.health/mon.maxHealth),bh);}ctx.fillStyle=(mon.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFF':mon.color;ctx.beginPath();ctx.arc(0,0,mon.radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle="black";ctx.lineWidth=1;ctx.stroke();ctx.restore();}); }
function drawBosses() { bosses.forEach(boss=>{if(boss.health<=0)return;const now=Date.now();ctx.save();ctx.translate(boss.x,boss.y);if(boss.health<boss.maxHealth){const barWidth=boss.radius*1.8;const barHeight=8;const barY=-boss.radius-barHeight-10;ctx.fillStyle='#440000';ctx.fillRect(-barWidth/2,barY,barWidth,barHeight);ctx.fillStyle='#FF3333';ctx.fillRect(-barWidth/2,barY,barWidth*(boss.health/boss.maxHealth),barHeight);ctx.strokeStyle='black';ctx.lineWidth=1;ctx.strokeRect(-barWidth/2,barY,barWidth,barHeight);} if(boss.type==='plains_boss'){ctx.fillStyle='#776B5D';ctx.beginPath();ctx.arc(0,0,boss.radius,0,Math.PI*2);ctx.fill();ctx.fillStyle='#8B4513';ctx.beginPath();ctx.ellipse(-boss.radius*0.4,-boss.radius*0.3,boss.radius*0.3,boss.radius*0.5,Math.PI/4,0,Math.PI*2);ctx.fill();ctx.fillStyle='#696969';ctx.beginPath();ctx.ellipse(boss.radius*0.3,boss.radius*0.4,boss.radius*0.4,boss.radius*0.2,-Math.PI/6,0,Math.PI*2);ctx.fill();ctx.strokeStyle='#3A3127';ctx.lineWidth=3;ctx.stroke();const armR=boss.radius*0.3,armD=boss.radius+armR*0.8;let leftA=boss.angle-Math.PI/1.5,rightA=boss.angle+Math.PI/1.5;if(boss.state==='attacking_hit'){const p=boss.attackAnimationTimer/ATTACK_DURATION;rightA=boss.angle+Math.PI/1.5+Math.sin(p*Math.PI)*1.5;}else if(boss.state==='attacking_smash'){const p=Math.min(1,boss.attackAnimationTimer/BOSS_SMASH_WINDUP);leftA=boss.angle-Math.PI/1.5-p*Math.PI*0.8;rightA=boss.angle+Math.PI/1.5+p*Math.PI*0.8;}else if(boss.state==='attacking_spin'){const p=boss.attackAnimationTimer/BOSS_SPIN_DURATION,spinOff=p*Math.PI*4;leftA=boss.angle+spinOff-Math.PI/1.5;rightA=boss.angle+spinOff+Math.PI/1.5;}ctx.fillStyle='#8B4513';const leftX=Math.cos(leftA)*armD,leftY=Math.sin(leftA)*armD;ctx.beginPath();ctx.arc(leftX,leftY,armR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.fillStyle='#696969';const rightX=Math.cos(rightA)*armD,rightY=Math.sin(rightA)*armD;ctx.beginPath();ctx.arc(rightX,rightY,armR*1.1,0,Math.PI*2);ctx.fill();ctx.stroke();if(boss.state==='attacking_smash'&&boss.attackAnimationTimer>=BOSS_SMASH_WINDUP){ctx.save();const ep=(boss.attackAnimationTimer-BOSS_SMASH_WINDUP)/BOSS_SMASH_EFFECT_DURATION;ctx.globalAlpha=Math.max(0,1.0-ep);ctx.strokeStyle='red';ctx.lineWidth=5+(1-ep)*5;ctx.beginPath();ctx.arc(0,0,BOSS_SMASH_RANGE*ep,0,Math.PI*2);ctx.stroke();ctx.restore();}if(boss.state==='attacking_spin'){ctx.save();ctx.globalAlpha=0.5;ctx.strokeStyle='white';ctx.lineWidth=2+Math.sin(now/50)*2;ctx.beginPath();ctx.arc(0,0,BOSS_SPIN_RANGE-5,0,Math.PI*2);ctx.stroke();ctx.beginPath();ctx.arc(0,0,BOSS_SPIN_RANGE-15,0,Math.PI*2);ctx.stroke();ctx.restore();}} else if(boss.type==='forest_wolf'){ctx.rotate(boss.angle);const bodyL=FOREST_WOLF_BODY_LENGTH;const bodyW=FOREST_WOLF_BODY_WIDTH;const headR=FOREST_WOLF_HEAD_RADIUS;const legR=FOREST_WOLF_LEG_RADIUS;const headOffsetX=bodyL/2+headR*0.6;ctx.fillStyle=boss.color;ctx.strokeStyle='#444';ctx.lineWidth=1;const legOffsetY=bodyW/2+legR*0.5;const legOffsetXFront=bodyL*0.35;const legOffsetXBack=-bodyL*0.35;ctx.beginPath();ctx.arc(legOffsetXFront,legOffsetY,legR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(legOffsetXFront,-legOffsetY,legR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(legOffsetXBack,legOffsetY,legR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(legOffsetXBack,-legOffsetY,legR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.fillStyle=boss.color;ctx.fillRect(-bodyL/2,-bodyW/2,bodyL,bodyW);ctx.strokeRect(-bodyL/2,-bodyW/2,bodyL,bodyW);ctx.fillStyle=boss.color;ctx.beginPath();ctx.arc(headOffsetX,0,headR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.fillStyle='#FF0000';const eyeOffsetY=headR*0.4;const eyeOffsetX=headOffsetX+headR*0.3;const eyeRadius=headR*0.2;ctx.beginPath();ctx.arc(eyeOffsetX,eyeOffsetY,eyeRadius,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(eyeOffsetX,-eyeOffsetY,eyeRadius,0,Math.PI*2);ctx.fill();} else if(boss.type==='jungle_boss'){const pulseFactor=0.9+Math.sin(now/300)*0.1;const currentRadius=boss.radius*pulseFactor;ctx.fillStyle=boss.color;ctx.globalAlpha=0.8;ctx.beginPath();ctx.arc(0,0,currentRadius,0,Math.PI*2);ctx.fill();ctx.fillStyle='#40E0D0';ctx.globalAlpha=0.9;ctx.beginPath();ctx.arc(0,0,currentRadius*0.6,0,Math.PI*2);ctx.fill();ctx.fillStyle='#FFFFFF';ctx.globalAlpha=1.0;const eyeRadius=currentRadius*0.15;const eyeOffsetX=currentRadius*0.3;const eyeAngle=boss.angle;ctx.beginPath();ctx.arc(Math.cos(eyeAngle-0.5)*eyeOffsetX,Math.sin(eyeAngle-0.5)*eyeOffsetX,eyeRadius,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(Math.cos(eyeAngle+0.5)*eyeOffsetX,Math.sin(eyeAngle+0.5)*eyeOffsetX,eyeRadius,0,Math.PI*2);ctx.fill();} ctx.restore();}); }
function drawDroppedItems() { ctx.save(); droppedItems.forEach(item => { const itemData = ITEM_DATA[item.type]; if (!itemData) return; ctx.save(); ctx.translate(item.x, item.y); ctx.fillStyle = itemData.color || '#FFFFFF'; ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 1; const size = item.radius * 1.8; switch (itemData.shape) { case 'line': ctx.beginPath(); ctx.moveTo(-size * 0.7, 0); ctx.lineTo(size * 0.7, 0); ctx.lineWidth = 3; ctx.stroke(); break; case 'rect': ctx.fillRect(-size / 2, -size / 2, size, size); ctx.strokeRect(-size / 2, -size / 2, size, size); break; case 'torch': { const stickH = size * 1.2; const stickW = size * 0.2; const flameH = size * 0.6; ctx.fillStyle = ITEM_DATA['stick']?.color || '#B8860B'; ctx.fillRect(-stickW / 2, -stickH / 2 + flameH * 0.4, stickW, stickH); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.ellipse(0, -stickH / 2, stickW * 1.2, flameH, 0, 0, Math.PI * 2); ctx.fill(); break; } case 'sword': { const swordH = size * 1.5; const swordW = size * 0.2; const guardW = size * 0.5; ctx.fillStyle = '#444'; ctx.fillRect(-swordW * 1.2, swordH * 0.2, swordW * 2.4, swordH * 0.2); ctx.fillStyle = '#888'; ctx.fillRect(-guardW / 2, swordH * 0.1, guardW, swordW * 2); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.moveTo(0, -swordH * 0.4); ctx.lineTo(-swordW, swordH * 0.1); ctx.lineTo(swordW, swordH * 0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); break; } case 'axe': case 'pickaxe': { const handleH = size * 1.4; const handleW = size * 0.2; const headW = size * 0.7; const headH = size*0.5; ctx.fillStyle = ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-handleW/2, -handleH/2+headH/2, handleW, handleH); ctx.strokeRect(-handleW/2, -handleH/2+headH/2, handleW, handleH); ctx.fillStyle = itemData.color; ctx.fillRect(-headW/2, -handleH/2, headW, headH); ctx.strokeRect(-headW/2, -handleH/2, headW, headH); break; } case 'bow': ctx.beginPath(); ctx.moveTo(0, -size * 0.6); ctx.quadraticCurveTo(-size * 0.7, 0, 0, size * 0.6); ctx.quadraticCurveTo(size * 0.7, 0, 0, -size * 0.6); ctx.moveTo(-size*0.1, -size*0.5); ctx.lineTo(-size*0.1, size*0.5); ctx.lineWidth = 1; ctx.strokeStyle = '#eee'; ctx.stroke(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke(); ctx.fill(); break; case 'cactus': const cW = size * 0.4; const cH = size * 1.3; ctx.fillRect(-cW/2,-cH/2, cW, cH); ctx.fillRect(-cW*1.2, -cH*0.1, cW*2.4, cW*0.6); ctx.strokeStyle='darkgreen'; ctx.strokeRect(-cW/2,-cH/2, cW, cH); break; case 'circle': default: ctx.beginPath(); ctx.arc(0, 0, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); break; } ctx.restore(); }); ctx.restore(); }
function drawPlayer() { ctx.save();ctx.translate(player.x,player.y);ctx.fillStyle='#87CEEB';ctx.beginPath();ctx.arc(0,0,player.radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle='#4682B4';ctx.lineWidth=2;ctx.stroke();let handBase=player.angle,handDist=HAND_DISTANCE,currentHandA=handBase,rightHandRelA=handBase+Math.PI/4;if(player.isAttacking){const prog=(Date.now()-player.attackTimer)/ATTACK_DURATION;if(player.equippedItemType&&ITEM_DATA[player.equippedItemType]?.toolType!=='bow'){const swing=Math.sin(prog*Math.PI)*ATTACK_SWING_ARC;currentHandA=handBase+swing-ATTACK_SWING_ARC/2;rightHandRelA=currentHandA+Math.PI/4;}else if(player.equippedItemType&&ITEM_DATA[player.equippedItemType]?.toolType==='bow'){const draw=Math.sin(prog*Math.PI)*5;handDist-=draw;currentHandA=handBase;rightHandRelA=handBase+Math.PI/4;}}else if(player.isInteracting){const prog=(Date.now()-player.interactTimer)/INTERACT_DURATION;const pulse=Math.sin(prog*Math.PI)*5;handDist+=pulse;currentHandA=handBase;rightHandRelA=currentHandA+Math.PI/4;}const handOff=Math.PI/4;const lx=Math.cos(currentHandA-handOff)*handDist,ly=Math.sin(currentHandA-handOff)*handDist,rx=Math.cos(currentHandA+handOff)*handDist,ry=Math.sin(currentHandA+handOff)*handDist;ctx.fillStyle='#FFDAB9';ctx.beginPath();ctx.arc(lx,ly,LIMB_RADIUS,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(rx,ry,LIMB_RADIUS,0,Math.PI*2);ctx.fill();if(player.equippedItemType){const d=ITEM_DATA[player.equippedItemType];if(d){ctx.save();const size=18,itemDist=handDist+LIMB_RADIUS-size*0.1;const ix=Math.cos(rightHandRelA)*itemDist,iy=Math.sin(rightHandRelA)*itemDist;ctx.translate(ix,iy);ctx.rotate(player.angle+Math.PI/4);const scale=size/30;ctx.scale(scale,scale);const shapeSize=18;ctx.fillStyle=d.color;ctx.strokeStyle='black';ctx.lineWidth=1/scale;switch(d.shape){case 'line':ctx.beginPath();ctx.moveTo(0,-shapeSize*0.6);ctx.lineTo(0,shapeSize*0.6);ctx.lineWidth=3;ctx.stroke();break;case 'rect':ctx.fillRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);ctx.strokeRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);break;case 'torch':const sH=shapeSize*1.0,sW=shapeSize*0.2,fH=shapeSize*0.5;ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-sW/2,sH*0.1,sW,sH*0.9);ctx.fillStyle=d.color;ctx.beginPath();ctx.ellipse(0,-sH*0.25,sW*1.5,fH,0,0,Math.PI*2);ctx.fill();break;case 'sword':const swH=shapeSize*1.3,swW=shapeSize*0.15,gW=shapeSize*0.4;ctx.fillStyle='#444';ctx.fillRect(-swW*1.2,swH*0.2,swW*2.4,swH*0.2);ctx.fillStyle='#888';ctx.fillRect(-gW/2,swH*0.1,gW,swW*2);ctx.fillStyle=d.color;ctx.beginPath();ctx.moveTo(0,-swH*0.4);ctx.lineTo(-swW,swH*0.1);ctx.lineTo(swW,swH*0.1);ctx.closePath();ctx.fill();ctx.stroke();break;case 'axe':case 'pickaxe':const hH=shapeSize*1.2,hW=shapeSize*0.15,hdW=shapeSize*0.6,hdH=shapeSize*0.4;ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-hW/2,-hH/2+hdH/2,hW,hH);ctx.strokeRect(-hW/2,-hH/2+hdH/2,hW,hH);ctx.fillStyle=d.color;ctx.fillRect(-hdW/2,-hH/2,hdW,hdH);ctx.strokeRect(-hdW/2,-hH/2,hdW,hdH);break;case 'bow':ctx.rotate(-Math.PI/4);ctx.beginPath();ctx.moveTo(0,-shapeSize*0.7);ctx.quadraticCurveTo(-shapeSize*0.8,0,0,shapeSize*0.7);ctx.quadraticCurveTo(shapeSize*0.8,0,0,-shapeSize*0.7);ctx.moveTo(-shapeSize*0.1,-shapeSize*0.6);ctx.lineTo(-shapeSize*0.1,shapeSize*0.6);ctx.lineWidth=1.5;ctx.strokeStyle='#eee';ctx.stroke();ctx.lineWidth=2.5;ctx.strokeStyle='black';ctx.stroke();ctx.fill();break;case 'circle':default:ctx.beginPath();ctx.arc(0,0,shapeSize*0.4,0,Math.PI*2);ctx.fill();ctx.stroke();break;}ctx.restore();}}ctx.restore(); }
function drawProjectiles() { ctx.save();projectiles.forEach(p=>{ctx.fillStyle=p.color||'#FFF';ctx.strokeStyle=p.color||'#FFF';ctx.save();ctx.translate(p.x,p.y);ctx.rotate(Math.atan2(p.vy,p.vx));ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-p.radius*2.5,0);ctx.lineTo(p.radius*1.5,0);ctx.lineTo(p.radius*0.8,-p.radius*0.6);ctx.moveTo(p.radius*1.5,0);ctx.lineTo(p.radius*0.8,p.radius*0.6);ctx.stroke();ctx.restore();});ctx.restore(); }
function worldToMinimap(wx, wy, mx, my, mw, mh) { const sx=mw/WORLD_WIDTH, sy=mh/WORLD_HEIGHT; return {x:mx+wx*sx, y:my+wy*sy}; }
function drawMinimap(ctx) { if(!isMinimapVisible)return; ctx.save();const mapX=canvas.width-MINIMAP_WIDTH-MINIMAP_PADDING,mapY=canvas.height-MINIMAP_HEIGHT-MINIMAP_PADDING;ctx.globalAlpha=MINIMAP_ALPHA;ctx.fillStyle='#555';ctx.fillRect(mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.globalAlpha=1.0;ctx.strokeStyle='#FFF';ctx.lineWidth=1;ctx.strokeRect(mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.save();ctx.rect(mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.clip();for(const biomeName in BIOME_DATA){const biome=BIOME_DATA[biomeName];ctx.fillStyle=biome.color;let bx,by,bw,bh;switch(biomeName){case 'plains':bx=BIOME_BOUNDS.FOREST_X_END;by=BIOME_BOUNDS.FROSTLANDS_Y_END;bw=BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END;bh=BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'forest':bx=0;by=BIOME_BOUNDS.FROSTLANDS_Y_END;bw=BIOME_BOUNDS.FOREST_X_END;bh=BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'jungle':bx=BIOME_BOUNDS.JUNGLE_X_START;by=BIOME_BOUNDS.FROSTLANDS_Y_END;bw=WORLD_WIDTH-BIOME_BOUNDS.JUNGLE_X_START;bh=BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'frostlands':bx=0;by=0;bw=WORLD_WIDTH;bh=BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'desert':bx=0;by=BIOME_BOUNDS.DESERT_Y_START;bw=WORLD_WIDTH;bh=WORLD_HEIGHT-BIOME_BOUNDS.DESERT_Y_START;break;case 'rocky':bx=0;by=0;bw=BIOME_BOUNDS.ROCKY_X_END;bh=BIOME_BOUNDS.ROCKY_Y_END;break;case 'swamp':bx=BIOME_BOUNDS.SWAMP_X_START;by=0;bw=WORLD_WIDTH-BIOME_BOUNDS.SWAMP_X_START;bh=BIOME_BOUNDS.SWAMP_Y_END;break;case 'volcano':bx=0;by=BIOME_BOUNDS.VOLCANO_Y_START;bw=BIOME_BOUNDS.VOLCANO_X_END;bh=WORLD_HEIGHT-BIOME_BOUNDS.VOLCANO_Y_START;break;case 'badlands':bx=BIOME_BOUNDS.BADLANDS_X_START;by=BIOME_BOUNDS.BADLANDS_Y_START;bw=WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START;bh=WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START;break;default:continue;}const start=worldToMinimap(bx,by,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);const end=worldToMinimap(bx+bw,by+bh,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillRect(start.x,start.y,end.x-start.x,end.y-start.y);}ctx.restore();const pPos=worldToMinimap(player.x,player.y,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillStyle=MINIMAP_PLAYER_COLOR;ctx.beginPath();ctx.arc(pPos.x,pPos.y,MINIMAP_PLAYER_SIZE,0,Math.PI*2);ctx.fill();if(bosses.length>0){bosses.forEach(boss=>{const bPos=worldToMinimap(boss.x,boss.y,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillStyle=MINIMAP_BOSS_COLOR;ctx.fillRect(bPos.x-2,bPos.y-2,5,5);});} const rPos=worldToMinimap(player.respawnX,player.respawnY,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillStyle=MINIMAP_RESPAWN_COLOR;ctx.beginPath();ctx.arc(rPos.x,rPos.y,MINIMAP_PLAYER_SIZE-1,0,Math.PI*2);ctx.fill();ctx.restore(); }
function draw() { if(!gameHasStarted){ctx.clearRect(0,0,canvas.width,canvas.height);return;} ctx.clearRect(0,0,canvas.width,canvas.height);ctx.save();ctx.translate(canvas.width/2-cameraX,canvas.height/2-cameraY); drawWorldBackground();drawBiomeWalls();drawResources();drawMonsters();drawBosses();drawUndeadMinions();drawSummonedSlimes();drawDroppedItems();drawProjectiles();drawPlayer();drawPets(); if(currentNightOpacity>0.01){ctx.save();ctx.fillStyle='#00001a';ctx.globalAlpha=currentNightOpacity;ctx.fillRect(cameraX-canvas.width/2,cameraY-canvas.height/2,canvas.width,canvas.height);ctx.globalAlpha=1.0;ctx.globalCompositeOperation='lighter';resources.forEach(res=>{if(res.isPlaced&&res.lightRadius>0&&res.type==='torch'){const g=ctx.createRadialGradient(res.x,res.y,0,res.x,res.y,res.lightRadius),b=0.6;g.addColorStop(0,`rgba(255,190,120,${b})`);g.addColorStop(0.6,`rgba(200,100,50,${b*0.5})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(res.x,res.y,res.lightRadius,0,Math.PI*2);ctx.fill();}});lavaPools.forEach(p=>{if(p.lightRadius>0){const cX=p.x+p.width/2,cY=p.y+p.height/2,b=p.lightOpacity||0.8,g=ctx.createRadialGradient(cX,cY,0,cX,cY,p.lightRadius);g.addColorStop(0,`rgba(255,100,0,${b*0.9})`);g.addColorStop(0.5,`rgba(255,60,0,${b*0.6})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(cX,cY,p.lightRadius,0,Math.PI*2);ctx.fill();}});if(player.equippedItemType==='torch'){const d=ITEM_DATA['torch'];if(d&&d.lightRadius>0){const r=d.lightRadius,g=ctx.createRadialGradient(player.x,player.y,0,player.x,player.y,r),b=0.65;g.addColorStop(0,`rgba(255,190,120,${b})`);g.addColorStop(0.6,`rgba(200,100,50,${b*0.5})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(player.x,player.y,r,0,Math.PI*2);ctx.fill();}}ctx.restore();} ctx.restore();drawMinimap(ctx); }

// --- Perk Selection Functions ---
function showLevel3PerkMenu() { if (!levelPerkOverlay || !perkChoice1Button || !perkChoice2Button || !perkDescription) return; console.log("Showing Level 3 Perk Menu"); gamePaused = true; let choice1Text = "Perk 1"; let choice2Text = "Perk 2"; let descText = "Choose your path!"; switch (player.className) { case 'knight': choice1Text = "+20 Max HP"; choice2Text = "+15 Sword Damage"; descText = "Strengthen your Resolve or your Blade?"; break; case 'archer': choice1Text = "+10% Move Speed"; choice2Text = "+10% Bow Attack Speed"; descText = "Become Swifter or Shoot Faster?"; break; case 'scout': choice1Text = "+10 Max HP"; choice2Text = "+15 Melee Damage (All)"; descText = "Bolster your Health or Enhance All Melee Strikes?"; break; case 'tank': choice1Text = "+50 Max HP"; choice2Text = "+20 Melee Damage / -15% Speed"; descText = "Become an Immovable Object or a Destructive Force?"; break; case 'vampire': choice1Text = "+2.5 Lifesteal"; choice2Text = "+15% Move Speed"; descText = "Enhance your Vampiric Drain or gain Celerity?"; break; case 'necromancer': choice1Text = "Kills needed per Undead -1"; choice2Text = "+20% Undead Health"; descText = "Improve your Necrotic Rituals or Fortify your Minions?"; break; case 'summoner': choice1Text = "+1 Max Slime"; choice2Text = "+25% Slime Health"; descText = "Expand your Legion or Empower your existing Summons?"; break; default: console.warn("Unknown class for perk menu:", player.className); choice1Text = "Generic Perk 1"; choice2Text = "Generic Perk 2"; break; } perkDescription.textContent = descText; perkChoice1Button.textContent = choice1Text; perkChoice2Button.textContent = choice2Text; perkChoice1Button.replaceWith(perkChoice1Button.cloneNode(true)); perkChoice2Button.replaceWith(perkChoice2Button.cloneNode(true)); const newChoice1Button = document.getElementById('perkChoice1Button'); const newChoice2Button = document.getElementById('perkChoice2Button'); newChoice1Button.addEventListener('click', () => applyPerkChoice(1), { once: true }); newChoice2Button.addEventListener('click', () => applyPerkChoice(2), { once: true }); levelPerkOverlay.style.display = 'flex'; }
function applyPerkChoice(choiceIndex) { if (player.hasChosenLevel3Perk || !gameHasStarted) return; console.log(`Applying Perk Choice ${choiceIndex} for class ${player.className}`); switch (player.className) { case 'knight': if (choiceIndex === 1) { player.bonusMaxHealth += 20; } else { player.bonusSwordDamage += 15; } break; case 'archer': if (choiceIndex === 1) { player.bonusMovementSpeedMult *= 1.10; } else { player.bonusBowAttackSpeedMult *= 0.90; } break; case 'scout': if (choiceIndex === 1) { player.bonusMaxHealth += 10; } else { player.bonusMeleeDamage += 15; } break; case 'tank': if (choiceIndex === 1) { player.bonusMaxHealth += 50; } else { player.bonusMeleeDamage += 20; player.bonusMovementSpeedMult *= 0.85; } break; case 'vampire': if (choiceIndex === 1) { player.bonusLifesteal += 2.5; } else { player.bonusMovementSpeedMult *= 1.15; } break; case 'necromancer': if (choiceIndex === 1) { CLASS_DATA.necromancer.killsToSummon = Math.max(1, (CLASS_DATA.necromancer.killsToSummon || NECROMANCER_KILLS_TO_SUMMON) -1); console.log("Necromancer kills needed reduced to:", CLASS_DATA.necromancer.killsToSummon);} else { player.bonusUndeadHealthMult *= 1.20; } break; case 'summoner': if (choiceIndex === 1) { player.bonusMaxSummons += 1; } else { player.bonusSummonHealthMult *= 1.25; } break; } player.hasChosenLevel3Perk = true; levelPerkOverlay.style.display = 'none'; gamePaused = false; player.maxHealth += player.bonusMaxHealth; player.health += player.bonusMaxHealth; player.bonusMaxHealth = 0; updateUI(); console.log("Perk applied. Player stats updated."); }

// --- Weapon Choice Functions ---
function showWeaponChoiceMenu() { if (!weaponChoiceOverlay || gamePaused) return; console.log("Showing Weapon Choice Menu for class:", player.className); gamePaused = true; const choices = CLASS_WEAPON_CHOICES[player.className] || CLASS_WEAPON_CHOICES.default; weaponChoiceTitle.textContent = "Choose Your Weapon"; weapon1Name.textContent = choices[0].name; weapon1Desc.textContent = choices[0].desc; weapon2Name.textContent = choices[1].name; weapon2Desc.textContent = choices[1].desc; weaponChoice1Button.dataset.weaponId = choices[0].id; weaponChoice2Button.dataset.weaponId = choices[1].id; weaponChoice1Button.replaceWith(weaponChoice1Button.cloneNode(true)); weaponChoice2Button.replaceWith(weaponChoice2Button.cloneNode(true)); document.getElementById('weaponChoice1Button').addEventListener('click', handleWeaponChoice, { once: true }); document.getElementById('weaponChoice2Button').addEventListener('click', handleWeaponChoice, { once: true }); weaponChoiceOverlay.style.display = 'flex'; }
function handleWeaponChoice(event) { const chosenWeaponId = event.target.dataset.weaponId; console.log("Weapon chosen:", chosenWeaponId); let chosenWeaponData = null; for (const classKey in CLASS_WEAPON_CHOICES) { const weapon = CLASS_WEAPON_CHOICES[classKey].find(w => w.id === chosenWeaponId); if (weapon) { chosenWeaponData = weapon; break; } } if (chosenWeaponData) { applyWeaponEffects(chosenWeaponData); player.chosenWeaponId = chosenWeaponId; } else { console.error("Could not find chosen weapon data for ID:", chosenWeaponId); } weaponChoiceOverlay.style.display = 'none'; gamePaused = false; updateUI(); }
function applyWeaponEffects(weaponData) { console.log("Applying effects for:", weaponData.name); player.weaponAttackSpeedMult = 1.0; player.weaponDamageMult = 1.0; player.weaponMoveSpeedMult = 1.0; player.weaponRangeMult = 1.0; player.weaponOnKillHeal = 0; for (const effect in weaponData.effects) { console.log(` - Applying ${effect}: ${weaponData.effects[effect]}`); switch (effect) { case 'weaponDamageMult': player.weaponDamageMult *= weaponData.effects[effect]; break; case 'weaponAttackSpeedMult': player.weaponAttackSpeedMult *= weaponData.effects[effect]; break; case 'weaponMoveSpeedMult': player.bonusMovementSpeedMult *= weaponData.effects[effect]; break; case 'bonusMaxHealth': player.maxHealth += weaponData.effects[effect]; player.health += weaponData.effects[effect]; break; case 'bonusMeleeDamage': player.bonusMeleeDamage += weaponData.effects[effect]; break; case 'weaponRangeMult': player.weaponRangeMult *= weaponData.effects[effect]; break; case 'weaponOnKillHeal': player.weaponOnKillHeal += weaponData.effects[effect]; break; } } player.health = Math.min(player.health, player.maxHealth); }

// --- Pet Choice Functions ---
function showPetChoiceMenu() { if (!petChoiceOverlay || gamePaused || player.pet) return; console.log("Showing Pet Choice Menu"); gamePaused = true; petChoice1Button.textContent = PET_DATA.frog.name; petChoice2Button.textContent = PET_DATA.cat.name; petChoice3Button.textContent = PET_DATA.beetle.name; petChoice4Button.textContent = PET_DATA.bird.name; petChoice5Button.textContent = PET_DATA.dog.name; const buttons = [petChoice1Button, petChoice2Button, petChoice3Button, petChoice4Button, petChoice5Button]; const petTypes = ['frog', 'cat', 'beetle', 'bird', 'dog']; buttons.forEach((button, index) => { const newButton = button.cloneNode(true); button.parentNode.replaceChild(newButton, button); newButton.addEventListener('click', () => applyPetChoice(petTypes[index]), { once: true }); }); petChoiceOverlay.style.display = 'flex'; }
function applyPetChoice(petType) { if (player.pet || !gameHasStarted) return; console.log("Pet chosen:", petType); const petBaseData = PET_DATA[petType]; player.pet = { type: petType, name: petBaseData.name, color: petBaseData.color, radius: petBaseData.radius, x: player.x - player.radius - PET_RADIUS, y: player.y, target: null, lastAttackTime: 0, lastHealTime: 0, blockReady: true, lastBlockTime: 0, projectileCooldown: 0, flashUntil: 0}; petChoiceOverlay.style.display = 'none'; gamePaused = false; updateUI(); }

// --- Pet Update and Draw ---
function updatePets(deltaTime) { if (!player.pet || gamePaused) return; const now = Date.now(); const pet = player.pet; let targetX = player.x - Math.cos(player.angle + Math.PI) * (player.radius + pet.radius + 5); let targetY = player.y - Math.sin(player.angle + Math.PI) * (player.radius + pet.radius + 5); let dx = 0, dy = 0; const distSqToTarget = distanceSq(pet.x, pet.y, targetX, targetY); const followStopDistSq = (PET_FOLLOW_DISTANCE * 0.8)**2; let petTarget = null; let minDistSq = Infinity; const petSpeed = PLAYER_SPEED*player.speedMultiplier*player.bonusMovementSpeedMult*player.weaponMoveSpeedMult; switch (pet.type) { case 'frog': if (now - player.lastPetHealTime > PET_FROG_HEAL_COOLDOWN) { if (player.health < player.maxHealth) { player.health = Math.min(player.maxHealth, player.health + PET_FROG_HEAL_AMOUNT); console.log(`%cFrog healed player for ${PET_FROG_HEAL_AMOUNT} HP!`, 'color: lightgreen'); player.lastPetHealTime = now; updateUI(); pet.flashUntil = now + 200; } } break; case 'cat': case 'dog': const attackPetDetectRangeSq = (MONSTER_DETECT_RANGE * 1.1)**2; const enemies = [...monsters, ...bosses]; for (const enemy of enemies) { if (enemy.health <= 0) continue; const dSq = distanceSq(pet.x, pet.y, enemy.x, enemy.y); if (dSq < attackPetDetectRangeSq && dSq < minDistSq) { if (!isLineObstructed(pet.x, pet.y, enemy.x, enemy.y, walls)) { minDistSq = dSq; petTarget = enemy; } } } pet.target = petTarget; if (pet.target) { const angleToEnemy = Math.atan2(pet.target.y - pet.y, pet.target.x - pet.x); dx = Math.cos(angleToEnemy) * petSpeed; dy = Math.sin(angleToEnemy) * petSpeed; if (pet.type === 'cat') { if (now - pet.lastAttackTime > PET_CAT_ATTACK_COOLDOWN) { console.log(`Cat ${pet.name} firing at ${pet.target.id}`); pet.lastAttackTime = now; const projX = pet.x + Math.cos(angleToEnemy) * (pet.radius + PET_CAT_PROJECTILE_RADIUS + 1); const projY = pet.y + Math.sin(angleToEnemy) * (pet.radius + PET_CAT_PROJECTILE_RADIUS + 1); const projectile = { id: `proj_pet_${pet.type}_${now}`, ownerId: player.id, sourceType: 'pet_cat', x: projX, y: projY, vx: Math.cos(angleToEnemy) * PET_CAT_PROJECTILE_SPEED, vy: Math.sin(angleToEnemy) * PET_CAT_PROJECTILE_SPEED, damage: PET_CAT_PROJECTILE_DAMAGE, range: PET_CAT_PROJECTILE_RANGE, traveled: 0, radius: PET_CAT_PROJECTILE_RADIUS, color: '#FF8C00', type: 'pet_projectile' }; projectiles.push(projectile); } } else { const dogAttackRangeSq = (PET_DOG_ATTACK_RANGE + pet.radius + pet.target.radius)**2; const dogHitRangeSq = (pet.radius + pet.target.radius + MONSTER_HIT_BUFFER)**2; if (minDistSq <= dogAttackRangeSq) { dx = 0; dy = 0; if (now - pet.lastAttackTime > PET_DOG_ATTACK_COOLDOWN) { if(minDistSq <= dogHitRangeSq) { pet.lastAttackTime = now; pet.target.health -= PET_DOG_DAMAGE; pet.target.health = Math.max(0, pet.target.health); pet.target.flashUntil = now + FLASH_DURATION; console.log(`Dog ${pet.name} bites ${pet.target.id}. Target HP: ${pet.target.health.toFixed(0)}`); if (pet.target.health <= 0) { console.log(`Dog ${pet.name} killed ${pet.target.type || pet.target.id}`); gainXP((target.isBoss ? PLAINS_BOSS_XP_REWARD : MONSTER_XP_REWARD) * MINION_KILL_XP_MULTIPLIER); if(pet.target.isBoss) { /* Handle boss death by pet */ } if (monsters.some(m => m.id === pet.target.id)) monsters = monsters.filter(m => m.id !== pet.target.id); else if (bosses.some(b => b.id === pet.target.id)) { bosses = bosses.filter(b => b.id !== pet.target.id); solidObjects = solidObjects.filter(s => s.id !== pet.target.id); } pet.target = null; } } } } } } break; case 'beetle': if (!pet.blockReady && now - pet.lastBlockTime > PET_BEETLE_BLOCK_COOLDOWN) { pet.blockReady = true; console.log("Beetle block ready!"); pet.flashUntil = now + 150; } break; case 'bird': for (let j = droppedItems.length - 1; j >= 0; j--) { const item = droppedItems[j]; if (distanceSq(pet.x, pet.y, item.x, item.y) < PET_BIRD_PICKUP_RANGE_SQ) { console.log("Bird picked up:", item.type); addToInventory(item.type, 1); droppedItems.splice(j, 1); pet.flashUntil = now + 100; break; } } break; } // Default Follow Movement if no target/other action overrides dx/dy
    if (dx === 0 && dy === 0 && distSqToTarget > followStopDistSq) { const angleToTarget = Math.atan2(targetY - pet.y, targetX - pet.x); dx = Math.cos(angleToTarget) * petSpeed * 0.8; dy = Math.sin(angleToTarget) * petSpeed * 0.8; } // Apply Movement & Collision
    if (dx !== 0 || dy !== 0) { let potentialX = pet.x + dx; let potentialY = pet.y + dy; const petCollisionCheckList = [...walls, ...solidObjects.filter(o => o.isPlaced)]; let collidedWith = checkCollision(pet.radius, potentialX, potentialY, player.id, petCollisionCheckList); if (!collidedWith) { pet.x = potentialX; pet.y = potentialY; } else { potentialX = pet.x + dx; potentialY = pet.y; if (!checkCollision(pet.radius, potentialX, potentialY, player.id, petCollisionCheckList)) { pet.x = potentialX; } else { potentialX = pet.x; potentialY = pet.y + dy; if (!checkCollision(pet.radius, potentialX, potentialY, player.id, petCollisionCheckList)) { pet.y = potentialY; } } } pet.x = Math.max(pet.radius, Math.min(WORLD_WIDTH - pet.radius, pet.x)); pet.y = Math.max(pet.radius, Math.min(WORLD_HEIGHT - pet.radius, pet.y)); } }
function drawPets() { if (!player.pet || gamePaused) return; const pet = player.pet; const now = Date.now(); ctx.save(); ctx.translate(pet.x, pet.y); ctx.fillStyle = (pet.flashUntil > now && Math.floor(now / 50) % 2 === 0) ? '#FFF' : pet.color; ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, pet.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'black'; if (pet.type === 'frog' || pet.type === 'cat' || pet.type === 'dog') { ctx.beginPath(); ctx.arc(-pet.radius * 0.4, -pet.radius * 0.2, 2, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(pet.radius * 0.4, -pet.radius * 0.2, 2, 0, Math.PI * 2); ctx.fill(); } else if (pet.type === 'beetle') { ctx.beginPath(); ctx.moveTo(0, -pet.radius); ctx.lineTo(-3, -pet.radius - 4); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, -pet.radius); ctx.lineTo(3, -pet.radius - 4); ctx.stroke(); if(!pet.blockReady){ ctx.fillStyle = 'rgba(100, 100, 100, 0.4)'; ctx.beginPath(); ctx.arc(0, 0, pet.radius+1, 0, Math.PI * 2); ctx.fill(); } } else if (pet.type === 'bird') { ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(0, -pet.radius * 0.5); ctx.lineTo(pet.radius, 0); ctx.lineTo(0, pet.radius * 0.5); ctx.closePath(); ctx.fill(); } ctx.restore(); }

// --- Game Loop ---
let lastTime = 0;
function gameLoop(timestamp) { const deltaTime=timestamp-lastTime; lastTime=timestamp; if (!isGameOver && gameHasStarted) { update(deltaTime || 0); } draw(); requestAnimationFrame(gameLoop); }

// --- Apply Class Stats Function ---
function applyClassStats(selectedClass) { const stats=CLASS_DATA[selectedClass]; if(!stats){console.error(`Invalid class: ${selectedClass}. Defaults.`);player.maxHealth=PLAYER_MAX_HEALTH*1.0;player.speedMultiplier=1.0;player.swordMultiplierBoost=1.0;player.bowMultiplierBoost=1.0;player.lifesteal=0;player.daySpeedPenalty=1.0; player.className=null;player.monsterKillCount=0;}else{console.log(`Applying stats: ${selectedClass}`);player.speedMultiplier=stats.speedMult;player.swordMultiplierBoost=stats.swordBoost;player.bowMultiplierBoost=stats.bowBoost;player.maxHealth=PLAYER_MAX_HEALTH*stats.healthMult;player.lifesteal=stats.lifesteal;player.daySpeedPenalty=stats.daySpeedPenalty;player.className=stats.className;player.monsterKillCount=0;console.log(` > Class Name: ${player.className}`); console.log(` > Kills required per Undead: ${stats.killsToSummon > 0 ? stats.killsToSummon : 'N/A'}`); console.log(` > HP:${Math.floor(player.maxHealth)} Speed:${player.speedMultiplier} Sword:${player.swordMultiplierBoost} Bow:${player.bowMultiplierBoost} Lifesteal:${player.lifesteal} DayPenalty:${player.daySpeedPenalty}`);} player.health=player.maxHealth; }

// --- Game Initialization Function ---
function initializeGame() { console.log("--- Initializing Game World ---"); spawnInitialResources(); createWalls(); spawnInitialMonsters(); spawnBosses(); player.hotbarSlots[0]={type:'wood_sword',count:1}; player.hotbarSlots[1]={type:'wood_pickaxe',count:1}; player.xpToNextLevel=calculateXPForNextLevel(player.level); selectHotbar(0); updateMainHotbarVisuals(); updateEquippedItem(); clampCamera(); updateUI(); gameHasStarted=true; console.log("--- Game Ready! ---"); }

// --- Summoner Ability Functions ---
function trySummonSlime() { const currentMaxSlimes = MAX_SUMMONED_SLIMES + player.bonusMaxSummons; if (summonedSlimes.length >= currentMaxSlimes) { console.log("Max summoned slimes reached. Removing oldest..."); const oldestSlime = summonedSlimes.shift(); } console.log("Attempting to summon slime..."); const spawnDist = player.radius + SUMMONED_SLIME_RADIUS + 5; const spawnX = player.x + Math.cos(player.angle) * spawnDist; const spawnY = player.y + Math.sin(player.angle) * spawnDist; spawnSummonedSlime(spawnX, spawnY); }
function spawnSummonedSlime(x, y) { const baseSlimeHealth = 50 * 2; const slimeHealth = baseSlimeHealth * SUMMONED_SLIME_HEALTH_MULT * player.bonusSummonHealthMult; const slime = { id: `sum_slime_${Date.now()}_${Math.random()}`, ownerId: player.id, x: x, y: y, radius: SUMMONED_SLIME_RADIUS, type: 'summoned_slime', color: SUMMONED_SLIME_COLOR, maxHealth: slimeHealth, health: slimeHealth, flashUntil: 0, speed: SUMMONED_SLIME_SPEED, state: 'following', attackTarget: null, targetType: null, wanderTargetX: null, wanderTargetY: null, lastWanderChange: 0, attackCooldown: SUMMONED_SLIME_ATTACK_COOLDOWN, lastAttackTime: 0, damage: SUMMONED_SLIME_DAMAGE * player.bonusSummonDamageMult, detectRangeSq: SUMMONED_SLIME_DETECT_RANGE_SQ, attackRange: SUMMONED_SLIME_ATTACK_RANGE, isSolid: false, isAttackable: true }; summonedSlimes.push(slime); console.log(`Summoned slime ${slime.id} (HP: ${Math.floor(slimeHealth)})`); }

// --- Necromancer Ability Functions ---
function trySummonUndead() { const killsNeeded = CLASS_DATA.necromancer.killsToSummon; if (player.monsterKillCount >= killsNeeded) { if (undeadMinions.length < MAX_UNDEAD_MINIONS) { console.log("Necromancer summoning undead..."); const spawnDist = player.radius + UNDEAD_RADIUS + 5; const spawnX = player.x + Math.cos(player.angle) * spawnDist; const spawnY = player.y + Math.sin(player.angle) * spawnDist; spawnUndeadMinion(spawnX, spawnY); player.monsterKillCount -= killsNeeded; console.log(`Kills remaining for next summon: ${killsNeeded - (player.monsterKillCount % killsNeeded)}`); updateUI(); } else { console.log("Max undead minions reached."); } } else { console.log(`Necromancer needs ${killsNeeded - player.monsterKillCount} more kills to summon.`); } }
function spawnUndeadMinion(x, y) { const baseSlimeHealth=50*2; const undeadHealth=baseSlimeHealth*UNDEAD_BASE_HEALTH_MULT*player.bonusUndeadHealthMult; const minion={id:`undead_${Date.now()}_${Math.random()}`,ownerId:player.id,x:x+(Math.random()-0.5)*10,y:y+(Math.random()-0.5)*10,radius:UNDEAD_RADIUS,type:'undead_minion',color:UNDEAD_COLOR,maxHealth:undeadHealth,health:undeadHealth,flashUntil:0,speed:UNDEAD_SPEED,state:'idle',attackTarget:null,targetType:null,wanderTargetX:null,wanderTargetY:null,lastWanderChange:0,attackCooldown:UNDEAD_ATTACK_COOLDOWN,lastAttackTime:0,damage:UNDEAD_DAMAGE,detectRangeSq:Infinity, attackRange:UNDEAD_ATTACK_RANGE,isSolid:false,isAttackable:true}; undeadMinions.push(minion); console.log(`Spawned undead ${minion.id} (HP: ${Math.floor(undeadHealth)})`); }

// --- Handle Spacebar Press ---
function handleSpacebarPress() { if (player.className === 'summoner') { trySummonSlime(); } else if (player.className === 'necromancer') { trySummonUndead(); } }

// --- Event Listeners for Class Selection ---
classSelect.addEventListener('change', ()=>{startGameButton.disabled=!(classSelect.value&&CLASS_DATA[classSelect.value]);});
startGameButton.addEventListener('click', ()=>{const selectedClass=classSelect.value; if(!selectedClass||!CLASS_DATA[selectedClass]){alert("Select class!");return;} applyClassStats(selectedClass); classSelectionOverlay.style.display='none'; initializeGame();});

// --- Start Game (Wait for Class Selection) ---
player.xpToNextLevel = calculateXPForNextLevel(player.level); // Calc initial XP
requestAnimationFrame(gameLoop); // Start loop, waits for gameHasStarted flag
console.log("--- game.js loaded. Waiting for class selection... ---");