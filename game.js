console.log("--- game.js started ---");

// --- DOM Elements ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const healthValueSpan = document.getElementById('healthValue');
const maxHealthValueSpan = document.getElementById('maxHealthValue'); // Reference for Max Health Display
const hungerValueSpan = document.getElementById('hungerValue');
const dayValueSpan = document.getElementById('dayValue');
const levelValueSpan = document.getElementById('levelValue');
const xpValueSpan = document.getElementById('xpValue');
const debugDiv = document.getElementById('debug');
const mainHotbarSlots = document.querySelectorAll('#hotbar .hotbar-slot');
const deathMessageDiv = document.getElementById('deathMessage');
const craftingMenuDiv = document.getElementById('craftingMenu');
const craftingMenuTitle = document.getElementById('craftingMenuTitle');
const closeCraftingButton = document.getElementById('closeCraftingButton');
const timeUIDiv = document.getElementById('timeUI');
// --- Class Selection Elements ---
const classSelectionOverlay = document.getElementById('classSelectionOverlay');
const classSelect = document.getElementById('classSelect');
const startGameButton = document.getElementById('startGameButton');

// --- Game Settings ---
const PLAYER_SPEED = 4; // Base speed, will be modified by class
const PLAYER_RADIUS = 15;
const PLAYER_MAX_HEALTH = 100; // Base max health, will be modified by class
const PLAYER_MAX_HUNGER = 100;
const LIMB_RADIUS = 5;
const HAND_DISTANCE = PLAYER_RADIUS + 10;
const ATTACK_SWING_ARC = Math.PI / 2;
const ATTACK_DURATION = 150;
const INTERACT_DURATION = 100;
const ATTACK_RANGE = 60;
const BASE_ATTACK_POWER = 5; // Base power for hands/unspecified
const BASE_GATHER_POWER = 3; // Base gathering power for hands
const SWORD_MULTIPLIER = 2.0; // Base multiplier for swords vs monsters
const AXE_MULTIPLIER = 3.0;   // Multiplier for axes vs trees
const PICKAXE_MULTIPLIER = 4.0; // Multiplier for pickaxes vs rocks
const FLASH_DURATION = 100;
const ITEM_PICKUP_RANGE_SQ = (PLAYER_RADIUS + 10) * (PLAYER_RADIUS + 10);
const DROPPED_ITEM_RADIUS = 5;
const INVENTORY_COLS = 8;
const INVENTORY_ROWS = 4;
const HOTBAR_SIZE = 5;
const MAX_STACK_SIZE = 64;
const PLACE_GRID_SIZE = 20;
const PLACE_RANGE_SQ = (PLAYER_RADIUS + 60) * (PLAYER_RADIUS + 60);
const INTERACT_RANGE_SQ = (PLAYER_RADIUS + 50) * (PLAYER_RADIUS + 50);
const HEAL_AMOUNT = 25;
const BOW_COOLDOWN = 1600;
const PROJECTILE_SPEED = 8;
const PROJECTILE_RANGE = 450;
const PROJECTILE_RADIUS = 3;
const MINIMAP_WIDTH = 160;
const MINIMAP_HEIGHT = 120;
const MINIMAP_PADDING = 15;
const MINIMAP_ALPHA = 0.75;
const MINIMAP_PLAYER_COLOR = '#00FF00';
const MINIMAP_BOSS_COLOR = '#FF0000';
const MINIMAP_RESPAWN_COLOR = '#FFFF00';
const MINIMAP_PLAYER_SIZE = 3;
const BASE_XP_FOR_LEVEL_2 = 100;
const XP_LEVEL_EXPONENT = 1.5;
const MONSTER_XP_REWARD = 10;
const PLAINS_BOSS_XP_REWARD = 250;
const MAX_UNDEAD_MINIONS = 10;      // Limit the number of necromancer minions

// --- World & Time Settings ---
const WORLD_WIDTH = 2000 * 10;
const WORLD_HEIGHT = 1500 * 10;
const ISLAND_PADDING = 150 * 3;
const DAY_LENGTH = 120000;
const NIGHT_START_PERCENT = 0.65;
const TRANSITION_DURATION_PERCENT = 0.08;
const SUNSET_START_PERCENT = NIGHT_START_PERCENT - TRANSITION_DURATION_PERCENT;
const SUNRISE_START_PERCENT = 1.0 - TRANSITION_DURATION_PERCENT;
const MAX_NIGHT_OPACITY = 0.75;

// --- Biome Definitions ---
const WORLD_THIRD_X = WORLD_WIDTH / 3; const WORLD_THIRD_Y = WORLD_HEIGHT / 3;
const BIOME_BOUNDS = { ROCKY_X_END: WORLD_THIRD_X, ROCKY_Y_END: WORLD_THIRD_Y, SWAMP_X_START: WORLD_WIDTH - WORLD_THIRD_X, SWAMP_Y_END: WORLD_THIRD_Y, VOLCANO_X_END: WORLD_THIRD_X, VOLCANO_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, BADLANDS_X_START: WORLD_WIDTH - WORLD_THIRD_X, BADLANDS_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, FROSTLANDS_Y_END: WORLD_THIRD_Y, DESERT_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, FOREST_X_END: WORLD_THIRD_X, JUNGLE_X_START: WORLD_WIDTH - WORLD_THIRD_X };
const WORLD_CENTER_X = WORLD_WIDTH / 2; const WORLD_CENTER_Y = WORLD_HEIGHT / 2;
const JUNGLE_LAKE = { x: BIOME_BOUNDS.JUNGLE_X_START + (WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START) * 0.15, y: BIOME_BOUNDS.FROSTLANDS_Y_END + (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END) * 0.2, width: (WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START) * 0.7, height: (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END) * 0.6, color: '#367588' };
const LAVA_POOL_COUNT = 5; const lavaPools = []; for (let i = 0; i < LAVA_POOL_COUNT; i++) { const poolWidth = (BIOME_BOUNDS.VOLCANO_X_END * 0.1) + (Math.random() * BIOME_BOUNDS.VOLCANO_X_END * 0.2); const poolHeight = ( (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START) * 0.1) + (Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START) * 0.2); lavaPools.push({ x: (Math.random() * (BIOME_BOUNDS.VOLCANO_X_END - poolWidth)), y: BIOME_BOUNDS.VOLCANO_Y_START + (Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START - poolHeight)), width: poolWidth, height: poolHeight, color: '#FF4500', lightRadius: 80 + Math.random() * 60, lightOpacity: 0.7 + Math.random() * 0.15 }); }
const WALL_THICKNESS = 15;
const WALL_COLOR = 'rgba(60, 40, 30, 0.8)';

const BIOME_DATA = {
    plains:     { color: '#A0D995', treeDensity: 0.04, rockDensity: 0.02, enemyDensity: 0.003, cactusDensity: 0, spawnMultiplier: 1.5 },
    forest:     { color: '#2E8B57', treeDensity: 0.5,  rockDensity: 0,    enemyDensity: 0.02,  cactusDensity: 0, spawnMultiplier: 3 },
    jungle:     { color: '#556B2F', treeDensity: 0.2,  rockDensity: 0.01, enemyDensity: 0.015, cactusDensity: 0, spawnMultiplier: 3 },
    frostlands: { color: '#E6E6FA', treeDensity: 0.15, rockDensity: 0.04, enemyDensity: 0.01,  cactusDensity: 0, spawnMultiplier: 2.5 },
    desert:     { color: '#EDC9AF', treeDensity: 0,    rockDensity: 0.25, enemyDensity: 0.018, cactusDensity: 0.2, spawnMultiplier: 2.5 },
    rocky:      { color: '#A9A9A9', treeDensity: 0,    rockDensity: 0.8,  enemyDensity: 0.01,  cactusDensity: 0, spawnMultiplier: 4 },
    swamp:      { color: '#6B8E23', treeDensity: 0.1,  rockDensity: 0.01, enemyDensity: 0.025, cactusDensity: 0, spawnMultiplier: 3, hasWater: true },
    volcano:    { color: '#4C4646', treeDensity: 0,    rockDensity: 0.5,  enemyDensity: 0.022, cactusDensity: 0, spawnMultiplier: 4, hasLava: true },
    badlands:   { color: '#D2B48C', treeDensity: 0,    rockDensity: 0.1,  enemyDensity: 0.025, cactusDensity: 0.05, spawnMultiplier: 3.5, hasBoneTrees: true },
};

// --- Class Data ---
const CLASS_DATA = {
    // value: { healthMult, speedMult, swordBoost, bowBoost, lifesteal, daySpeedPenalty, necromancyChance }
    knight:     { healthMult: 1.0, speedMult: 1.00, swordBoost: 3.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, necromancyChance: 0 },
    archer:     { healthMult: 1.0, speedMult: 1.00, swordBoost: 1.0, bowBoost: 5.0, lifesteal: 0,   daySpeedPenalty: 1.0, necromancyChance: 0 },
    scout:      { healthMult: 0.8, speedMult: 1.75, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, necromancyChance: 0 },
    tank:       { healthMult: 3.0, speedMult: 0.80, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, necromancyChance: 0 },
    vampire:    { healthMult: 0.8, speedMult: 1.00, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 2.5, daySpeedPenalty: 0.5, necromancyChance: 0 },
    necromancer:{ healthMult: 0.5, speedMult: 0.80, swordBoost: 1.0, bowBoost: 1.0, lifesteal: 0,   daySpeedPenalty: 1.0, necromancyChance: 0.2 }, // 1 in 5 chance
};

// --- Boss Settings ---
const PLAINS_BOSS_RADIUS = 40; const PLAINS_BOSS_HEALTH = 1000; const PLAINS_BOSS_SPEED = 1.0; const PLAINS_BOSS_DETECT_RANGE_SQ = 400 * 400; const PLAINS_BOSS_ATTACK_COOLDOWN = 1500; const PLAINS_BOSS_ATTACK_CHOICE_COOLDOWN = 3000; const BOSS_HIT_RANGE = PLAINS_BOSS_RADIUS + PLAYER_RADIUS + 10; const BOSS_HIT_DAMAGE = 25; const BOSS_SMASH_RANGE = 100; const BOSS_SMASH_DAMAGE = 35; const BOSS_SMASH_WINDUP = 800; const BOSS_SMASH_EFFECT_DURATION = 300; const BOSS_SPIN_RANGE = PLAINS_BOSS_RADIUS + 20; const BOSS_SPIN_DAMAGE = 15; const BOSS_SPIN_DURATION = 1200; const BOSS_SPIN_DAMAGE_INTERVAL = 300;

// --- Monster Settings ---
const MONSTER_SPEED = 1.8;
const MONSTER_DETECT_RANGE = 250;
const MONSTER_ATTACK_RANGE = PLAYER_RADIUS + 10; // Monster stops moving when this close to attempt attack
const MONSTER_ATTACK_COOLDOWN = 1000;
const MONSTER_DAMAGE = 10;
const INITIAL_MONSTER_COUNT = 1000;
const NIGHTLY_MONSTER_SPAWN_COUNT = 100;
const MAX_MONSTER_COUNT = 5000;
const FOREST_TREE_TARGET = 1200;
const GOLD_COIN_DROP_CHANCE = 1 / 50;

// --- Undead Minion Settings (Moved After Monster Settings) ---
const UNDEAD_RADIUS = 8;
const UNDEAD_COLOR = '#E0E0E0';
const UNDEAD_BASE_HEALTH_MULT = 0.8;
const UNDEAD_SPEED = 1.5;
const UNDEAD_DETECT_RANGE_SQ = (MONSTER_DETECT_RANGE * 0.8) ** 2; // Correctly uses MONSTER_DETECT_RANGE now
const UNDEAD_ATTACK_RANGE = MONSTER_ATTACK_RANGE - 5; // Keep consistent if needed
const UNDEAD_ATTACK_COOLDOWN = 1200;
const UNDEAD_DAMAGE = 6;


// --- Item Data ---
const ITEM_DATA = {
    'tree':        { color: '#654321', name: 'Tree', isPlaceable: false, health: 50, radius: 15, shape: 'circle', isSolid: true, isAttackable: true },
    'rock':        { color: '#808080', name: 'Rock', isPlaceable: false, health: 150, radius: 12, shape: 'circle', isSolid: true, isAttackable: true },
    'cactus':      { color: '#2E8B57', name: 'Cactus', isPlaceable: false, isSolid: true, isAttackable: true, radius: 10, health: 100, shape: 'cactus' },
    'bone_tree':   { color: '#EEDFCC', name: 'Bone Tree', isPlaceable: false, isSolid: true, isAttackable: true, radius: 13, health: 160, shape: 'tree', variant: 'bone'},
    'wood':         { color: '#A0522D', name: 'Wood', isPlaceable: false, shape: 'rect' },
    'stone':        { color: '#778899', name: 'Stone', isPlaceable: false, shape: 'circle' },
    'plant_fiber':  { color: '#9ACD32', name: 'Plant Fiber', isPlaceable: false, shape: 'line' },
    'monster_goop': { color: '#90EE90', name: 'Monster Goop', isPlaceable: false, shape: 'circle' },
    'gold_coin':    { color: '#FFD700', name: 'Gold Coin', isPlaceable: false, shape: 'circle' },
    'dust':         { color: '#C2B280', name: 'Dust', isPlaceable: false, shape: 'circle'},
    'stick':        { color: '#B8860B', name: 'Stick', isPlaceable: false, shape: 'line' },
    'iron_ore':     { color: '#8A867D', name: 'Iron Ore', isPlaceable: false, shape: 'circle' },
    'cobalt_ore':   { color: '#2040C0', name: 'Cobalt Ore', isPlaceable: false, shape: 'circle' },
    'mithril_ore':  { color: '#60D090', name: 'Mithril Ore', isPlaceable: false, shape: 'circle' },
    'adamantite_ore':{ color: '#B01010', name: 'Adamantite Ore', isPlaceable: false, shape: 'circle' },
    'wood_plank':   { color: '#DEB887', name: 'Wooden Plank', isPlaceable: true, solidRadius: PLACE_GRID_SIZE / 2, shape: 'rect', isSolid: true, isAttackable: true, health: 50 },
    'stone_block':  { color: '#696969', name: 'Stone Block', isPlaceable: true, solidRadius: PLACE_GRID_SIZE / 2, shape: 'rect', isSolid: true, isAttackable: true, health: 150 },
    'workbench':    { color: '#D2691E', name: 'Workbench', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect', isSolid: true, isAttackable: true, health: 100 },
    'icky_bed':     { color: '#556B2F', name: 'Icky Bed', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect', isSolid: true, isAttackable: true, health: 80 },
    'torch':        { color: '#FFA500', name: 'Torch', isPlaceable: true, isSolid: true, isAttackable: true, solidRadius: 5, health: 10, lightRadius: 120, shape: 'torch' },
    'item_upgrader_t1': { color: '#708090', name: 'Item Upgrader T1', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect', isSolid: true, isAttackable: true, health: 200 },
    'healing_salve':{ color: '#FFC0CB', name: 'Healing Salve', isPlaceable: false, isUsable: true, shape: 'circle' },
    'wood_sword':   { color: '#D2B48C', name: 'Wooden Sword', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER, shape: 'sword' },
    'wood_axe':     { color: '#8B4513', name: 'Wooden Axe', isPlaceable: false, type: 'tool', toolType: 'axe', gatherMultiplier: AXE_MULTIPLIER, target: 'tree', shape: 'axe' },
    'wood_pickaxe': { color: '#A0522D', name: 'Wooden Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER, target: 'rock', shape: 'pickaxe', toolTier: 0 },
    'stone_sword':  { color: '#A9A9A9', name: 'Stone Sword', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER * 1.5, shape: 'sword' },
    'stone_axe':    { color: '#808080', name: 'Stone Axe', isPlaceable: false, type: 'tool', toolType: 'axe', gatherMultiplier: AXE_MULTIPLIER * 1.5, target: 'tree', shape: 'axe' },
    'stone_pickaxe':{ color: '#696969', name: 'Stone Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 1.5, target: 'rock', shape: 'pickaxe', toolTier: 1 },
    'iron_pickaxe': { color: '#A19D94', name: 'Iron Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 2.0, target: 'rock', shape: 'pickaxe', toolTier: 2 },
    'cobalt_pickaxe':{ color: '#3E64FF', name: 'Cobalt Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 2.7, target: 'rock', shape: 'pickaxe', toolTier: 3 },
    'mithril_pickaxe':{ color: '#93E9BE', name: 'Mithril Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 3.5, target: 'rock', shape: 'pickaxe', toolTier: 4 },
    'adamantite_pickaxe':{ color: '#E41B17', name: 'Adamantite Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 4.5, target: 'rock', shape: 'pickaxe', toolTier: 5 },
    'wooden_bow':   { color: '#CD853F', name: 'Wooden Bow', isPlaceable: false, type: 'tool', toolType: 'bow', shape: 'bow', range: 400, damage: 45 },
    'stone_reinforced_bow': { color: '#A58D71', name: 'Stone-Reinforced Bow', isPlaceable: false, type: 'tool', toolType: 'bow', shape: 'bow', range: 450, damage: 66 },
    'bone_scythe':  { color: '#F5F5DC', name: 'Bone Scythe', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER * 2, shape: 'sword'},
    'fishing_rod':  { color: '#C0C0C0', name: 'Fishing Rod', isPlaceable: false, type: 'tool', toolType: 'fishing_rod', shape: 'line' },
};

// --- Boss -> Wall Tier Mapping ---
const BOSS_WALL_TIER_MAP = {
    'plains_boss': 1,
};

// --- Game State ---
let mouseCanvasX = 0; let mouseCanvasY = 0;
let worldMouseX = 0; let worldMouseY = 0;
let keysPressed = {};
let resources = []; let monsters = []; let solidObjects = []; let bosses = [];
let walls = [];
let projectiles = [];
let droppedItems = [];
let undeadMinions = []; // Array to hold necromancer minions
let gameTime = 0; let dayCount = 1; let isNight = false;
let currentNightOpacity = 0;
let isGameOver = false; let isCraftingMenuOpen = false; let isUpgraderUIOpen = false;
let selectedUpgradeInput = { slotIndex: -1, source: null };
let cameraX = 0; let cameraY = 0;
let isMinimapVisible = true;
let gameHasStarted = false; // Flag to prevent updates before start

// --- Player Object ---
const player = {
    x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2,
    radius: PLAYER_RADIUS,
    id: 'player',
    health: PLAYER_MAX_HEALTH,
    maxHealth: PLAYER_MAX_HEALTH,
    hunger: PLAYER_MAX_HUNGER,
    level: 1,
    currentXP: 0,
    xpToNextLevel: BASE_XP_FOR_LEVEL_2,
    // --- Class Specific Modifiers/Stats ---
    speedMultiplier: 1.0,
    swordMultiplierBoost: 1.0,
    bowMultiplierBoost: 1.0,
    lifesteal: 0,
    daySpeedPenalty: 1.0,
    necromancyChance: 0,
    // --- Rest of player properties ---
    angle: 0,
    isAttacking: false, attackTimer: 0,
    isInteracting: false, interactTimer: 0,
    inventorySlots: new Array(INVENTORY_COLS * INVENTORY_ROWS).fill(null),
    hotbarSlots: new Array(HOTBAR_SIZE).fill(null),
    selectedHotbarSlotIndex: 0,
    equippedItemType: null,
    selectedInventoryItem: null,
    respawnX: WORLD_WIDTH / 2,
    respawnY: WORLD_HEIGHT / 2,
    lastBowShotTime: 0,
};

// --- Define Recipes ---
const recipes = [
    { id: 'stick', name: "Stick (x4)", output: { type: 'stick', count: 4 }, input: { 'wood': 1 }, requiresWorkbench: false },
    { id: 'wood_plank', name: "Wooden Plank (x4)", output: { type: 'wood_plank', count: 4 }, input: { 'wood': 1 }, requiresWorkbench: false },
    { id: 'stone_block', name: "Stone Block", output: { type: 'stone_block', count: 1 }, input: { 'stone': 2 }, requiresWorkbench: false },
    { id: 'basic_workbench', name: "Workbench", output: { type: 'workbench', count: 1 }, input: { 'wood_plank': 5, 'stick': 2 }, requiresWorkbench: false },
    { id: 'healing_salve', name: "Healing Salve", output: { type: 'healing_salve', count: 1}, input: { 'plant_fiber': 3, 'monster_goop': 1}, requiresWorkbench: false },
    { id: 'icky_bed', name: "Icky Bed", output: { type: 'icky_bed', count: 1}, input: { 'wood_plank': 8, 'plant_fiber': 5, 'monster_goop': 3 }, requiresWorkbench: false },
    { id: 'torch', name: "Torch (x3)", output: { type: 'torch', count: 3 }, input: { 'stick': 12, 'monster_goop': 10 }, requiresWorkbench: false },
    { id: 'item_upgrader_t1', name: "Item Upgrader T1", output: { type: 'item_upgrader_t1', count: 1 }, input: { 'stone': 10, 'wood': 10, 'monster_goop': 15 }, requiresWorkbench: false },
    { id: 'wood_sword', name: "Wooden Sword", output: { type: 'wood_sword', count: 1}, input: { 'wood_plank': 2, 'stick': 1}, requiresWorkbench: true },
    { id: 'wood_axe', name: "Wooden Axe", output: { type: 'wood_axe', count: 1}, input: { 'wood_plank': 3, 'stick': 2}, requiresWorkbench: true },
    { id: 'wood_pickaxe', name: "Wooden Pickaxe", output: { type: 'wood_pickaxe', count: 1}, input: { 'wood_plank': 3, 'stick': 2}, requiresWorkbench: true },
    { id: 'fishing_rod', name: "Fishing Rod", output: { type: 'fishing_rod', count: 1}, input: { 'stick': 3, 'plant_fiber': 2}, requiresWorkbench: true },
    { id: 'iron_pickaxe', name: "Iron Pickaxe", output: { type: 'iron_pickaxe', count: 1 }, input: { 'stone_pickaxe': 1, 'iron_ore': 8, 'stick': 3 }, requiresWorkbench: true },
    { id: 'cobalt_pickaxe', name: "Cobalt Pickaxe", output: { type: 'cobalt_pickaxe', count: 1 }, input: { 'iron_pickaxe': 1, 'cobalt_ore': 10, 'wood': 5 }, requiresWorkbench: true },
    { id: 'mithril_pickaxe', name: "Mithril Pickaxe", output: { type: 'mithril_pickaxe', count: 1 }, input: { 'cobalt_pickaxe': 1, 'mithril_ore': 12, 'stone': 8 }, requiresWorkbench: true },
    { id: 'adamantite_pickaxe', name: "Adamantite Pickaxe", output: { type: 'adamantite_pickaxe', count: 1 }, input: { 'mithril_pickaxe': 1, 'adamantite_ore': 15, 'gold_coin': 5 }, requiresWorkbench: true },
];

// --- Define Upgrader Recipes ---
const UPGRADER_RECIPES = {
    'wood_sword':   { material: 'stone', materialCount: 5, output: 'stone_sword', name: 'Stone Sword' },
    'wood_axe':     { material: 'stone', materialCount: 5, output: 'stone_axe', name: 'Stone Axe' },
    'wooden_bow':   { material: 'stone', materialCount: 8, output: 'stone_reinforced_bow', name: 'Stone-Reinforced Bow' },
};

// --- Utility Functions ---
function distanceSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
function distance(x1, y1, x2, y2) { return Math.sqrt(distanceSq(x1, y1, x2, y2)); }
function normalizeAngle(angle) { while (angle <= -Math.PI) angle += 2 * Math.PI; while (angle > Math.PI) angle -= 2 * Math.PI; return angle; }
function clampCamera() { const camLeft = player.x - canvas.width / 2; const camTop = player.y - canvas.height / 2; const camRight = player.x + canvas.width / 2; const camBottom = player.y + canvas.height / 2; cameraX = player.x; cameraY = player.y; if (camLeft < 0) cameraX = canvas.width / 2; if (camRight > WORLD_WIDTH) cameraX = WORLD_WIDTH - canvas.width / 2; if (camTop < 0) cameraY = canvas.height / 2; if (camBottom > WORLD_HEIGHT) cameraY = WORLD_HEIGHT - canvas.height / 2; }
function canvasToWorld(canvasX, canvasY) { const worldOriginX = cameraX - canvas.width / 2; const worldOriginY = cameraY - canvas.height / 2; return { x: canvasX + worldOriginX, y: canvasY + worldOriginY }; }
function getBiomeAt(x, y) { if (x < BIOME_BOUNDS.ROCKY_X_END && y < BIOME_BOUNDS.ROCKY_Y_END) return 'rocky'; if (x > BIOME_BOUNDS.SWAMP_X_START && y < BIOME_BOUNDS.SWAMP_Y_END) return 'swamp'; if (x < BIOME_BOUNDS.VOLCANO_X_END && y > BIOME_BOUNDS.VOLCANO_Y_START) return 'volcano'; if (x > BIOME_BOUNDS.BADLANDS_X_START && y > BIOME_BOUNDS.BADLANDS_Y_START) return 'badlands'; if (y < BIOME_BOUNDS.FROSTLANDS_Y_END) return 'frostlands'; if (y > BIOME_BOUNDS.DESERT_Y_START) return 'desert'; if (x < BIOME_BOUNDS.FOREST_X_END) return 'forest'; if (x > BIOME_BOUNDS.JUNGLE_X_START) return 'jungle'; return 'plains'; }
function formatTime(milliseconds) { if (milliseconds < 0) milliseconds = 0; const totalSeconds = Math.floor(milliseconds / 1000); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }

// --- Line Segment Intersection Helper ---
function segmentsIntersect(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    function orientation(px, py, qx, qy, rx, ry) { const val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy); if (val === 0) return 0; return (val > 0) ? 1 : 2; }
    function onSegment(px, py, qx, qy, rx, ry) { return (qx <= Math.max(px, rx) && qx >= Math.min(px, rx) && qy <= Math.max(py, ry) && qy >= Math.min(py, ry)); }
    const o1=orientation(p1x, p1y, p2x, p2y, p3x, p3y), o2=orientation(p1x, p1y, p2x, p2y, p4x, p4y), o3=orientation(p3x, p3y, p4x, p4y, p1x, p1y), o4=orientation(p3x, p3y, p4x, p4y, p2x, p2y);
    if (o1!==o2 && o3!==o4) return true; if (o1===0 && onSegment(p1x,p1y,p3x,p3y,p2x,p2y)) return true; if (o2===0 && onSegment(p1x,p1y,p4x,p4y,p2x,p2y)) return true; if (o3===0 && onSegment(p3x,p3y,p1x,p1y,p4x,p4y)) return true; if (o4===0 && onSegment(p3x,p3y,p2x,p2y,p4x,p4y)) return true; return false;
}

// --- Line of Sight Check ---
function isLineObstructed(p1x, p1y, p2x, p2y, wallArray) {
    for (const wall of wallArray) { if (!wall.isWall) continue; const wx = wall.x, wy = wall.y, ww = wall.width, wh = wall.height; const tl={x:wx,y:wy}, tr={x:wx+ww,y:wy}, bl={x:wx,y:wy+wh}, br={x:wx+ww,y:wy+wh}; if (segmentsIntersect(p1x,p1y,p2x,p2y, tl.x,tl.y, tr.x,tr.y)) return true; if (segmentsIntersect(p1x,p1y,p2x,p2y, bl.x,bl.y, br.x,br.y)) return true; if (segmentsIntersect(p1x,p1y,p2x,p2y, tl.x,tl.y, bl.x,bl.y)) return true; if (segmentsIntersect(p1x,p1y,p2x,p2y, tr.x,tr.y, br.x,br.y)) return true; } return false;
}

// --- XP and Leveling ---
function calculateXPForNextLevel(currentLevel) { if (currentLevel < 1) return BASE_XP_FOR_LEVEL_2; const required = Math.floor(BASE_XP_FOR_LEVEL_2 * Math.pow(currentLevel, XP_LEVEL_EXPONENT)); return Math.max(BASE_XP_FOR_LEVEL_2, required); }
function gainXP(amount) { if (isGameOver || amount <= 0 || !gameHasStarted) return; player.currentXP += amount; console.log(`%cGained ${amount} XP! Current: ${player.currentXP}/${player.xpToNextLevel}`, "color: lightgreen;"); while (player.currentXP >= player.xpToNextLevel) { player.level++; player.currentXP -= player.xpToNextLevel; player.xpToNextLevel = calculateXPForNextLevel(player.level); console.log(`%cLEVEL UP! Reached Level ${player.level}!`, "color: yellow; font-size: 1.2em; font-weight: bold;"); console.log(`%cNext level requires ${player.xpToNextLevel} XP. Current XP: ${player.currentXP}`, "color: lightblue;"); } updateUI(); }

// --- Item Handling Functions ---
function findFirstEmptyInventorySlot() { return player.inventorySlots.findIndex(slot => slot === null); }
function findItemStackableInventorySlot(itemType) { return player.inventorySlots.findIndex(slot => slot !== null && slot.type === itemType && slot.count < MAX_STACK_SIZE); }
function addDroppedItem(x, y, type, count = 1) { for (let i = 0; i < count; i++) { const offsetX = (Math.random() - 0.5) * 15; const offsetY = (Math.random() - 0.5) * 15; droppedItems.push({ id: `item_${Date.now()}_${Math.random()}`, x: x + offsetX, y: y + offsetY, type: type, radius: DROPPED_ITEM_RADIUS, spawnTime: Date.now() }); } }
function addToInventory(itemType, count = 1) { let rem=count; while(rem>0){const idx=findItemStackableInventorySlot(itemType); if(idx!==-1){const slot=player.inventorySlots[idx]; const add=Math.min(rem,MAX_STACK_SIZE-slot.count); slot.count+=add; rem-=add;}else{break;}} while(rem>0){const idx=findFirstEmptyInventorySlot(); if(idx!==-1){const add=Math.min(rem,MAX_STACK_SIZE); player.inventorySlots[idx]={type:itemType, count:add}; rem-=add;}else{console.warn(`Inv full! Cannot add ${rem} ${itemType}.`); rem=0; break;}} if(isCraftingMenuOpen){populateCraftingMenu(isNearWorkbench(), isNearUpgrader());} updateMainHotbarVisuals();}
function removeFromInventory(itemType, count = 1) { let rem=count; let removed=0; for(let i=0; i<player.inventorySlots.length && rem>0; i++){const slot=player.inventorySlots[i]; if(slot && slot.type===itemType){const remSlot=Math.min(rem,slot.count); slot.count-=remSlot; rem-=remSlot; removed+=remSlot; if(slot.count<=0){player.inventorySlots[i]=null;}}} /* Check hotbar if needed */ if(removed>0){if(isCraftingMenuOpen){populateCraftingMenu(isNearWorkbench(), isNearUpgrader());} updateMainHotbarVisuals();} return rem <= 0; }
function getTotalItemCount(itemType) { const invCount=player.inventorySlots.reduce((t,s)=>(s&&s.type===itemType?t+s.count:t),0); const hotbarCount=player.hotbarSlots.reduce((t,s)=>(s&&s.type===itemType?t+s.count:t),0); return invCount+hotbarCount; }

// --- Crafting Functions ---
function canCraft(recipe) { for (const itemId in recipe.input) { if (getTotalItemCount(itemId) < recipe.input[itemId]) return false; } return true; }
function doCraft(recipeId) { const recipe = recipes.find(r => r.id === recipeId); if (!recipe) return; if (canCraft(recipe)) { let success = true; const ingredientsToRemove = { ...recipe.input }; for (const itemId in ingredientsToRemove) { if (!removeFromInventory(itemId, ingredientsToRemove[itemId])) { success = false; break; } } if (success) { addToInventory(recipe.output.type, recipe.output.count); console.log(`%cCrafted ${recipe.output.count}x ${recipe.output.type}!`, 'color: cyan; font-weight: bold;'); if (isCraftingMenuOpen) populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } else { console.error(`Crafting failed for ${recipe.name} due to ingredient removal issue.`); } } else { console.log(`Cannot craft ${recipe.name} - missing ingredients.`); } }

// --- UI Interaction ('E' Menu - Item Moving) ---
function handleInventorySlotClick(index) { const clickedSlot = player.inventorySlots[index]; const selected = player.selectedInventoryItem; if (selected) { const originalSourceSlot = selected.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; originalSourceSlot[selected.index] = clickedSlot; player.inventorySlots[index] = { type: selected.type, count: selected.count }; player.selectedInventoryItem = null; } else if (clickedSlot) { player.selectedInventoryItem = { index: index, type: clickedSlot.type, count: clickedSlot.count, source: 'inventory' }; } populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); updateMainHotbarVisuals(); }
function handleHotbarSlotClick(index) { const clickedSlot = player.hotbarSlots[index]; const selected = player.selectedInventoryItem; if (selected) { const originalSourceSlot = selected.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; originalSourceSlot[selected.index] = clickedSlot; player.hotbarSlots[index] = { type: selected.type, count: selected.count }; player.selectedInventoryItem = null; } else if (clickedSlot) { player.selectedInventoryItem = { index: index, type: clickedSlot.type, count: clickedSlot.count, source: 'hotbar' }; } populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); updateMainHotbarVisuals(); updateEquippedItem(); }
function drawItemShape(ctx, itemType, size) { const itemData = ITEM_DATA[itemType]; if (!itemData) { ctx.fillStyle='magenta'; ctx.fillRect(size*0.1,size*0.1,size*0.8,size*0.8); ctx.strokeStyle='black'; ctx.lineWidth=1; ctx.strokeRect(size*0.1,size*0.1,size*0.8,size*0.8); ctx.beginPath();ctx.moveTo(size*0.1,size*0.1);ctx.lineTo(size*0.9,size*0.9);ctx.moveTo(size*0.9,size*0.1);ctx.lineTo(size*0.1,size*0.9);ctx.stroke(); return; } ctx.save(); ctx.translate(size/2, size/2); ctx.fillStyle=itemData.color||'#FFF'; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; const scale=size/30; ctx.scale(scale,scale); const shapeSize=18; switch(itemData.shape){ case 'line': ctx.beginPath();ctx.moveTo(0,-shapeSize*0.6);ctx.lineTo(0,shapeSize*0.6);ctx.lineWidth=3*scale>1?3:1/scale;ctx.stroke();break; case 'rect': ctx.fillRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);ctx.strokeRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);break; case 'torch': const sH=shapeSize*1.0,sW=shapeSize*0.2,fH=shapeSize*0.5; ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-sW/2,sH*0.1,sW,sH*0.9); ctx.fillStyle=itemData.color;ctx.beginPath();ctx.ellipse(0,-sH*0.25,sW*1.5,fH,0,0,Math.PI*2);ctx.fill();break; case 'sword': const swH=shapeSize*1.3,swW=shapeSize*0.15,gW=shapeSize*0.4; ctx.fillStyle='#444';ctx.fillRect(-swW*1.2,swH*0.2,swW*2.4,swH*0.2); ctx.fillStyle='#888';ctx.fillRect(-gW/2,swH*0.1,gW,swW*2); ctx.fillStyle=itemData.color;ctx.beginPath();ctx.moveTo(0,-swH*0.4);ctx.lineTo(-swW,swH*0.1);ctx.lineTo(swW,swH*0.1);ctx.closePath();ctx.fill();ctx.stroke();break; case 'axe': case 'pickaxe': const hH=shapeSize*1.2,hW=shapeSize*0.15,hdW=shapeSize*0.6,hdH=shapeSize*0.4; ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-hW/2,-hH/2+hdH/2,hW,hH);ctx.strokeRect(-hW/2,-hH/2+hdH/2,hW,hH); ctx.fillStyle=itemData.color;ctx.fillRect(-hdW/2,-hH/2,hdW,hdH);ctx.strokeRect(-hdW/2,-hH/2,hdW,hdH);break; case 'bow': ctx.beginPath();ctx.moveTo(0,-shapeSize*0.6);ctx.quadraticCurveTo(-shapeSize*0.7,0,0,shapeSize*0.6);ctx.quadraticCurveTo(shapeSize*0.7,0,0,-shapeSize*0.6); ctx.moveTo(-shapeSize*0.1,-shapeSize*0.5);ctx.lineTo(-shapeSize*0.1,shapeSize*0.5);ctx.lineWidth=1*scale>0.5?1:0.5/scale;ctx.strokeStyle='#eee';ctx.stroke(); ctx.lineWidth=3*scale>1?3:1/scale;ctx.strokeStyle='rgba(0,0,0,0.6)';ctx.stroke();ctx.fill();break; case 'cactus': const cW=shapeSize*0.4,cH=shapeSize*1.3; ctx.fillRect(-cW/2,-cH/2,cW,cH);ctx.fillRect(-cW*1.2,-cH*0.1,cW*2.4,cW*0.6);ctx.strokeStyle='darkgreen';ctx.strokeRect(-cW/2,-cH/2,cW,cH);break; case 'circle': default: ctx.beginPath();ctx.arc(0,0,shapeSize*0.4,0,Math.PI*2);ctx.fill();ctx.stroke();break; } ctx.restore(); }
function populateCraftingMenu(isNearWorkbench, isNearUpgrader) { if (!craftingMenuDiv) return; const invGrid=document.getElementById('inventoryGrid');const hotbarGrid=document.getElementById('hotbarGrid');const playerRecipeList=document.getElementById('recipeList');const workbenchCtxDiv=document.getElementById('workbenchContext');const upgraderCtxDiv=document.getElementById('upgraderContext');const workbenchRecipeList=document.getElementById('workbenchRecipeList'); if (!invGrid||!hotbarGrid||!playerRecipeList||!workbenchCtxDiv||!upgraderCtxDiv||!workbenchRecipeList) { console.error("Missing UI elements for combined crafting menu!"); return; } invGrid.style.setProperty('--inventory-cols',INVENTORY_COLS); hotbarGrid.style.setProperty('--hotbar-size',HOTBAR_SIZE); const createSlotCanvas=(item)=>{const canvas=document.createElement('canvas');canvas.width=40;canvas.height=40;canvas.classList.add('item-icon');const itemCtx=canvas.getContext('2d');if(item&&item.type){drawItemShape(itemCtx,item.type,canvas.width);}return canvas;}; invGrid.innerHTML=''; player.inventorySlots.forEach((item,index)=>{const slotDiv=document.createElement('div');slotDiv.classList.add('inventory-slot');slotDiv.dataset.index=index; if(item){const itemData=ITEM_DATA[item.type]||{name:item.type};slotDiv.title=itemData.name;slotDiv.appendChild(createSlotCanvas(item));if(item.count>1){const countSpan=document.createElement('span');countSpan.classList.add('item-count');countSpan.textContent=item.count;slotDiv.appendChild(countSpan);}} if(player.selectedInventoryItem&&player.selectedInventoryItem.source==='inventory'&&player.selectedInventoryItem.index===index){slotDiv.classList.add('selected-for-move');if(item)slotDiv.style.opacity='0.5';} slotDiv.addEventListener('click',()=>handleInventorySlotClick(index)); invGrid.appendChild(slotDiv);}); hotbarGrid.innerHTML=''; player.hotbarSlots.forEach((item,index)=>{const slotDiv=document.createElement('div');slotDiv.classList.add('hotbar-menu-slot');slotDiv.dataset.index=index; if(item){const itemData=ITEM_DATA[item.type]||{name:item.type};slotDiv.title=itemData.name;slotDiv.appendChild(createSlotCanvas(item));if(item.count>1){const countSpan=document.createElement('span');countSpan.classList.add('item-count');countSpan.textContent=item.count;slotDiv.appendChild(countSpan);}} if(player.selectedInventoryItem&&player.selectedInventoryItem.source==='hotbar'&&player.selectedInventoryItem.index===index){slotDiv.classList.add('selected-for-move');if(item)slotDiv.style.opacity='0.5';} slotDiv.addEventListener('click',()=>handleHotbarSlotClick(index)); hotbarGrid.appendChild(slotDiv);}); playerRecipeList.innerHTML=''; const playerRecipes=recipes.filter(r=>!r.requiresWorkbench); if(playerRecipes.length===0){playerRecipeList.innerHTML=`<li>No player recipes available.</li>`;} else {playerRecipes.forEach(recipe=>{const li=document.createElement('li');const canCurrentlyCraft=canCraft(recipe);let ingredientsHTML=''; for(const itemId in recipe.input){const req=recipe.input[itemId];const owned=getTotalItemCount(itemId);const missingCls=owned<req?'missing':'';const itemName=(ITEM_DATA[itemId]?.name||itemId).replace(/_/g,' ');ingredientsHTML+=`<span class="ingredient ${missingCls}">${itemName}: ${owned}/${req}</span>`;} li.innerHTML=`<div><strong>${recipe.name}</strong><div class="recipe-details">${ingredientsHTML}</div></div><button data-recipe-id="${recipe.id}" ${canCurrentlyCraft?'':'disabled'}>Craft</button>`; const craftBtn=li.querySelector('button');if(craftBtn){craftBtn.addEventListener('click',()=>{doCraft(recipe.id);});} playerRecipeList.appendChild(li);});} workbenchRecipeList.innerHTML=''; if(isNearWorkbench){populateWorkbenchRecipes(workbenchRecipeList);} if(isNearUpgrader){populateUpgraderUI();}else{const upIn=document.getElementById('upgraderInputSlot');const upMat=document.getElementById('upgraderMaterialSlot');const upOut=document.getElementById('upgraderOutputSlot');const upBtn=document.getElementById('upgradeItemButton');if(upIn)upIn.innerHTML='';if(upMat)upMat.innerHTML='';if(upOut)upOut.innerHTML='';if(upBtn)upBtn.disabled=true;selectedUpgradeInput={slotIndex:-1,source:null};} }
function toggleCraftingMenu() { if (!gameHasStarted) return; isCraftingMenuOpen = !isCraftingMenuOpen; if (isCraftingMenuOpen) { const nearUpgrader = isNearUpgrader(); const nearWorkbench = !nearUpgrader && isNearWorkbench(); let context = 'player'; let title = 'Crafting'; let activeClass = ''; if (nearUpgrader) { context = 'upgrader'; title = 'Item Upgrader'; activeClass = 'upgrader-active'; } else if (nearWorkbench) { context = 'workbench'; title = 'Workbench Crafting'; activeClass = 'workbench-active'; } populateCraftingMenu(nearWorkbench, nearUpgrader); craftingMenuDiv.className = 'active ' + activeClass; craftingMenuDiv.style.display = 'flex'; craftingMenuTitle.textContent = title; } else { craftingMenuDiv.style.display = 'none'; craftingMenuDiv.className = ''; if (player.selectedInventoryItem) { player.selectedInventoryItem = null; } if (selectedUpgradeInput.slotIndex !== -1) selectedUpgradeInput = { slotIndex: -1, source: null }; } }
function isNearWorkbench() { for (const obj of solidObjects) { if (obj.isPlaced && obj.type === 'workbench' && distanceSq(player.x,player.y,obj.x,obj.y)<INTERACT_RANGE_SQ && distanceSq(player.x,player.y,obj.x,obj.y)>(player.radius+obj.radius-5)**2) return true; } return false; }
function isNearUpgrader() { for (const obj of solidObjects) { if (obj.isPlaced && obj.type === 'item_upgrader_t1' && distanceSq(player.x,player.y,obj.x,obj.y)<INTERACT_RANGE_SQ && distanceSq(player.x,player.y,obj.x,obj.y)>(player.radius+obj.radius-5)**2) return true; } return false; }
function findUpgradeableTool() { const types=['wood_sword','wood_axe','wood_pickaxe','wooden_bow']; for(let i=0;i<player.hotbarSlots.length;i++){const item=player.hotbarSlots[i];if(item&&types.includes(item.type)&&UPGRADER_RECIPES[item.type]){return {item,index:i,source:'hotbar'};}} for(let i=0;i<player.inventorySlots.length;i++){const item=player.inventorySlots[i];if(item&&types.includes(item.type)&&UPGRADER_RECIPES[item.type]){return {item,index:i,source:'inventory'};}} return null; }
function populateWorkbenchRecipes(listElement) { if(!listElement) return; listElement.innerHTML=''; const availableRecipes=recipes.filter(r=>r.requiresWorkbench===true); if(availableRecipes.length===0){listElement.innerHTML=`<li>No workbench recipes available yet.</li>`;}else{availableRecipes.forEach(recipe=>{const li=document.createElement('li');const canCurrentlyCraft=canCraft(recipe);let ingredientsHTML=''; for(const itemId in recipe.input){const req=recipe.input[itemId];const owned=getTotalItemCount(itemId);const missingCls=owned<req?'missing':'';const itemName=(ITEM_DATA[itemId]?.name||itemId).replace(/_/g,' ');ingredientsHTML+=`<span class="ingredient ${missingCls}">${itemName}: ${owned}/${req}</span>`;} li.innerHTML=`<div><strong>${recipe.name}</strong><div class="recipe-details">${ingredientsHTML}</div></div><button data-recipe-id="${recipe.id}" ${canCurrentlyCraft?'':'disabled'}>Craft</button>`; const craftBtn=li.querySelector('button');if(craftBtn){craftBtn.addEventListener('click',()=>{doCraft(recipe.id);});} listElement.appendChild(li);});}}
function populateUpgraderUI() { const inputSlotDiv=document.getElementById('upgraderInputSlot'); const materialSlotDiv=document.getElementById('upgraderMaterialSlot'); const outputSlotDiv=document.getElementById('upgraderOutputSlot'); const upgradeBtn=document.getElementById('upgradeItemButton'); if(!inputSlotDiv||!materialSlotDiv||!outputSlotDiv||!upgradeBtn){console.error("Missing Upgrader UI elements");return;} const createSlotCanvas=(item)=>{const c=document.createElement('canvas');c.width=40;c.height=40;c.classList.add('item-icon');const ctx=c.getContext('2d');if(item&&item.type){drawItemShape(ctx,item.type,c.width);}return c;}; inputSlotDiv.innerHTML='(Click Tool)';inputSlotDiv.style.opacity='0.5';inputSlotDiv.classList.remove('has-item'); materialSlotDiv.innerHTML='(Material)';materialSlotDiv.style.opacity='0.5';materialSlotDiv.classList.remove('has-item'); outputSlotDiv.innerHTML='(Result)';outputSlotDiv.style.opacity='0.5';outputSlotDiv.classList.remove('has-item'); upgradeBtn.disabled=true; if(!inputSlotDiv.dataset.listenerAdded){inputSlotDiv.addEventListener('click',handleUpgraderInputClick);inputSlotDiv.dataset.listenerAdded='true';} let currentInputItem=null; if(selectedUpgradeInput.slotIndex!==-1&&selectedUpgradeInput.source){const srcArr=selectedUpgradeInput.source==='inventory'?player.inventorySlots:player.hotbarSlots;currentInputItem=srcArr[selectedUpgradeInput.slotIndex];} if(currentInputItem){inputSlotDiv.innerHTML='';inputSlotDiv.appendChild(createSlotCanvas(currentInputItem));inputSlotDiv.style.opacity='1';inputSlotDiv.classList.add('has-item');const upgradeRecipe=UPGRADER_RECIPES[currentInputItem.type];if(upgradeRecipe){materialSlotDiv.innerHTML='';const materialItem={type:upgradeRecipe.material,count:upgradeRecipe.materialCount};materialSlotDiv.appendChild(createSlotCanvas(materialItem));const countSpanMat=document.createElement('span');countSpanMat.classList.add('item-count');countSpanMat.textContent=upgradeRecipe.materialCount;materialSlotDiv.appendChild(countSpanMat);materialSlotDiv.style.opacity='1';materialSlotDiv.classList.add('has-item');outputSlotDiv.innerHTML='';const outputItem={type:upgradeRecipe.output,count:1};outputSlotDiv.appendChild(createSlotCanvas(outputItem));outputSlotDiv.style.opacity='1';outputSlotDiv.classList.add('has-item');const hasMats=getTotalItemCount(upgradeRecipe.material)>=upgradeRecipe.materialCount;upgradeBtn.disabled=!hasMats;}else{outputSlotDiv.innerHTML='(Invalid)';upgradeBtn.disabled=true;}}else{upgradeBtn.disabled=true;} }
function handleUpgraderInputClick() { const selected=player.selectedInventoryItem; if(selected){const itemType=selected.type;if(UPGRADER_RECIPES[itemType]){selectedUpgradeInput.slotIndex=selected.index;selectedUpgradeInput.source=selected.source;player.selectedInventoryItem=null;populateCraftingMenu(false,true);}}else if(selectedUpgradeInput.slotIndex!==-1){selectedUpgradeInput={slotIndex:-1,source:null};populateCraftingMenu(false,true);} }
function doUpgrade() { if(selectedUpgradeInput.slotIndex===-1||!selectedUpgradeInput.source){console.warn("No tool selected to upgrade.");return;} const srcArr=selectedUpgradeInput.source==='inventory'?player.inventorySlots:player.hotbarSlots;const toolToUpgrade=srcArr[selectedUpgradeInput.slotIndex]; if(!toolToUpgrade){console.error("Selected tool disappeared?");selectedUpgradeInput={slotIndex:-1,source:null};populateCraftingMenu(false,true);return;} const upgradeRecipe=UPGRADER_RECIPES[toolToUpgrade.type]; if(!upgradeRecipe){console.error("Upgrade recipe inconsistency.");return;} if(getTotalItemCount(upgradeRecipe.material)>=upgradeRecipe.materialCount){const removedMat=removeFromInventory(upgradeRecipe.material,upgradeRecipe.materialCount); let removedTool=false; if(selectedUpgradeInput.source==='inventory'){player.inventorySlots[selectedUpgradeInput.slotIndex]=null;removedTool=true;}else if(selectedUpgradeInput.source==='hotbar'){player.hotbarSlots[selectedUpgradeInput.slotIndex]=null;removedTool=true;updateMainHotbarVisuals();updateEquippedItem();} if(removedMat&&removedTool){addToInventory(upgradeRecipe.output,1);console.log(`%cUpgraded to ${upgradeRecipe.name}!`, "color: lightblue; font-weight: bold;");selectedUpgradeInput={slotIndex:-1,source:null};populateCraftingMenu(false,true);}else{console.error("Failed to remove resources during upgrade attempt.");}}else{console.warn(`Not enough ${upgradeRecipe.material} (button click).`);} }
const integratedUpgradeButton = document.getElementById('upgradeItemButton'); if (integratedUpgradeButton) integratedUpgradeButton.addEventListener('click', doUpgrade);
function updateMainHotbarVisuals() { mainHotbarSlots.forEach((slotDiv,index)=>{const item=player.hotbarSlots[index];const existingIcon=slotDiv.querySelector('.item-icon');const existingCount=slotDiv.querySelector('.item-count');if(existingIcon)slotDiv.removeChild(existingIcon);if(existingCount)slotDiv.removeChild(existingCount);let numSpan=slotDiv.querySelector('span');if(!numSpan){numSpan=document.createElement('span');numSpan.style.opacity='0.5';numSpan.style.position='absolute';numSpan.style.top='5px';numSpan.style.left='5px';numSpan.style.zIndex='-1';numSpan.textContent=`${index+1}`;slotDiv.appendChild(numSpan);} if(item){const itemCanvas=document.createElement('canvas');itemCanvas.width=35;itemCanvas.height=35;itemCanvas.classList.add('item-icon');itemCanvas.style.pointerEvents='none';const itemCtx=itemCanvas.getContext('2d');if(item.type){drawItemShape(itemCtx,item.type,itemCanvas.width);} slotDiv.appendChild(itemCanvas);if(item.count>1){const countSpan=document.createElement('span');countSpan.classList.add('item-count');countSpan.textContent=item.count;slotDiv.appendChild(countSpan);}}}); }

// --- Collision Detection ---
function checkCollision(entityRadius, potentialX, potentialY, ignoreId = null, checkAgainst = [...solidObjects, ...monsters, ...bosses, ...undeadMinions]) { // Added undead
    for (const solid of checkAgainst) {
        // Ensure target exists, isn't the entity itself, and is 'alive' for non-wall checks if applicable
        if (solid && solid.id !== ignoreId && (solid.isWall || solid.health > 0)) {
            if (solid.isWall) { const cx=Math.max(solid.x,Math.min(potentialX,solid.x+solid.width)); const cy=Math.max(solid.y,Math.min(potentialY,solid.y+solid.height)); if(distanceSq(potentialX,potentialY,cx,cy)<entityRadius*entityRadius) return solid; }
            else if (typeof solid.radius==='number') { if(distanceSq(potentialX,potentialY,solid.x,solid.y)<(entityRadius+solid.radius)**2) return solid; }
        }
    } return null;
}

// --- Initialization Functions ---
function createWalls() { walls = []; solidObjects = solidObjects.filter(obj => !obj.isWall); console.log("Creating biome walls..."); const add=(id,x,y,w,h,tier)=>{const wall={id:id,x:x,y:y,width:w,height:h,color:WALL_COLOR,isWall:true,tier:tier,isSolid:true,isAttackable:false, health: Infinity}; walls.push(wall);solidObjects.push(wall);}; add('wall_f_p',BIOME_BOUNDS.FOREST_X_END-WALL_THICKNESS/2,BIOME_BOUNDS.FROSTLANDS_Y_END,WALL_THICKNESS,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END,1); add('wall_j_p',BIOME_BOUNDS.JUNGLE_X_START-WALL_THICKNESS/2,BIOME_BOUNDS.FROSTLANDS_Y_END,WALL_THICKNESS,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END,1); add('wall_r_f',BIOME_BOUNDS.ROCKY_X_END-WALL_THICKNESS/2,0,WALL_THICKNESS,BIOME_BOUNDS.ROCKY_Y_END,2); add('wall_s_f',BIOME_BOUNDS.SWAMP_X_START-WALL_THICKNESS/2,0,WALL_THICKNESS,BIOME_BOUNDS.SWAMP_Y_END,2); add('wall_v_d',BIOME_BOUNDS.VOLCANO_X_END-WALL_THICKNESS/2,BIOME_BOUNDS.VOLCANO_Y_START,WALL_THICKNESS,WORLD_HEIGHT-BIOME_BOUNDS.VOLCANO_Y_START,3); add('wall_b_d',BIOME_BOUNDS.BADLANDS_X_START-WALL_THICKNESS/2,BIOME_BOUNDS.BADLANDS_Y_START,WALL_THICKNESS,WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START,3); add('wall_fr_pl',BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.FROSTLANDS_Y_END-WALL_THICKNESS/2,BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END,WALL_THICKNESS,4); add('wall_d_pl',BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.DESERT_Y_START-WALL_THICKNESS/2,BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END,WALL_THICKNESS,4); add('wall_r_fo',0,BIOME_BOUNDS.ROCKY_Y_END-WALL_THICKNESS/2,BIOME_BOUNDS.ROCKY_X_END,WALL_THICKNESS,4); add('wall_s_j',BIOME_BOUNDS.SWAMP_X_START,BIOME_BOUNDS.SWAMP_Y_END-WALL_THICKNESS/2,WORLD_WIDTH-BIOME_BOUNDS.SWAMP_X_START,WALL_THICKNESS,4); add('wall_v_fo',0,BIOME_BOUNDS.VOLCANO_Y_START-WALL_THICKNESS/2,BIOME_BOUNDS.VOLCANO_X_END,WALL_THICKNESS,4); add('wall_b_j',BIOME_BOUNDS.BADLANDS_X_START,BIOME_BOUNDS.BADLANDS_Y_START-WALL_THICKNESS/2,WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START,WALL_THICKNESS,4); console.log(`Created ${walls.length} wall segments.`); }
function spawnInitialResources() { resources=[]; solidObjects=[]; let resCount=0, treeCount=0, rockCount=0, boneCount=0, attempts=0; const MAX_ATT=15000; console.log(`Spawning ${FOREST_TREE_TARGET} trees...`); attempts=0; while(treeCount<FOREST_TREE_TARGET&&attempts<MAX_ATT*2){attempts++;const x=Math.random()*BIOME_BOUNDS.FOREST_X_END,y=BIOME_BOUNDS.FROSTLANDS_Y_END+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); if(getBiomeAt(x,y)!=='forest')continue; const d=ITEM_DATA['tree'], r=d?.radius||15, h=d?.health||50; const res={id:`res_t_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:'tree',color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false,variant:null}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);treeCount++;resCount++;}} console.log(`Spawned ${treeCount} forest trees.`); console.log(`Spawning 1500 rocks...`); attempts=0; let count=0; while(count<1500&&attempts<MAX_ATT*1.5){attempts++;const x=Math.random()*BIOME_BOUNDS.ROCKY_X_END,y=Math.random()*BIOME_BOUNDS.ROCKY_Y_END; if(getBiomeAt(x,y)!=='rocky')continue; const d=ITEM_DATA['rock'], r=d?.radius||12, h=d?.health||150; const res={id:`res_r_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:'rock',color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);count++;resCount++;}} console.log(`Spawned ${count} rocky rocks.`); console.log(`Spawning 300 bone trees...`); attempts=0; count=0; while(count<300&&attempts<MAX_ATT){attempts++;const x=BIOME_BOUNDS.BADLANDS_X_START+Math.random()*(WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START),y=BIOME_BOUNDS.BADLANDS_Y_START+Math.random()*(WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START); if(getBiomeAt(x,y)!=='badlands')continue; const d=ITEM_DATA['bone_tree'], r=d?.radius||13, h=d?.health||80; const res={id:`res_b_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:'bone_tree',color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false,variant:'bone'}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);count++;resCount++;}} console.log(`Spawned ${count} bone trees.`); console.log("Spawning other resources..."); const TARGET_OTHER=2000; attempts=0; const MAX_OTHER_ATT=TARGET_OTHER*15; let tempOther=0; while(tempOther<TARGET_OTHER&&attempts<MAX_OTHER_ATT){attempts++;const x=Math.random()*WORLD_WIDTH,y=Math.random()*WORLD_HEIGHT;const biome=getBiomeAt(x,y); if(biome==='rocky'||biome==='badlands'||biome==='forest')continue; if((x>JUNGLE_LAKE.x&&x<JUNGLE_LAKE.x+JUNGLE_LAKE.width&&y>JUNGLE_LAKE.y&&y<JUNGLE_LAKE.y+JUNGLE_LAKE.height)||lavaPools.some(p=>x>p.x&&x<p.x+p.width&&y>p.y&&y<p.y+p.height)||(x<ISLAND_PADDING/2||x>WORLD_WIDTH-ISLAND_PADDING/2||y<ISLAND_PADDING/2||y>WORLD_HEIGHT-ISLAND_PADDING/2))continue; const data=BIOME_DATA[biome];const mult=data.spawnMultiplier||1;const chance=0.05;if(Math.random()>chance*mult)continue; const rand=Math.random();let type=null,variant=null;let treeD=data.treeDensity,rockD=data.rockDensity,cactusD=data.cactusDensity; if(biome==='volcano'||biome==='swamp')treeD=0; const totalD=treeD+rockD+cactusD; if(totalD>0){const treeC=treeD/totalD;const rockC=rockD/totalD; if(rand<treeC){type='tree';if(biome==='frostlands')variant='snowy';}else if(rand<treeC+rockC){type='rock';}else if(cactusD>0&&biome==='desert'){type='cactus';}} if(type){const d=ITEM_DATA[type];const r=d?.radius||(type==='tree'?(12+Math.random()*6):(10+Math.random()*4));const h=d?.health||(type==='tree'?50:150);const res={id:`res_${type}_${Date.now()}_${Math.random()}`,x:x,y:y,radius:r,type:type,color:d.color,maxHealth:h*2,health:h*2,flashUntil:0,isAttackable:true,isSolid:true,isPlaced:false,variant:variant}; if(!checkCollision(r,x,y,null,solidObjects)){resources.push(res);solidObjects.push(res);tempOther++;resCount++;}}} if(attempts>=MAX_OTHER_ATT)console.warn("Max attempts spawning other resources."); console.log(`Total resources spawned: ${resCount}`); }
function spawnInitialMonsters() { monsters = []; let attempts=0; const MAX_ATT=INITIAL_MONSTER_COUNT*5; console.log(`Spawning ${INITIAL_MONSTER_COUNT} monsters...`); let count=0; while(count<INITIAL_MONSTER_COUNT&&attempts<MAX_ATT){attempts++;const x=Math.random()*WORLD_WIDTH, y=Math.random()*WORLD_HEIGHT; if((x>JUNGLE_LAKE.x&&x<JUNGLE_LAKE.x+JUNGLE_LAKE.width&&y>JUNGLE_LAKE.y&&y<JUNGLE_LAKE.y+JUNGLE_LAKE.height)||lavaPools.some(p=>x>p.x&&x<p.x+p.width&&y>p.y&&y<p.y+p.height)||(x<ISLAND_PADDING/2||x>WORLD_WIDTH-ISLAND_PADDING/2||y<ISLAND_PADDING/2||y>WORLD_HEIGHT-ISLAND_PADDING/2)||distanceSq(x,y,player.x,player.y)<(200*200)||checkCollision(10,x,y,null,solidObjects)) continue; const h=50; const mon={id:`mon_${Date.now()}_${Math.random()}`,x:x,y:y,radius:10+Math.random()*5,type:'slime',color:'#DC143C',maxHealth:h*2,health:h*2,flashUntil:0,state:'idle',attackCooldown:MONSTER_ATTACK_COOLDOWN,lastAttackTime:0,target:null,isAttackable:true,isSolid:false}; monsters.push(mon); count++;} if(attempts>=MAX_ATT&&count<INITIAL_MONSTER_COUNT){console.warn(`Max spawn attempts for monsters. Spawned: ${count}`);} console.log(`Spawned ${count} actual monsters.`); }
function spawnBosses() { bosses=[]; const h=PLAINS_BOSS_HEALTH, buf=50; let x,y,att=0, MAX_ATT=50; do{x=BIOME_BOUNDS.FOREST_X_END+buf+Math.random()*(BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END-2*buf); y=BIOME_BOUNDS.FROSTLANDS_Y_END+buf+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END-2*buf); att++;} while(checkCollision(PLAINS_BOSS_RADIUS,x,y,null,solidObjects)&&att<MAX_ATT); if(att>=MAX_ATT){console.error("Cannot find valid boss spawn!");x=WORLD_CENTER_X;y=WORLD_CENTER_Y;} const boss={id:`boss_plains_${Date.now()}`,x:x,y:y,radius:PLAINS_BOSS_RADIUS,type:'plains_boss',color:'#665A48',angle:0,maxHealth:h,health:h,flashUntil:0,state:'patrolling',attackCooldown:PLAINS_BOSS_ATTACK_COOLDOWN,lastAttackTime:0,attackTarget:null,speed:PLAINS_BOSS_SPEED,detectRangeSq:PLAINS_BOSS_DETECT_RANGE_SQ,attackRange_hit:BOSS_HIT_RANGE,attackRange_smash:BOSS_SMASH_RANGE,attackRange_spin:BOSS_SPIN_RANGE,patrolTargetX:null,patrolTargetY:null,attackAnimationTimer:0,attackChoiceCooldown:PLAINS_BOSS_ATTACK_CHOICE_COOLDOWN,lastAttackChoiceTime:0,currentAttack:null,smashLanded:false,lastSpinDamageTime:0,isAttackable:true,isSolid:true,isPlaced:false,isBoss:true}; bosses.push(boss); solidObjects.push(boss); console.log("Spawned Plains Boss at",Math.round(x),Math.round(y)); }

// --- Input Handling ---
document.addEventListener('keydown', (event) => { if (isGameOver || !gameHasStarted) return; const key=event.key.toLowerCase(); if (key==='e'){toggleCraftingMenu();keysPressed[key]=false;return;} if (key==='escape'){if(isCraftingMenuOpen){toggleCraftingMenu();} keysPressed[key]=false;return;} if(isCraftingMenuOpen) return; if(key==='m'){isMinimapVisible=!isMinimapVisible;console.log(`Minimap toggled: ${isMinimapVisible?'ON':'OFF'}`);keysPressed[key]=false;event.preventDefault();return;} keysPressed[key]=true; if(!isNaN(parseInt(key))&&parseInt(key)>=1&&parseInt(key)<=HOTBAR_SIZE){selectHotbar(parseInt(key)-1);} });
document.addEventListener('keyup', (event) => { keysPressed[event.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', (event) => { if(isGameOver||!gameHasStarted)return; const rect=canvas.getBoundingClientRect(); mouseCanvasX=event.clientX-rect.left; mouseCanvasY=event.clientY-rect.top; const worldCoords=canvasToWorld(mouseCanvasX,mouseCanvasY); worldMouseX=worldCoords.x; worldMouseY=worldCoords.y; });
canvas.addEventListener('mousedown', (event) => { if(isGameOver||isCraftingMenuOpen||!gameHasStarted)return; if(event.button===0){player.isAttacking=true;player.attackTimer=Date.now();tryAttack();} else if(event.button===2){if(!player.isInteracting&&!player.isAttacking){player.isInteracting=true;player.interactTimer=Date.now();tryInteract();}} });
closeCraftingButton.addEventListener('click', ()=>{if(player.selectedInventoryItem){player.selectedInventoryItem=null;} if(selectedUpgradeInput.slotIndex!==-1)selectedUpgradeInput={slotIndex:-1,source:null}; toggleCraftingMenu();});
canvas.addEventListener('contextmenu', (event) => event.preventDefault());

// --- Action Functions ---
function findNearestObject(x, y, rangeSq, filterFn = () => true) { let closest=null,minDistSq=rangeSq; for(const obj of solidObjects){if(obj.isPlaced&&filterFn(obj)){const dSq=distanceSq(x,y,obj.x,obj.y);if(dSq<minDistSq&&dSq<(obj.radius+PLAYER_RADIUS)**2){minDistSq=dSq;closest=obj;}}} return closest; }
function decrementHotbarItem(index) { const slot=player.hotbarSlots[index]; if(!slot)return false; slot.count--; if(slot.count<=0){player.hotbarSlots[index]=null;} updateMainHotbarVisuals();updateEquippedItem();if(isCraftingMenuOpen){populateCraftingMenu(isNearWorkbench(),isNearUpgrader());} return true;}
function tryAttack() { if (!gameHasStarted) return; const now=Date.now(); const equippedItemSlot=player.hotbarSlots[player.selectedHotbarSlotIndex]; const equippedItemType=equippedItemSlot?equippedItemSlot.type:null; const equippedItemData=equippedItemType?ITEM_DATA[equippedItemType]:null; if(equippedItemData&&equippedItemData.type==='tool'&&equippedItemData.toolType==='bow'){if(now-player.lastBowShotTime>=BOW_COOLDOWN){player.lastBowShotTime=now;const speed=PROJECTILE_SPEED,range=equippedItemData.range||PROJECTILE_RANGE,dmg=(equippedItemData.damage||10)*player.bowMultiplierBoost;const proj={id:`proj_${player.id}_${now}`,ownerId:player.id,x:player.x+Math.cos(player.angle)*(player.radius+5),y:player.y+Math.sin(player.angle)*(player.radius+5),vx:Math.cos(player.angle)*speed,vy:Math.sin(player.angle)*speed,damage:dmg,range:range,traveled:0,radius:PROJECTILE_RADIUS,color:'#F5F5DC',type:'arrow_projectile'};projectiles.push(proj);console.log(`Fired arrow (Dmg:${dmg.toFixed(1)})`);} return;} let bestTarget=null,minDistSq=(ATTACK_RANGE+player.radius)**2; const attackables=[...monsters,...resources,...bosses,...undeadMinions]; const ax=player.x+Math.cos(player.angle)*player.radius, ay=player.y+Math.sin(player.angle)*player.radius; for(const target of attackables){if(!target||target.health<=0||!target.isAttackable)continue; let hit=false; if(target.isWall){const cx=Math.max(target.x,Math.min(ax,target.x+target.width)),cy=Math.max(target.y,Math.min(ay,target.y+target.height));if(distanceSq(ax,ay,cx,cy)<ATTACK_RANGE**2)hit=true;} else if(typeof target.radius==='number'){const dSq=distanceSq(ax,ay,target.x,target.y);if(dSq<minDistSq&&dSq<(target.radius+ATTACK_RANGE)**2)hit=true;} if(hit){const angleTo=Math.atan2(target.y-player.y,target.x-player.x);const angleDiff=Math.abs(normalizeAngle(player.angle-angleTo));if(angleDiff<ATTACK_SWING_ARC/2+0.5){if(target.isWall){bestTarget=target;}else{const dSq=distanceSq(ax,ay,target.x,target.y);if(dSq<minDistSq){minDistSq=dSq;bestTarget=target;}}}}} if(bestTarget){if(bestTarget.isWall){console.log("Hit wall");return;} const targetIsEnemy=monsters.some(m=>m.id===bestTarget.id)||bosses.some(b=>b.id===bestTarget.id); const targetIsMonster=monsters.some(m=>m.id===bestTarget.id); bestTarget.flashUntil=now+FLASH_DURATION; let damage=0,canDmg=true; const targetIsBoss=bosses.some(b=>b.id===bestTarget.id);const targetIsTree=bestTarget.type==='tree';const targetIsRock=bestTarget.type==='rock';const targetIsCactus=bestTarget.type==='cactus';const targetIsBone=bestTarget.type==='bone_tree';const targetIsPlaced=bestTarget.isPlaced;const targetIsUndead=bestTarget.type==='undead_minion'; if(equippedItemData&&equippedItemData.type==='tool'){if((targetIsEnemy||targetIsUndead)&&equippedItemData.toolType==='sword'){damage=BASE_ATTACK_POWER*equippedItemData.damageMultiplier*player.swordMultiplierBoost;console.log(`Sword on ${bestTarget.type||'res'} (Dmg:${damage.toFixed(1)})`);} else if((targetIsTree||targetIsBone)&&equippedItemData.toolType==='axe'){damage=BASE_GATHER_POWER*equippedItemData.gatherMultiplier;} else if(targetIsRock&&equippedItemData.toolType==='pickaxe'){damage=BASE_GATHER_POWER*equippedItemData.gatherMultiplier;} else if(targetIsCactus&&equippedItemData.toolType==='axe'){damage=BASE_GATHER_POWER*equippedItemData.gatherMultiplier;} else if(targetIsPlaced&&(equippedItemData.toolType==='axe'||equippedItemData.toolType==='pickaxe')){damage=BASE_GATHER_POWER*2.0;} else {damage=BASE_ATTACK_POWER/2;}} else {damage=(targetIsEnemy||targetIsUndead)?BASE_ATTACK_POWER:BASE_GATHER_POWER;if(targetIsRock){damage=BASE_GATHER_POWER/3;}} if(canDmg&&damage>0){bestTarget.health-=damage;if(targetIsEnemy&&player.lifesteal>0){const hBef=player.health;player.health=Math.min(player.maxHealth,player.health+player.lifesteal);if(player.health>hBef)updateUI();} if(bestTarget.health<=0){console.log(`%cDestroyed ${bestTarget.type||'res'}!`,'color:orange;font-weight:bold;');const dx=bestTarget.x,dy=bestTarget.y;let drops=[];if(targetIsMonster&&player.necromancyChance>0){if(undeadMinions.length<MAX_UNDEAD_MINIONS){if(Math.random()<player.necromancyChance){console.log("%cNecromancy!", "color:magenta;font-weight:bold;");spawnUndeadMinion(dx,dy);}}else{console.log("%cMax undead.", "color:gray;");}} if(targetIsTree){drops.push({type:'wood',count:1+Math.floor(Math.random()*3)});if(Math.random()<0.2)drops.push({type:'plant_fiber',count:1});} else if(targetIsRock){drops.push({type:'stone',count:1+Math.floor(Math.random()*2)});} else if(targetIsCactus){drops.push({type:'plant_fiber',count:1+Math.floor(Math.random()*2)});} else if(targetIsBone){drops.push({type:'dust',count:1+Math.floor(Math.random()*3)});if(Math.random()<0.02){drops.push({type:'bone_scythe',count:1});console.log("%cDrops Bone Scythe!","color:magenta;font-weight:bold;");}} else if(targetIsMonster){drops.push({type:'monster_goop',count:1+Math.floor(Math.random()*4)});if(Math.random()<GOLD_COIN_DROP_CHANCE)drops.push({type:'gold_coin',count:1});if(Math.random()<0.02)drops.push({type:'healing_salve',count:1});gainXP(MONSTER_XP_REWARD);} else if(targetIsBoss&&bestTarget.type==='plains_boss'){drops.push({type:'gold_coin',count:10+Math.floor(Math.random()*16)});drops.push({type:'stone',count:5+Math.floor(Math.random()*11)});drops.push({type:'wooden_bow',count:1});drops.push({type:'iron_ore',count:15});if(Math.random()<0.1)drops.push({type:'healing_salve',count:2});gainXP(PLAINS_BOSS_XP_REWARD);const tier=BOSS_WALL_TIER_MAP[bestTarget.type];if(tier!==undefined){const wc=walls.length;walls=walls.filter(w=>w.tier!==tier);solidObjects=solidObjects.filter(s=>!(s.isWall&&s.tier===tier));const rem=wc-walls.length;if(rem>0)console.log(`%cTier ${tier} walls (${rem}) gone!`,'color:blue;font-weight:bold;');else console.log(`%cNo Tier ${tier} walls found.`,'color:gray;');}else{console.warn(`No wall tier map for ${bestTarget.type}`);}} else if(targetIsPlaced){drops.push({type:bestTarget.type,count:1});} drops.forEach(d=>addDroppedItem(dx,dy,d.type,d.count)); if(bestTarget.isSolid)solidObjects=solidObjects.filter(s=>s.id!==bestTarget.id); if(targetIsMonster)monsters=monsters.filter(m=>m.id!==bestTarget.id); else if(targetIsBoss) {bosses=bosses.filter(b=>b.id!==bestTarget.id); solidObjects=solidObjects.filter(s=>s.id!==bestTarget.id);} else if(targetIsUndead)undeadMinions=undeadMinions.filter(u=>u.id!==bestTarget.id); else resources=resources.filter(r=>r.id!==bestTarget.id);}}} }
function tryInteract() { if (!gameHasStarted) return; const item=player.hotbarSlots[player.selectedHotbarSlotIndex]; const type=item?item.type:null; const data=type?ITEM_DATA[type]:null; if(item&&data&&data.isUsable){if(type==='healing_salve'){if(player.health<player.maxHealth){player.health=Math.min(player.maxHealth,player.health+HEAL_AMOUNT);decrementHotbarItem(player.selectedHotbarSlotIndex);console.log(`Used Salve. HP: ${player.health.toFixed(0)}`);return;}else{console.log("Health full.");return;}} return;} const nearby=findNearestObject(player.x,player.y,INTERACT_RANGE_SQ,(obj)=>ITEM_DATA[obj.type]?.isInteractable); if(nearby){if(nearby.type==='icky_bed'){player.respawnX=nearby.x;player.respawnY=nearby.y;console.log(`%cSpawn set!`,'color:yellow;');nearby.flashUntil=Date.now()+200;return;} return;} if(item&&data&&data.isPlaceable){const gx=Math.round(worldMouseX/PLACE_GRID_SIZE)*PLACE_GRID_SIZE, gy=Math.round(worldMouseY/PLACE_GRID_SIZE)*PLACE_GRID_SIZE; if(distanceSq(player.x,player.y,gx,gy)>PLACE_RANGE_SQ)return; const r=data.solidRadius||PLACE_GRID_SIZE/2; if(checkCollision(r-1,gx,gy,null,solidObjects))return; if(distanceSq(player.x,player.y,gx,gy)<(player.radius+r)**2)return; const placed={id:`placed_${Date.now()}_${Math.random()}`,x:gx,y:gy,radius:r,type:type,color:data.color,maxHealth:data.health||100,health:data.health||100,flashUntil:0,isAttackable:data.isAttackable??true,isSolid:data.isSolid??true,isPlaced:true,lightRadius:data.lightRadius||0,isInteractable:data.isInteractable||false}; resources.push(placed); if(placed.isSolid)solidObjects.push(placed); decrementHotbarItem(player.selectedHotbarSlotIndex); console.log(`Placed ${type} at (${gx},${gy})`); return;} }
function selectHotbar(index) { if(index<0||index>=HOTBAR_SIZE)return; player.selectedHotbarSlotIndex=index; mainHotbarSlots.forEach((slot,i)=>{slot.classList.toggle('selected',i===index);}); updateEquippedItem(); }
function updateEquippedItem() { const slot=player.hotbarSlots[player.selectedHotbarSlotIndex]; player.equippedItemType=slot?slot.type:null; }

// --- Update Functions ---
function updatePlayer(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted)return; let dx=0,dy=0; if(keysPressed['w'])dy-=1; if(keysPressed['s'])dy+=1; if(keysPressed['a'])dx-=1; if(keysPressed['d'])dx+=1; const mag=Math.sqrt(dx*dx+dy*dy); let speed=PLAYER_SPEED*player.speedMultiplier; if(!isNight&&player.daySpeedPenalty<1.0){speed*=player.daySpeedPenalty;} if(mag>0){dx=(dx/mag)*speed; dy=(dy/mag)*speed;}else{dx=0;dy=0;} let px=player.x+dx,py=player.y+dy; let collided=checkCollision(player.radius,px,py,player.id,[...solidObjects,...monsters,...bosses,...undeadMinions]); if(collided){px=player.x+dx;py=player.y;collided=checkCollision(player.radius,px,py,player.id,[...solidObjects,...monsters,...bosses,...undeadMinions]);if(collided){px=player.x;py=player.y+dy;collided=checkCollision(player.radius,px,py,player.id,[...solidObjects,...monsters,...bosses,...undeadMinions]);if(collided){px=player.x;py=player.y;}}} player.x=px;player.y=py; player.x=Math.max(player.radius,Math.min(WORLD_WIDTH-player.radius,player.x));player.y=Math.max(player.radius,Math.min(WORLD_HEIGHT-player.radius,player.y)); for(let i=droppedItems.length-1;i>=0;i--){const item=droppedItems[i];if(distanceSq(player.x,player.y,item.x,item.y)<ITEM_PICKUP_RANGE_SQ){addToInventory(item.type,1);droppedItems.splice(i,1);}} const aimX=worldMouseX-player.x,aimY=worldMouseY-player.y;player.angle=Math.atan2(aimY,aimX); const now=Date.now();if(player.isAttacking&&now-player.attackTimer>ATTACK_DURATION)player.isAttacking=false;if(player.isInteracting&&now-player.interactTimer>INTERACT_DURATION)player.isInteracting=false; if(player.health<=0&&!isGameOver){isGameOver=true;console.error("Player Died!");deathMessageDiv.style.display='block';const dX=player.x,dY=player.y; setTimeout(()=>{const slots=[...player.inventorySlots.map((it,idx)=>it?{item:it,index:idx,source:'inventory'}:null),...player.hotbarSlots.map((it,idx)=>it?{item:it,index:idx,source:'hotbar'}:null)].filter(Boolean);if(slots.length>0){const rIdx=Math.floor(Math.random()*slots.length);const slotDrop=slots[rIdx];const dropped=slotDrop.item;if(dropped){console.log(`%cDrop ${dropped.count}x ${dropped.type} from ${slotDrop.source} ${slotDrop.index} on death!`,"color:orange");addDroppedItem(dX,dY,dropped.type,dropped.count);if(slotDrop.source==='inventory')player.inventorySlots[slotDrop.index]=null;else player.hotbarSlots[slotDrop.index]=null;if(isCraftingMenuOpen)populateCraftingMenu(isNearWorkbench(),isNearUpgrader());updateMainHotbarVisuals();}} player.health=player.maxHealth;player.x=player.respawnX;player.y=player.respawnY;player.isAttacking=false;player.isInteracting=false;clampCamera();updateUI();deathMessageDiv.style.display='none';isGameOver=false;},2000);} }
function updateMonsters(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted)return; const now=Date.now(); monsters.forEach(monster=>{if(monster.health<=0)return; let potentialTarget=null,targetDistSq=Infinity,targetIsPlayer=false; const distPlayerSq=distanceSq(monster.x,monster.y,player.x,player.y); if(distPlayerSq<MONSTER_DETECT_RANGE**2){if(!isLineObstructed(monster.x,monster.y,player.x,player.y,walls)){potentialTarget=player;targetDistSq=distPlayerSq;targetIsPlayer=true;}} for(const minion of undeadMinions){if(minion.health<=0)continue; const distMinionSq=distanceSq(monster.x,monster.y,minion.x,minion.y); if(distMinionSq<MONSTER_DETECT_RANGE**2&&distMinionSq<targetDistSq){if(!isLineObstructed(monster.x,monster.y,minion.x,minion.y,walls)){potentialTarget=minion;targetDistSq=distMinionSq;targetIsPlayer=false;}}} if(potentialTarget){monster.target=potentialTarget; const stopChasingRangeSq = (MONSTER_ATTACK_RANGE + monster.radius + potentialTarget.radius)**2; if(targetDistSq<=stopChasingRangeSq)monster.state='attacking'; else monster.state='chasing';}else{monster.state='idle';monster.target=null;} let dx=0,dy=0; if(monster.state==='chasing'&&monster.target&&monster.target.health>0){const angle=Math.atan2(monster.target.y-monster.y,monster.target.x-monster.x);dx=Math.cos(angle)*MONSTER_SPEED;dy=Math.sin(angle)*MONSTER_SPEED;} if(dx!==0||dy!==0){let px=monster.x+dx,py=monster.y+dy; const others=monsters.filter(m=>m.id!==monster.id); let collided=checkCollision(monster.radius,px,py,monster.id,[...solidObjects,...others,...bosses,player,...undeadMinions]); if(!collided){monster.x=px;monster.y=py;}else{/* Sliding? */}} if(monster.state==='attacking'&&monster.target&&monster.target.health>0){if(now-monster.lastAttackTime>monster.attackCooldown){const contactDistanceSq = (monster.radius + monster.target.radius)**2; const currentDistToTargetSq = distanceSq(monster.x, monster.y, monster.target.x, monster.target.y); if(currentDistToTargetSq <= contactDistanceSq) { monster.target.health-=MONSTER_DAMAGE;monster.target.health=Math.max(0,monster.target.health);monster.lastAttackTime=now;console.log(`Monster ${monster.id} *hits* ${monster.target.id}. Target HP: ${monster.target.health.toFixed(0)}`);if(monster.target.id===player.id){document.getElementById('gameContainer').style.boxShadow='inset 0 0 30px 10px rgba(255,0,0,0.5)';setTimeout(()=>document.getElementById('gameContainer').style.boxShadow='',150);}else{monster.target.flashUntil=now+FLASH_DURATION;}}}} monster.x=Math.max(monster.radius,Math.min(WORLD_WIDTH-monster.radius,monster.x));monster.y=Math.max(monster.radius,Math.min(WORLD_HEIGHT-monster.radius,monster.y));}); }
function updateBosses(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted)return; const now=Date.now(); bosses.forEach(boss=>{if(boss.health<=0)return; let potentialTarget=null,targetDistSq=Infinity,targetIsPlayer=false; const distPlayerSq=distanceSq(boss.x,boss.y,player.x,player.y); if(distPlayerSq<boss.detectRangeSq){if(!isLineObstructed(boss.x,boss.y,player.x,player.y,walls)){potentialTarget=player;targetDistSq=distPlayerSq;targetIsPlayer=true;}} for(const minion of undeadMinions){if(minion.health<=0)continue; const distMinionSq=distanceSq(boss.x,boss.y,minion.x,minion.y); if(distMinionSq<boss.detectRangeSq&&distMinionSq<targetDistSq){if(!isLineObstructed(boss.x,boss.y,minion.x,minion.y,walls)){potentialTarget=minion;targetDistSq=distMinionSq;targetIsPlayer=false;}}} boss.attackTarget=potentialTarget; if(potentialTarget){const angleToTarget=Math.atan2(potentialTarget.y-boss.y,potentialTarget.x-boss.x);boss.angle=angleToTarget;const attackRangeSq=targetIsPlayer?(BOSS_HIT_RANGE)**2:(BOSS_HIT_RANGE+boss.radius+UNDEAD_RADIUS-player.radius)**2; const smashRangeSq=targetIsPlayer?(BOSS_SMASH_RANGE)**2:(BOSS_SMASH_RANGE+boss.radius+UNDEAD_RADIUS-player.radius)**2;const spinRangeSq=targetIsPlayer?(BOSS_SPIN_RANGE)**2:(BOSS_SPIN_RANGE+boss.radius+UNDEAD_RADIUS-player.radius)**2;const inHitRange=targetDistSq<attackRangeSq;const inSmashRange=targetDistSq<smashRangeSq;const inSpinRange=targetDistSq<spinRangeSq;if(boss.state==='patrolling'||boss.state==='chasing'){if(inHitRange||inSmashRange||inSpinRange)boss.state='chasing';else boss.state='patrolling';} if(boss.state==='chasing'){if(now-boss.lastAttackChoiceTime>boss.attackChoiceCooldown&&now-boss.lastAttackTime>boss.attackCooldown){boss.lastAttackChoiceTime=now;let possible=[];if(inHitRange)possible.push('hit');if(inSmashRange)possible.push('smash');if(inSpinRange)possible.push('spin');if(possible.length>0){boss.currentAttack=possible[Math.floor(Math.random()*possible.length)];console.log("Boss chose:",boss.currentAttack);boss.state=`attacking_${boss.currentAttack}`;boss.attackAnimationTimer=0;boss.lastAttackTime=now;if(boss.currentAttack==='smash')boss.smashLanded=false;if(boss.currentAttack==='spin')boss.lastSpinDamageTime=0;}} let dx=Math.cos(boss.angle)*boss.speed, dy=Math.sin(boss.angle)*boss.speed; let px=boss.x+dx, py=boss.y+dy; const others=bosses.filter(b=>b.id!==boss.id); let collided=checkCollision(boss.radius,px,py,boss.id,[...solidObjects,...others,...monsters,player,...undeadMinions]); if(!collided){boss.x=px;boss.y=py;}else{/* Sliding */}}} else {boss.state='patrolling';boss.attackTarget=null;boss.patrolTargetX=null;} if(boss.state==='patrolling'){if(boss.patrolTargetX===null||distanceSq(boss.x,boss.y,boss.patrolTargetX,boss.patrolTargetY)<50**2){const buf=100;boss.patrolTargetX=BIOME_BOUNDS.FOREST_X_END+buf+Math.random()*(BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END-2*buf);boss.patrolTargetY=BIOME_BOUNDS.FROSTLANDS_Y_END+buf+Math.random()*(BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END-2*buf);}if(boss.patrolTargetX!==null){const angle=Math.atan2(boss.patrolTargetY-boss.y,boss.patrolTargetX-boss.x);boss.angle=angle;let dx=Math.cos(angle)*boss.speed, dy=Math.sin(angle)*boss.speed;let px=boss.x+dx, py=boss.y+dy;const others=bosses.filter(b=>b.id!==boss.id);let collided=checkCollision(boss.radius,px,py,boss.id,[...solidObjects,...others,...monsters,player,...undeadMinions]);if(!collided){boss.x=px;boss.y=py;}else{/* Sliding */}}} else if(boss.state==='attacking_hit'){boss.attackAnimationTimer+=deltaTime;if(boss.attackAnimationTimer>=ATTACK_DURATION/2&&boss.attackAnimationTimer<ATTACK_DURATION&&boss.attackTarget){const hitRangeCheckSq = boss.attackTarget.id === player.id ? boss.attackRange_hit**2 : (boss.radius + UNDEAD_RADIUS + 10)**2; if(distanceSq(boss.x,boss.y,boss.attackTarget.x,boss.attackTarget.y)<hitRangeCheckSq){boss.attackTarget.health=Math.max(0,boss.attackTarget.health-BOSS_HIT_DAMAGE);boss.attackTarget.flashUntil=now+FLASH_DURATION;console.log(`Boss hit ${boss.attackTarget.id}! HP:${boss.attackTarget.health.toFixed(0)}`);}boss.attackAnimationTimer=ATTACK_DURATION;}if(boss.attackAnimationTimer>=ATTACK_DURATION){boss.state='chasing';boss.currentAttack=null;}} else if(boss.state==='attacking_smash'){boss.attackAnimationTimer+=deltaTime;if(boss.attackAnimationTimer>=BOSS_SMASH_WINDUP&&!boss.smashLanded&&boss.attackTarget){boss.smashLanded=true;const smashRangeCheckSq = boss.attackTarget.id === player.id ? BOSS_SMASH_RANGE**2 : (BOSS_SMASH_RANGE + boss.radius + UNDEAD_RADIUS - player.radius)**2; if(distanceSq(boss.x,boss.y,boss.attackTarget.x,boss.attackTarget.y)<smashRangeCheckSq){boss.attackTarget.health=Math.max(0,boss.attackTarget.health-BOSS_SMASH_DAMAGE);boss.attackTarget.flashUntil=now+FLASH_DURATION;console.log(`Boss smash ${boss.attackTarget.id}! HP:${boss.attackTarget.health.toFixed(0)}`);}}if(boss.attackAnimationTimer>=BOSS_SMASH_WINDUP+BOSS_SMASH_EFFECT_DURATION){boss.state='chasing';boss.currentAttack=null;}} else if(boss.state==='attacking_spin'){boss.attackAnimationTimer+=deltaTime;if(now-boss.lastSpinDamageTime>BOSS_SPIN_DAMAGE_INTERVAL&&boss.attackTarget){const spinRangeCheckSq = boss.attackTarget.id === player.id ? boss.attackRange_spin**2 : (boss.radius + UNDEAD_RADIUS + 20)**2; if(distanceSq(boss.x,boss.y,boss.attackTarget.x,boss.attackTarget.y)<spinRangeCheckSq){boss.attackTarget.health=Math.max(0,boss.attackTarget.health-BOSS_SPIN_DAMAGE);boss.attackTarget.flashUntil=now+FLASH_DURATION;console.log(`Boss spin ${boss.attackTarget.id}! HP:${boss.attackTarget.health.toFixed(0)}`);}boss.lastSpinDamageTime=now;}if(boss.attackAnimationTimer>=BOSS_SPIN_DURATION){boss.state='chasing';boss.currentAttack=null;}} boss.x=Math.max(boss.radius,Math.min(WORLD_WIDTH-boss.radius,boss.x));boss.y=Math.max(boss.radius,Math.min(WORLD_HEIGHT-boss.radius,boss.y));}); }
function updateUndeadMinions(deltaTime) { if(!gameHasStarted||undeadMinions.length===0)return; const now=Date.now(); for(let i=undeadMinions.length-1;i>=0;i--){const minion=undeadMinions[i];if(minion.health<=0){console.log(`Undead ${minion.id} perished.`);undeadMinions.splice(i,1);continue;} let potentialTarget=null,potentialTargetType=null,minDistSq=minion.detectRangeSq; const enemies=[...monsters,...bosses]; for(const enemy of enemies){if(enemy.health<=0)continue; const dSq=distanceSq(minion.x,minion.y,enemy.x,enemy.y);if(dSq<minDistSq){if(!isLineObstructed(minion.x,minion.y,enemy.x,enemy.y,walls)){minDistSq=dSq;potentialTarget=enemy;potentialTargetType=monsters.some(m=>m.id===enemy.id)?'monster':'boss';}}} if(potentialTarget){minion.attackTarget=potentialTarget;minion.targetType=potentialTargetType;const distToTargetSq=minDistSq;if(distToTargetSq<=minion.attackRange**2)minion.state='attacking';else minion.state='chasing';minion.wanderTargetX=null;}else{if(minion.state==='chasing'||minion.state==='attacking')minion.state='wandering';minion.attackTarget=null;minion.targetType=null;} let dx=0,dy=0;const target=minion.attackTarget; if(minion.state==='chasing'&&target&&target.health>0){const angle=Math.atan2(target.y-minion.y,target.x-minion.x);dx=Math.cos(angle)*minion.speed;dy=Math.sin(angle)*minion.speed;}else if(minion.state==='attacking'&&target&&target.health>0){if(now-minion.lastAttackTime>=minion.attackCooldown){target.health-=minion.damage;target.flashUntil=now+FLASH_DURATION;minion.lastAttackTime=now;console.log(`Undead ${minion.id} attacks ${minion.targetType} ${target.id}. Target HP:${target.health.toFixed(0)}`);if(target.health<=0){minion.state='wandering';minion.attackTarget=null;minion.targetType=null;}}}else if(minion.state==='wandering'){if(minion.wanderTargetX===null||distanceSq(minion.x,minion.y,minion.wanderTargetX,minion.wanderTargetY)<20**2||now-minion.lastWanderChange>5000){const dist=50+Math.random()*100,angle=Math.random()*Math.PI*2;minion.wanderTargetX=minion.x+Math.cos(angle)*dist;minion.wanderTargetY=minion.y+Math.sin(angle)*dist;minion.lastWanderChange=now;minion.wanderTargetX=Math.max(minion.radius+10,Math.min(WORLD_WIDTH-minion.radius-10,minion.wanderTargetX));minion.wanderTargetY=Math.max(minion.radius+10,Math.min(WORLD_HEIGHT-minion.radius-10,minion.wanderTargetY));}if(minion.wanderTargetX!==null){const angle=Math.atan2(minion.wanderTargetY-minion.y,minion.wanderTargetX-minion.x);dx=Math.cos(angle)*minion.speed*0.5;dy=Math.sin(angle)*minion.speed*0.5;}} if(dx!==0||dy!==0){let px=minion.x+dx,py=minion.y+dy;const others=undeadMinions.filter(u=>u.id!==minion.id);let collided=checkCollision(minion.radius,px,py,minion.id,[...solidObjects,player,...monsters,...bosses,...others]);if(!collided){minion.x=px;minion.y=py;} minion.x=Math.max(minion.radius,Math.min(WORLD_WIDTH-minion.radius,minion.x));minion.y=Math.max(minion.radius,Math.min(WORLD_HEIGHT-minion.radius,minion.y));}} }
function updateProjectiles(deltaTime) { if (!gameHasStarted) return; for (let i=projectiles.length-1; i>=0; i--) { const proj=projectiles[i]; const speed=PROJECTILE_SPEED*(deltaTime/(1000/60)); const mx=proj.vx/PROJECTILE_SPEED*speed, my=proj.vy/PROJECTILE_SPEED*speed, moveDist=Math.sqrt(mx*mx+my*my); proj.x+=mx; proj.y+=my; proj.traveled+=moveDist; if (proj.traveled>proj.range || proj.x<0 || proj.x>WORLD_WIDTH || proj.y<0 || proj.y>WORLD_HEIGHT) { projectiles.splice(i,1); continue; } const solidHit=checkCollision(proj.radius,proj.x,proj.y,proj.ownerId,solidObjects); if(solidHit){if(solidHit.isWall){projectiles.splice(i,1);continue;} if(solidHit.isAttackable&&ITEM_DATA[solidHit.type]?.health){solidHit.health-=proj.damage;solidHit.flashUntil=Date.now()+FLASH_DURATION;if(solidHit.health<=0){console.log(`%cProj destroyed ${solidHit.type}!`,'color:gray;');let drops=[];if(solidHit.isPlaced)drops.push({type:solidHit.type,count:1}); drops.forEach(d=>addDroppedItem(solidHit.x,solidHit.y,d.type,d.count));resources=resources.filter(r=>r.id!==solidHit.id);solidObjects=solidObjects.filter(s=>s.id!==solidHit.id);}} projectiles.splice(i,1);continue;} for(let j=monsters.length-1;j>=0;j--){const mon=monsters[j];if(proj.ownerId!==mon.id){if(distanceSq(proj.x,proj.y,mon.x,mon.y)<(proj.radius+mon.radius)**2){mon.health-=proj.damage;mon.flashUntil=Date.now()+FLASH_DURATION;if(mon.health<=0){console.log(`%cDestroyed monster w/ proj!`,'color:orange;');addDroppedItem(mon.x,mon.y,'monster_goop',1+Math.floor(Math.random()*4));if(Math.random()<GOLD_COIN_DROP_CHANCE)addDroppedItem(mon.x,mon.y,'gold_coin',1);monsters.splice(j,1);gainXP(MONSTER_XP_REWARD);} projectiles.splice(i,1);break;}}} if(!projectiles[i])continue; for(let j=bosses.length-1;j>=0;j--){const boss=bosses[j];if(proj.ownerId!==boss.id){if(distanceSq(proj.x,proj.y,boss.x,boss.y)<(proj.radius+boss.radius)**2){boss.health-=proj.damage;boss.flashUntil=Date.now()+FLASH_DURATION;console.log(`Proj hit boss ${boss.id}, HP:${boss.health.toFixed(0)}`);if(boss.health<=0){console.log(`%cDestroyed boss w/ proj!`,'color:red;font-weight:bold;');addDroppedItem(boss.x,boss.y,'gold_coin',10+Math.floor(Math.random()*16));addDroppedItem(boss.x,boss.y,'iron_ore',15);addDroppedItem(boss.x,boss.y,'wooden_bow',1);gainXP(PLAINS_BOSS_XP_REWARD);const tier=BOSS_WALL_TIER_MAP[boss.type];if(tier!==undefined){/*...*/walls=walls.filter(w=>w.tier!==tier);solidObjects=solidObjects.filter(s=>!(s.isWall&&s.tier===tier));/*...*/} bosses.splice(j,1);solidObjects=solidObjects.filter(s=>s.id!==boss.id);} projectiles.splice(i,1);break;}}} if(!projectiles[i])continue; for(let j=undeadMinions.length-1;j>=0;j--){const minion=undeadMinions[j];if(proj.ownerId!==player.id){if(distanceSq(proj.x,proj.y,minion.x,minion.y)<(proj.radius+minion.radius)**2){minion.health-=proj.damage;minion.flashUntil=Date.now()+FLASH_DURATION;console.log(`Proj hit undead ${minion.id}, HP:${minion.health.toFixed(0)}`);if(minion.health<=0){undeadMinions.splice(j,1);} projectiles.splice(i,1);break;}}} } }
function updateWorld(deltaTime) { if(isGameOver||isCraftingMenuOpen||!gameHasStarted)return; gameTime+=deltaTime; const cycleTime=gameTime%DAY_LENGTH, cyclePercent=cycleTime/DAY_LENGTH; const newDay=Math.floor(gameTime/DAY_LENGTH)+1; if(newDay>dayCount){dayCount=newDay;console.log(`Day ${dayCount}`);} const wasNight=isNight; let targetOp=0,phase="Day",timeLeft=0,transitionDur=TRANSITION_DURATION_PERCENT*DAY_LENGTH,nextPhaseStart=SUNSET_START_PERCENT; if(cyclePercent>=0&&cyclePercent<SUNSET_START_PERCENT){isNight=false;phase="Day";targetOp=0;nextPhaseStart=SUNSET_START_PERCENT;} else if(cyclePercent>=SUNSET_START_PERCENT&&cyclePercent<NIGHT_START_PERCENT){isNight=true;phase="Sunset";const tp=(cyclePercent-SUNSET_START_PERCENT)/TRANSITION_DURATION_PERCENT;targetOp=tp*MAX_NIGHT_OPACITY;nextPhaseStart=NIGHT_START_PERCENT;} else if(cyclePercent>=NIGHT_START_PERCENT&&cyclePercent<SUNRISE_START_PERCENT){isNight=true;phase="Night";targetOp=MAX_NIGHT_OPACITY;nextPhaseStart=SUNRISE_START_PERCENT;} else {isNight=false;phase="Sunrise";const tp=(cyclePercent-SUNRISE_START_PERCENT)/TRANSITION_DURATION_PERCENT;targetOp=(1-tp)*MAX_NIGHT_OPACITY;nextPhaseStart=1.0;} timeLeft=(nextPhaseStart*DAY_LENGTH)-cycleTime;if(nextPhaseStart===1.0)timeLeft=DAY_LENGTH-cycleTime;else if(timeLeft<-10)timeLeft+=DAY_LENGTH; if(Math.abs(currentNightOpacity-targetOp)>0.005){const speed=deltaTime/(transitionDur/2);if(currentNightOpacity<targetOp)currentNightOpacity=Math.min(currentNightOpacity+speed,targetOp);else if(currentNightOpacity>targetOp)currentNightOpacity=Math.max(currentNightOpacity-speed,targetOp);}else{currentNightOpacity=targetOp;} currentNightOpacity=Math.max(0,Math.min(MAX_NIGHT_OPACITY,currentNightOpacity)); if(timeUIDiv)timeUIDiv.innerHTML=`<span>Phase: ${phase}</span><br><span>~ Left: ${formatTime(timeLeft)}</span>`; if(isNight&&!wasNight){console.log("Night begins! Spawning monsters...");const count=monsters.length,space=MAX_MONSTER_COUNT-count,toSpawn=Math.min(NIGHTLY_MONSTER_SPAWN_COUNT,space);if(toSpawn>0){const h=50;let spawned=0,attempts=0,MAX_ATT=toSpawn*5;while(spawned<toSpawn&&attempts<MAX_ATT){attempts++;const x=Math.random()*WORLD_WIDTH,y=Math.random()*WORLD_HEIGHT;if((x>JUNGLE_LAKE.x&&x<JUNGLE_LAKE.x+JUNGLE_LAKE.width&&y>JUNGLE_LAKE.y&&y<JUNGLE_LAKE.y+JUNGLE_LAKE.height)||lavaPools.some(p=>x>p.x&&x<p.x+p.width&&y>p.y&&y<p.y+p.height)||(x<ISLAND_PADDING/2||x>WORLD_WIDTH-ISLAND_PADDING/2||y<ISLAND_PADDING/2||y>WORLD_HEIGHT-ISLAND_PADDING/2)||distanceSq(x,y,player.x,player.y)<(MONSTER_DETECT_RANGE*1.5)**2||checkCollision(10,x,y,null,solidObjects))continue;const mon={id:`mon_${Date.now()}_${Math.random()}`,x:x,y:y,radius:10+Math.random()*5,type:'slime',color:'#DC143C',maxHealth:h*2,health:h*2,flashUntil:0,state:'idle',attackCooldown:MONSTER_ATTACK_COOLDOWN,lastAttackTime:0,target:null,isAttackable:true,isSolid:false};monsters.push(mon);spawned++;}if(attempts>=MAX_ATT&&spawned<toSpawn)console.warn("Max attempts for nightly spawn.");console.log(`Spawned ${spawned} new slimes. Total:${monsters.length}`);}} }
function updateUI() { healthValueSpan.textContent=Math.floor(player.health); maxHealthValueSpan.textContent=Math.floor(player.maxHealth); hungerValueSpan.textContent=Math.floor(player.hunger); dayValueSpan.textContent=dayCount; levelValueSpan.textContent=player.level; xpValueSpan.textContent=`${player.currentXP}/${player.xpToNextLevel}`; let debugSpeedPenalty=(!isNight&&player.daySpeedPenalty<1.0)?` DaySpeed:x${player.daySpeedPenalty.toFixed(2)}`:''; debugDiv.textContent=`World:(${Math.round(player.x)},${Math.round(player.y)})|Mouse:(${Math.round(worldMouseX)},${Math.round(worldMouseY)})|Res:${resources.length}|Mon:${monsters.length}|Undead:${undeadMinions.length}|Items:${droppedItems.length}|Proj:${projectiles.length}|SpeedM:${player.speedMultiplier.toFixed(2)}${debugSpeedPenalty}`; }
function update(deltaTime) { if (isGameOver || !gameHasStarted) return; if (!deltaTime || deltaTime > 500) deltaTime = 16; updatePlayer(deltaTime); updateMonsters(deltaTime); updateBosses(deltaTime); updateUndeadMinions(deltaTime); updateProjectiles(deltaTime); updateWorld(deltaTime); clampCamera(); updateUI(); }

// --- Undead Minion Functions ---
function spawnUndeadMinion(x, y) { const baseSlimeHealth=50*2; const undeadHealth=baseSlimeHealth*UNDEAD_BASE_HEALTH_MULT; const minion={id:`undead_${Date.now()}_${Math.random()}`,ownerId:player.id,x:x+(Math.random()-0.5)*10,y:y+(Math.random()-0.5)*10,radius:UNDEAD_RADIUS,type:'undead_minion',color:UNDEAD_COLOR,maxHealth:undeadHealth,health:undeadHealth,flashUntil:0,speed:UNDEAD_SPEED,state:'wandering',attackTarget:null,targetType:null,wanderTargetX:null,wanderTargetY:null,lastWanderChange:0,attackCooldown:UNDEAD_ATTACK_COOLDOWN,lastAttackTime:0,damage:UNDEAD_DAMAGE,detectRangeSq:UNDEAD_DETECT_RANGE_SQ,attackRange:UNDEAD_ATTACK_RANGE,isSolid:false,isAttackable:true}; undeadMinions.push(minion); console.log(`Spawned undead ${minion.id} at (${Math.round(x)},${Math.round(y)})`); }
// updateUndeadMinions is defined above with other update functions
function drawUndeadMinions() { if(!gameHasStarted||undeadMinions.length===0)return; const now=Date.now(); ctx.save(); undeadMinions.forEach(minion=>{ctx.save();ctx.translate(minion.x,minion.y); if(minion.health<minion.maxHealth&&minion.health>0){const bw=minion.radius*1.8,bh=3,barY=-minion.radius-bh-2; ctx.fillStyle='#444';ctx.fillRect(-bw/2,barY,bw,bh); ctx.fillStyle='#BBB';ctx.fillRect(-bw/2,barY,bw*(minion.health/minion.maxHealth),bh);} ctx.fillStyle=(minion.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFF':minion.color; ctx.beginPath();ctx.arc(0,0,minion.radius,0,Math.PI*2);ctx.fill(); ctx.strokeStyle="#555";ctx.lineWidth=1;ctx.stroke(); ctx.restore();}); ctx.restore(); }

// --- Draw Functions ---
function drawWorldBackground() { ctx.save(); ctx.fillStyle=BIOME_DATA.desert.color;ctx.fillRect(0,BIOME_BOUNDS.DESERT_Y_START,WORLD_WIDTH,WORLD_HEIGHT-BIOME_BOUNDS.DESERT_Y_START); ctx.fillStyle=BIOME_DATA.frostlands.color;ctx.fillRect(0,0,WORLD_WIDTH,BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=BIOME_DATA.forest.color;ctx.fillRect(0,BIOME_BOUNDS.FROSTLANDS_Y_END,BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=BIOME_DATA.jungle.color;ctx.fillRect(BIOME_BOUNDS.JUNGLE_X_START,BIOME_BOUNDS.FROSTLANDS_Y_END,WORLD_WIDTH-BIOME_BOUNDS.JUNGLE_X_START,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=BIOME_DATA.rocky.color;ctx.fillRect(0,0,BIOME_BOUNDS.ROCKY_X_END,BIOME_BOUNDS.ROCKY_Y_END); ctx.fillStyle=BIOME_DATA.swamp.color;ctx.fillRect(BIOME_BOUNDS.SWAMP_X_START,0,WORLD_WIDTH-BIOME_BOUNDS.SWAMP_X_START,BIOME_BOUNDS.SWAMP_Y_END); ctx.fillStyle=BIOME_DATA.volcano.color;ctx.fillRect(0,BIOME_BOUNDS.VOLCANO_Y_START,BIOME_BOUNDS.VOLCANO_X_END,WORLD_HEIGHT-BIOME_BOUNDS.VOLCANO_Y_START); ctx.fillStyle=BIOME_DATA.badlands.color;ctx.fillRect(BIOME_BOUNDS.BADLANDS_X_START,BIOME_BOUNDS.BADLANDS_Y_START,WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START,WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START); ctx.fillStyle=BIOME_DATA.plains.color;ctx.fillRect(BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.FROSTLANDS_Y_END,BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END,BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle=JUNGLE_LAKE.color;ctx.fillRect(JUNGLE_LAKE.x,JUNGLE_LAKE.y,JUNGLE_LAKE.width,JUNGLE_LAKE.height); lavaPools.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x,p.y,p.width,p.height);}); ctx.restore(); }
function drawBiomeWalls() { ctx.save();ctx.fillStyle=WALL_COLOR;ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=1;walls.forEach(w=>{ctx.fillRect(w.x,w.y,w.width,w.height);ctx.strokeRect(w.x,w.y,w.width,w.height);});ctx.restore(); }
function drawResources() { const now=Date.now();resources.forEach(res=>{ctx.save();ctx.translate(res.x,res.y);if(res.isAttackable&&res.health<res.maxHealth&&res.health>0){const bw=res.radius*1.5,bh=5,by=-res.radius-bh-3;ctx.fillStyle='#666';ctx.fillRect(-bw/2,by,bw,bh);let hc='#DDD';if(res.type==='tree'||res.type==='bone_tree')hc='#228B22';else if(res.type==='rock')hc='#A9A9A9';else if(res.isPlaced)hc='#4682B4';ctx.fillStyle=hc;ctx.fillRect(-bw/2,by,bw*(res.health/res.maxHealth),bh);}const baseColor=res.color||ITEM_DATA[res.type]?.color||'magenta';ctx.fillStyle=(res.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFF':baseColor;if(res.type==='workbench'||res.type==='stone_block'||res.type==='wood_plank'||res.type==='icky_bed'||res.type==='item_upgrader_t1'){ctx.fillRect(-res.radius,-res.radius,res.radius*2,res.radius*2);ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=1;ctx.strokeRect(-res.radius,-res.radius,res.radius*2,res.radius*2);}else if(res.type==='torch'){const sh=res.radius*3,sw=res.radius*0.6,fh=res.radius*1.5;ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-sw/2,-sh/2+fh*0.4,sw,sh);ctx.fillStyle=baseColor;ctx.beginPath();ctx.ellipse(0,-sh/2,sw*1.2,fh,0,0,Math.PI*2);ctx.fill();}else if(res.type==='cactus'){const cw=res.radius*0.6,ch=res.radius*2;ctx.fillStyle=baseColor;ctx.fillRect(-cw/2,-ch/2,cw,ch);ctx.fillRect(-cw*1.5,-ch*0.1,cw*2.5,cw*0.8);ctx.strokeStyle='darkgreen';ctx.lineWidth=1;ctx.strokeRect(-cw/2,-ch/2,cw,ch);}else if(res.type==='tree'||res.type==='bone_tree'){ctx.beginPath();ctx.arc(0,0,res.radius,0,Math.PI*2);ctx.fillStyle=res.variant==='bone'?'#DDD':baseColor;ctx.fill();ctx.fillStyle=res.variant==='bone'?'#999':'#A0522D';const tw=res.radius*0.4,th=res.radius*0.6;ctx.fillRect(-tw/2,0,tw,th);if(res.variant==='snowy'){ctx.fillStyle='rgba(255,255,255,0.8)';ctx.beginPath();ctx.arc(0,-res.radius*0.3,res.radius*0.9,0,Math.PI*2);ctx.fill();}}else{ctx.beginPath();ctx.arc(0,0,res.radius,0,Math.PI*2);ctx.fill();if(res.type==='rock'){ctx.strokeStyle='rgba(0,0,0,0.3)';ctx.lineWidth=1;ctx.stroke();}}ctx.restore();}); }
function drawMonsters() { const now=Date.now();monsters.forEach(mon=>{ctx.save();ctx.translate(mon.x,mon.y);if(mon.health<mon.maxHealth&&mon.health>0){const bw=mon.radius*1.5,bh=4,by=-mon.radius-bh-2;ctx.fillStyle='#550000';ctx.fillRect(-bw/2,by,bw,bh);ctx.fillStyle='#FF0000';ctx.fillRect(-bw/2,by,bw*(mon.health/mon.maxHealth),bh);}ctx.fillStyle=(mon.flashUntil>now&&Math.floor(now/50)%2===0)?'#FFF':mon.color;ctx.beginPath();ctx.arc(0,0,mon.radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle="black";ctx.lineWidth=1;ctx.stroke();ctx.restore();}); }
function drawBosses() { bosses.forEach(boss=>{if(boss.health<=0)return;const now=Date.now();ctx.save();ctx.translate(boss.x,boss.y);if(boss.health<boss.maxHealth){const bw=boss.radius*1.8,bh=8,by=-boss.radius-bh-5;ctx.fillStyle='#440000';ctx.fillRect(-bw/2,by,bw,bh);ctx.fillStyle='#FF3333';ctx.fillRect(-bw/2,by,bw*(boss.health/boss.maxHealth),bh);ctx.strokeStyle='black';ctx.lineWidth=1;ctx.strokeRect(-bw/2,by,bw,bh);}ctx.fillStyle='#776B5D';ctx.beginPath();ctx.arc(0,0,boss.radius,0,Math.PI*2);ctx.fill();ctx.fillStyle='#8B4513';ctx.beginPath();ctx.ellipse(-boss.radius*0.4,-boss.radius*0.3,boss.radius*0.3,boss.radius*0.5,Math.PI/4,0,Math.PI*2);ctx.fill();ctx.fillStyle='#696969';ctx.beginPath();ctx.ellipse(boss.radius*0.3,boss.radius*0.4,boss.radius*0.4,boss.radius*0.2,-Math.PI/6,0,Math.PI*2);ctx.fill();ctx.strokeStyle='#3A3127';ctx.lineWidth=3;ctx.stroke();const armR=boss.radius*0.3,armD=boss.radius+armR*0.8;let leftA=boss.angle-Math.PI/1.5,rightA=boss.angle+Math.PI/1.5;if(boss.state==='attacking_hit'){const p=boss.attackAnimationTimer/ATTACK_DURATION;rightA=boss.angle+Math.PI/1.5+Math.sin(p*Math.PI)*1.5;}else if(boss.state==='attacking_smash'){const p=Math.min(1,boss.attackAnimationTimer/BOSS_SMASH_WINDUP);leftA=boss.angle-Math.PI/1.5-p*Math.PI*0.8;rightA=boss.angle+Math.PI/1.5+p*Math.PI*0.8;}else if(boss.state==='attacking_spin'){const p=boss.attackAnimationTimer/BOSS_SPIN_DURATION,spinOff=p*Math.PI*4;leftA=boss.angle+spinOff-Math.PI/1.5;rightA=boss.angle+spinOff+Math.PI/1.5;}ctx.fillStyle='#8B4513';const leftX=Math.cos(leftA)*armD,leftY=Math.sin(leftA)*armD;ctx.beginPath();ctx.arc(leftX,leftY,armR,0,Math.PI*2);ctx.fill();ctx.stroke();ctx.fillStyle='#696969';const rightX=Math.cos(rightA)*armD,rightY=Math.sin(rightA)*armD;ctx.beginPath();ctx.arc(rightX,rightY,armR*1.1,0,Math.PI*2);ctx.fill();ctx.stroke();if(boss.state==='attacking_smash'&&boss.attackAnimationTimer>=BOSS_SMASH_WINDUP){ctx.save();const ep=(boss.attackAnimationTimer-BOSS_SMASH_WINDUP)/BOSS_SMASH_EFFECT_DURATION;ctx.globalAlpha=Math.max(0,1.0-ep);ctx.strokeStyle='red';ctx.lineWidth=5+(1-ep)*5;ctx.beginPath();ctx.arc(0,0,BOSS_SMASH_RANGE*ep,0,Math.PI*2);ctx.stroke();ctx.restore();}if(boss.state==='attacking_spin'){ctx.save();ctx.globalAlpha=0.5;ctx.strokeStyle='white';ctx.lineWidth=2+Math.sin(now/50)*2;ctx.beginPath();ctx.arc(0,0,BOSS_SPIN_RANGE-5,0,Math.PI*2);ctx.stroke();ctx.beginPath();ctx.arc(0,0,BOSS_SPIN_RANGE-15,0,Math.PI*2);ctx.stroke();ctx.restore();}ctx.restore();}); }
function drawDroppedItems() { // Corrected version from previous response
    ctx.save();
    droppedItems.forEach(item => {
        const itemData = ITEM_DATA[item.type]; if (!itemData) return;
        ctx.save(); ctx.translate(item.x, item.y);
        ctx.fillStyle = itemData.color || '#FFFFFF'; ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 1;
        const size = item.radius * 1.8;
        switch (itemData.shape) {
            case 'line': ctx.beginPath(); ctx.moveTo(-size * 0.7, 0); ctx.lineTo(size * 0.7, 0); ctx.lineWidth = 3; ctx.stroke(); break;
            case 'rect': ctx.fillRect(-size / 2, -size / 2, size, size); ctx.strokeRect(-size / 2, -size / 2, size, size); break;
            case 'torch': { const stickH = size * 1.2; const stickW = size * 0.2; const flameH = size * 0.6; ctx.fillStyle = ITEM_DATA['stick']?.color || '#B8860B'; ctx.fillRect(-stickW / 2, -stickH / 2 + flameH * 0.4, stickW, stickH); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.ellipse(0, -stickH / 2, stickW * 1.2, flameH, 0, 0, Math.PI * 2); ctx.fill(); break; }
            case 'sword': { const swordH = size * 1.5; const swordW = size * 0.2; const guardW = size * 0.5; ctx.fillStyle = '#444'; ctx.fillRect(-swordW * 1.2, swordH * 0.2, swordW * 2.4, swordH * 0.2); ctx.fillStyle = '#888'; ctx.fillRect(-guardW / 2, swordH * 0.1, guardW, swordW * 2); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.moveTo(0, -swordH * 0.4); ctx.lineTo(-swordW, swordH * 0.1); ctx.lineTo(swordW, swordH * 0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); break; }
            case 'axe': case 'pickaxe': { const handleH = size * 1.4; const handleW = size * 0.2; const headW = size * 0.7; const headH = size*0.5; ctx.fillStyle = ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-handleW/2, -handleH/2+headH/2, handleW, handleH); ctx.strokeRect(-handleW/2, -handleH/2+headH/2, handleW, handleH); ctx.fillStyle = itemData.color; ctx.fillRect(-headW/2, -handleH/2, headW, headH); ctx.strokeRect(-headW/2, -handleH/2, headW, headH); break; }
            case 'bow': ctx.beginPath(); ctx.moveTo(0, -size * 0.6); ctx.quadraticCurveTo(-size * 0.7, 0, 0, size * 0.6); ctx.quadraticCurveTo(size * 0.7, 0, 0, -size * 0.6); ctx.moveTo(-size*0.1, -size*0.5); ctx.lineTo(-size*0.1, size*0.5); ctx.lineWidth = 1; ctx.strokeStyle = '#eee'; ctx.stroke(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke(); ctx.fill(); break;
            case 'cactus': const cW = size * 0.4; const cH = size * 1.3; ctx.fillRect(-cW/2,-cH/2, cW, cH); ctx.fillRect(-cW*1.2, -cH*0.1, cW*2.4, cW*0.6); ctx.strokeStyle='darkgreen'; ctx.strokeRect(-cW/2,-cH/2, cW, cH); break;
            case 'circle': default: ctx.beginPath(); ctx.arc(0, 0, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); break;
        }
        ctx.restore();
    });
    ctx.restore();
}
function drawPlayer() { ctx.save();ctx.translate(player.x,player.y);ctx.fillStyle='#87CEEB';ctx.beginPath();ctx.arc(0,0,player.radius,0,Math.PI*2);ctx.fill();ctx.strokeStyle='#4682B4';ctx.lineWidth=2;ctx.stroke();let handBase=player.angle,handDist=HAND_DISTANCE,currentHandA=handBase,rightHandRelA=handBase+Math.PI/4;if(player.isAttacking){const prog=(Date.now()-player.attackTimer)/ATTACK_DURATION;if(player.equippedItemType&&ITEM_DATA[player.equippedItemType]?.toolType!=='bow'){const swing=Math.sin(prog*Math.PI)*ATTACK_SWING_ARC;currentHandA=handBase+swing-ATTACK_SWING_ARC/2;rightHandRelA=currentHandA+Math.PI/4;}else if(player.equippedItemType&&ITEM_DATA[player.equippedItemType]?.toolType==='bow'){const draw=Math.sin(prog*Math.PI)*5;handDist-=draw;currentHandA=handBase;rightHandRelA=handBase+Math.PI/4;}}else if(player.isInteracting){const prog=(Date.now()-player.interactTimer)/INTERACT_DURATION;const pulse=Math.sin(prog*Math.PI)*5;handDist+=pulse;currentHandA=handBase;rightHandRelA=currentHandA+Math.PI/4;}const handOff=Math.PI/4;const lx=Math.cos(currentHandA-handOff)*handDist,ly=Math.sin(currentHandA-handOff)*handDist,rx=Math.cos(currentHandA+handOff)*handDist,ry=Math.sin(currentHandA+handOff)*handDist;ctx.fillStyle='#FFDAB9';ctx.beginPath();ctx.arc(lx,ly,LIMB_RADIUS,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(rx,ry,LIMB_RADIUS,0,Math.PI*2);ctx.fill();if(player.equippedItemType){const d=ITEM_DATA[player.equippedItemType];if(d){ctx.save();const size=18,itemDist=handDist+LIMB_RADIUS-size*0.1;const ix=Math.cos(rightHandRelA)*itemDist,iy=Math.sin(rightHandRelA)*itemDist;ctx.translate(ix,iy);ctx.rotate(player.angle+Math.PI/4);const scale=size/30;ctx.scale(scale,scale);const shapeSize=18;ctx.fillStyle=d.color;ctx.strokeStyle='black';ctx.lineWidth=1/scale;switch(d.shape){case 'line':ctx.beginPath();ctx.moveTo(0,-shapeSize*0.6);ctx.lineTo(0,shapeSize*0.6);ctx.lineWidth=3;ctx.stroke();break;case 'rect':ctx.fillRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);ctx.strokeRect(-shapeSize*0.4,-shapeSize*0.4,shapeSize*0.8,shapeSize*0.8);break;case 'torch':const sH=shapeSize*1.0,sW=shapeSize*0.2,fH=shapeSize*0.5;ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-sW/2,sH*0.1,sW,sH*0.9);ctx.fillStyle=d.color;ctx.beginPath();ctx.ellipse(0,-sH*0.25,sW*1.5,fH,0,0,Math.PI*2);ctx.fill();break;case 'sword':const swH=shapeSize*1.3,swW=shapeSize*0.15,gW=shapeSize*0.4;ctx.fillStyle='#444';ctx.fillRect(-swW*1.2,swH*0.2,swW*2.4,swH*0.2);ctx.fillStyle='#888';ctx.fillRect(-gW/2,swH*0.1,gW,swW*2);ctx.fillStyle=d.color;ctx.beginPath();ctx.moveTo(0,-swH*0.4);ctx.lineTo(-swW,swH*0.1);ctx.lineTo(swW,swH*0.1);ctx.closePath();ctx.fill();ctx.stroke();break;case 'axe':case 'pickaxe':const hH=shapeSize*1.2,hW=shapeSize*0.15,hdW=shapeSize*0.6,hdH=shapeSize*0.4;ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B';ctx.fillRect(-hW/2,-hH/2+hdH/2,hW,hH);ctx.strokeRect(-hW/2,-hH/2+hdH/2,hW,hH);ctx.fillStyle=d.color;ctx.fillRect(-hdW/2,-hH/2,hdW,hdH);ctx.strokeRect(-hdW/2,-hH/2,hdW,hdH);break;case 'bow':ctx.rotate(-Math.PI/4);ctx.beginPath();ctx.moveTo(0,-shapeSize*0.7);ctx.quadraticCurveTo(-shapeSize*0.8,0,0,shapeSize*0.7);ctx.quadraticCurveTo(shapeSize*0.8,0,0,-shapeSize*0.7);ctx.moveTo(-shapeSize*0.1,-shapeSize*0.6);ctx.lineTo(-shapeSize*0.1,shapeSize*0.6);ctx.lineWidth=1.5;ctx.strokeStyle='#eee';ctx.stroke();ctx.lineWidth=2.5;ctx.strokeStyle='black';ctx.stroke();ctx.fill();break;case 'circle':default:ctx.beginPath();ctx.arc(0,0,shapeSize*0.4,0,Math.PI*2);ctx.fill();ctx.stroke();break;}ctx.restore();}}ctx.restore(); }
function drawProjectiles() { ctx.save();projectiles.forEach(p=>{ctx.fillStyle=p.color||'#FFF';ctx.strokeStyle=p.color||'#FFF';ctx.save();ctx.translate(p.x,p.y);ctx.rotate(Math.atan2(p.vy,p.vx));ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-p.radius*2.5,0);ctx.lineTo(p.radius*1.5,0);ctx.lineTo(p.radius*0.8,-p.radius*0.6);ctx.moveTo(p.radius*1.5,0);ctx.lineTo(p.radius*0.8,p.radius*0.6);ctx.stroke();ctx.restore();});ctx.restore(); }
function worldToMinimap(wx, wy, mx, my, mw, mh) { const sx=mw/WORLD_WIDTH, sy=mh/WORLD_HEIGHT; return {x:mx+wx*sx, y:my+wy*sy}; }
function drawMinimap(ctx) { if(!isMinimapVisible)return; ctx.save();const mapX=canvas.width-MINIMAP_WIDTH-MINIMAP_PADDING,mapY=canvas.height-MINIMAP_HEIGHT-MINIMAP_PADDING;ctx.globalAlpha=MINIMAP_ALPHA;ctx.fillStyle='#555';ctx.fillRect(mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.globalAlpha=1.0;ctx.strokeStyle='#FFF';ctx.lineWidth=1;ctx.strokeRect(mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.save();ctx.rect(mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.clip();for(const biomeName in BIOME_DATA){const biome=BIOME_DATA[biomeName];ctx.fillStyle=biome.color;let bx,by,bw,bh;switch(biomeName){case 'plains':bx=BIOME_BOUNDS.FOREST_X_END;by=BIOME_BOUNDS.FROSTLANDS_Y_END;bw=BIOME_BOUNDS.JUNGLE_X_START-BIOME_BOUNDS.FOREST_X_END;bh=BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'forest':bx=0;by=BIOME_BOUNDS.FROSTLANDS_Y_END;bw=BIOME_BOUNDS.FOREST_X_END;bh=BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'jungle':bx=BIOME_BOUNDS.JUNGLE_X_START;by=BIOME_BOUNDS.FROSTLANDS_Y_END;bw=WORLD_WIDTH-BIOME_BOUNDS.JUNGLE_X_START;bh=BIOME_BOUNDS.DESERT_Y_START-BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'frostlands':bx=0;by=0;bw=WORLD_WIDTH;bh=BIOME_BOUNDS.FROSTLANDS_Y_END;break;case 'desert':bx=0;by=BIOME_BOUNDS.DESERT_Y_START;bw=WORLD_WIDTH;bh=WORLD_HEIGHT-BIOME_BOUNDS.DESERT_Y_START;break;case 'rocky':bx=0;by=0;bw=BIOME_BOUNDS.ROCKY_X_END;bh=BIOME_BOUNDS.ROCKY_Y_END;break;case 'swamp':bx=BIOME_BOUNDS.SWAMP_X_START;by=0;bw=WORLD_WIDTH-BIOME_BOUNDS.SWAMP_X_START;bh=BIOME_BOUNDS.SWAMP_Y_END;break;case 'volcano':bx=0;by=BIOME_BOUNDS.VOLCANO_Y_START;bw=BIOME_BOUNDS.VOLCANO_X_END;bh=WORLD_HEIGHT-BIOME_BOUNDS.VOLCANO_Y_START;break;case 'badlands':bx=BIOME_BOUNDS.BADLANDS_X_START;by=BIOME_BOUNDS.BADLANDS_Y_START;bw=WORLD_WIDTH-BIOME_BOUNDS.BADLANDS_X_START;bh=WORLD_HEIGHT-BIOME_BOUNDS.BADLANDS_Y_START;break;default:continue;}const start=worldToMinimap(bx,by,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);const end=worldToMinimap(bx+bw,by+bh,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillRect(start.x,start.y,end.x-start.x,end.y-start.y);}ctx.restore();const pPos=worldToMinimap(player.x,player.y,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillStyle=MINIMAP_PLAYER_COLOR;ctx.beginPath();ctx.arc(pPos.x,pPos.y,MINIMAP_PLAYER_SIZE,0,Math.PI*2);ctx.fill();if(bosses.length>0){const bPos=worldToMinimap(bosses[0].x,bosses[0].y,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillStyle=MINIMAP_BOSS_COLOR;ctx.fillRect(bPos.x-2,bPos.y-2,5,5);}const rPos=worldToMinimap(player.respawnX,player.respawnY,mapX,mapY,MINIMAP_WIDTH,MINIMAP_HEIGHT);ctx.fillStyle=MINIMAP_RESPAWN_COLOR;ctx.beginPath();ctx.arc(rPos.x,rPos.y,MINIMAP_PLAYER_SIZE-1,0,Math.PI*2);ctx.fill();ctx.restore(); }
function draw() { if(!gameHasStarted){ctx.clearRect(0,0,canvas.width,canvas.height);return;} ctx.clearRect(0,0,canvas.width,canvas.height);ctx.save();ctx.translate(canvas.width/2-cameraX,canvas.height/2-cameraY); drawWorldBackground();drawBiomeWalls();drawResources();drawMonsters();drawBosses();drawUndeadMinions();drawDroppedItems();drawProjectiles();drawPlayer(); if(currentNightOpacity>0.01){ctx.save();ctx.fillStyle='#00001a';ctx.globalAlpha=currentNightOpacity;ctx.fillRect(cameraX-canvas.width/2,cameraY-canvas.height/2,canvas.width,canvas.height);ctx.globalAlpha=1.0;ctx.globalCompositeOperation='lighter';resources.forEach(res=>{if(res.isPlaced&&res.lightRadius>0&&res.type==='torch'){const g=ctx.createRadialGradient(res.x,res.y,0,res.x,res.y,res.lightRadius),b=0.6;g.addColorStop(0,`rgba(255,190,120,${b})`);g.addColorStop(0.6,`rgba(200,100,50,${b*0.5})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(res.x,res.y,res.lightRadius,0,Math.PI*2);ctx.fill();}});lavaPools.forEach(p=>{if(p.lightRadius>0){const cX=p.x+p.width/2,cY=p.y+p.height/2,b=p.lightOpacity||0.8,g=ctx.createRadialGradient(cX,cY,0,cX,cY,p.lightRadius);g.addColorStop(0,`rgba(255,100,0,${b*0.9})`);g.addColorStop(0.5,`rgba(255,60,0,${b*0.6})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(cX,cY,p.lightRadius,0,Math.PI*2);ctx.fill();}});if(player.equippedItemType==='torch'){const d=ITEM_DATA['torch'];if(d&&d.lightRadius>0){const r=d.lightRadius,g=ctx.createRadialGradient(player.x,player.y,0,player.x,player.y,r),b=0.65;g.addColorStop(0,`rgba(255,190,120,${b})`);g.addColorStop(0.6,`rgba(200,100,50,${b*0.5})`);g.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(player.x,player.y,r,0,Math.PI*2);ctx.fill();}}ctx.restore();} ctx.restore();drawMinimap(ctx); }

// --- Game Loop ---
let lastTime = 0;
function gameLoop(timestamp) { const deltaTime=timestamp-lastTime; lastTime=timestamp; if (!isGameOver && gameHasStarted) { update(deltaTime || 0); } draw(); requestAnimationFrame(gameLoop); }

// --- Apply Class Stats Function ---
function applyClassStats(selectedClass) { const stats=CLASS_DATA[selectedClass]; if(!stats){console.error(`Invalid class: ${selectedClass}. Defaults.`);player.maxHealth=PLAYER_MAX_HEALTH*1.0;player.speedMultiplier=1.0;player.swordMultiplierBoost=1.0;player.bowMultiplierBoost=1.0;player.lifesteal=0;player.daySpeedPenalty=1.0;player.necromancyChance=0;}else{console.log(`Applying stats: ${selectedClass}`);player.speedMultiplier=stats.speedMult;player.swordMultiplierBoost=stats.swordBoost;player.bowMultiplierBoost=stats.bowBoost;player.maxHealth=PLAYER_MAX_HEALTH*stats.healthMult;player.lifesteal=stats.lifesteal;player.daySpeedPenalty=stats.daySpeedPenalty;player.necromancyChance=stats.necromancyChance;console.log(` > HP:${Math.floor(player.maxHealth)} Speed:${player.speedMultiplier} Sword:${player.swordMultiplierBoost} Bow:${player.bowMultiplierBoost} Lifesteal:${player.lifesteal} DayPenalty:${player.daySpeedPenalty} Necro%:${player.necromancyChance}`);} player.health=player.maxHealth; }

// --- Game Initialization Function ---
function initializeGame() { console.log("--- Initializing Game World ---"); spawnInitialResources(); createWalls(); spawnInitialMonsters(); spawnBosses(); player.hotbarSlots[0]={type:'wood_sword',count:1}; player.hotbarSlots[1]={type:'wood_pickaxe',count:1}; player.xpToNextLevel=calculateXPForNextLevel(player.level); selectHotbar(0); updateMainHotbarVisuals(); updateEquippedItem(); clampCamera(); updateUI(); gameHasStarted=true; console.log("--- Game Ready! ---"); }

// --- Event Listeners for Class Selection ---
classSelect.addEventListener('change', ()=>{startGameButton.disabled=!(classSelect.value&&CLASS_DATA[classSelect.value]);});
startGameButton.addEventListener('click', ()=>{const selectedClass=classSelect.value; if(!selectedClass||!CLASS_DATA[selectedClass]){alert("Select class!");return;} applyClassStats(selectedClass); classSelectionOverlay.style.display='none'; initializeGame();});

// --- Start Game (Wait for Class Selection) ---
player.xpToNextLevel = calculateXPForNextLevel(player.level); // Calc initial XP
requestAnimationFrame(gameLoop); // Start loop, waits for gameHasStarted flag
console.log("--- game.js loaded. Waiting for class selection... ---");