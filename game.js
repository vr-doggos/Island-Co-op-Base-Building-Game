console.log("--- game.js started ---");

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const healthValueSpan = document.getElementById('healthValue');
const hungerValueSpan = document.getElementById('hungerValue');
const dayValueSpan = document.getElementById('dayValue');
const debugDiv = document.getElementById('debug');
const mainHotbarSlots = document.querySelectorAll('#hotbar .hotbar-slot'); // Select main game hotbar slots
const deathMessageDiv = document.getElementById('deathMessage');
// --- Combined Crafting Menu Elements ---
const craftingMenuDiv = document.getElementById('craftingMenu');
const craftingMenuTitle = document.getElementById('craftingMenuTitle'); // Reference to the title H2
// Close button
const closeCraftingButton = document.getElementById('closeCraftingButton');
// Time UI ref
const timeUIDiv = document.getElementById('timeUI');


// --- Game Settings ---
const PLAYER_SPEED = 4;
const PLAYER_RADIUS = 15;
const PLAYER_MAX_HEALTH = 100;
const PLAYER_MAX_HUNGER = 100;
const LIMB_RADIUS = 5;
const HAND_DISTANCE = PLAYER_RADIUS + 10;
const ATTACK_SWING_ARC = Math.PI / 2;
const ATTACK_DURATION = 150;
const INTERACT_DURATION = 100;
const ATTACK_RANGE = 60;
const BASE_ATTACK_POWER = 5; // Base power for hands/unspecified
const BASE_GATHER_POWER = 3; // Base gathering power for hands
const SWORD_MULTIPLIER = 2.0; // Multiplier for swords vs monsters
const AXE_MULTIPLIER = 3.0;   // Multiplier for axes vs trees
const PICKAXE_MULTIPLIER = 4.0; // Multiplier for pickaxes vs rocks
const FLASH_DURATION = 100;
const ITEM_PICKUP_RANGE_SQ = (PLAYER_RADIUS + 10) * (PLAYER_RADIUS + 10);
const DROPPED_ITEM_RADIUS = 5;
const INVENTORY_COLS = 8;
const INVENTORY_ROWS = 4;
const HOTBAR_SIZE = 5;
const MAX_STACK_SIZE = 64;
const PLACE_GRID_SIZE = 20;
const PLACE_RANGE_SQ = (PLAYER_RADIUS + 60) * (PLAYER_RADIUS + 60);
const INTERACT_RANGE_SQ = (PLAYER_RADIUS + 50) * (PLAYER_RADIUS + 50);
const HEAL_AMOUNT = 25; // How much the Healing Salve heals

// --- World & Time Settings ---
const WORLD_WIDTH = 2000 * 10;
const WORLD_HEIGHT = 1500 * 10;
const ISLAND_PADDING = 150 * 3;
const DAY_LENGTH = 120000; // 2 minutes total cycle
const NIGHT_START_PERCENT = 0.65; // Night starts 65% in (35% night duration)
const TRANSITION_DURATION_PERCENT = 0.08; // 8% of DAY_LENGTH for sunrise/sunset fade
const SUNSET_START_PERCENT = NIGHT_START_PERCENT - TRANSITION_DURATION_PERCENT; // Starts fading before night
const SUNRISE_START_PERCENT = 1.0 - TRANSITION_DURATION_PERCENT; // Starts fading before day
const MAX_NIGHT_OPACITY = 0.75; // How dark the night gets


// --- Biome Definitions ---
const WORLD_THIRD_X = WORLD_WIDTH / 3; const WORLD_THIRD_Y = WORLD_HEIGHT / 3;
const BIOME_BOUNDS = { ROCKY_X_END: WORLD_THIRD_X, ROCKY_Y_END: WORLD_THIRD_Y, SWAMP_X_START: WORLD_WIDTH - WORLD_THIRD_X, SWAMP_Y_END: WORLD_THIRD_Y, VOLCANO_X_END: WORLD_THIRD_X, VOLCANO_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, BADLANDS_X_START: WORLD_WIDTH - WORLD_THIRD_X, BADLANDS_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, FROSTLANDS_Y_END: WORLD_THIRD_Y, DESERT_Y_START: WORLD_HEIGHT - WORLD_THIRD_Y, FOREST_X_END: WORLD_THIRD_X, JUNGLE_X_START: WORLD_WIDTH - WORLD_THIRD_X };
const WORLD_CENTER_X = WORLD_WIDTH / 2; const WORLD_CENTER_Y = WORLD_HEIGHT / 2;
const JUNGLE_LAKE = { x: BIOME_BOUNDS.JUNGLE_X_START + (WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START) * 0.15, y: BIOME_BOUNDS.FROSTLANDS_Y_END + (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END) * 0.2, width: (WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START) * 0.7, height: (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END) * 0.6, color: '#367588' };
const LAVA_POOL_COUNT = 5; const lavaPools = []; for (let i = 0; i < LAVA_POOL_COUNT; i++) { const poolWidth = (BIOME_BOUNDS.VOLCANO_X_END * 0.1) + (Math.random() * BIOME_BOUNDS.VOLCANO_X_END * 0.2); const poolHeight = ( (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START) * 0.1) + (Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START) * 0.2); lavaPools.push({ x: (Math.random() * (BIOME_BOUNDS.VOLCANO_X_END - poolWidth)), y: BIOME_BOUNDS.VOLCANO_Y_START + (Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START - poolHeight)), width: poolWidth, height: poolHeight, color: '#FF4500', lightRadius: 80 + Math.random() * 60, lightOpacity: 0.7 + Math.random() * 0.15 }); }

// Biome characteristics with SPECIFIED multipliers
const BIOME_DATA = {
    plains:     { color: '#A0D995', treeDensity: 0.04, rockDensity: 0.02, enemyDensity: 0.003, cactusDensity: 0, spawnMultiplier: 1.5 },
    forest:     { color: '#2E8B57', treeDensity: 0.5,  rockDensity: 0,    enemyDensity: 0.02,  cactusDensity: 0, spawnMultiplier: 3 },
    jungle:     { color: '#556B2F', treeDensity: 0.2,  rockDensity: 0.01, enemyDensity: 0.015, cactusDensity: 0, spawnMultiplier: 3 },
    frostlands: { color: '#E6E6FA', treeDensity: 0.15, rockDensity: 0.04, enemyDensity: 0.01,  cactusDensity: 0, spawnMultiplier: 2.5 },
    desert:     { color: '#EDC9AF', treeDensity: 0,    rockDensity: 0.25, enemyDensity: 0.018, cactusDensity: 0.2, spawnMultiplier: 2.5 },
    rocky:      { color: '#A9A9A9', treeDensity: 0,    rockDensity: 0.8,  enemyDensity: 0.01,  cactusDensity: 0, spawnMultiplier: 4 },
    swamp:      { color: '#6B8E23', treeDensity: 0.1,  rockDensity: 0.01, enemyDensity: 0.025, cactusDensity: 0, spawnMultiplier: 3, hasWater: true },
    volcano:    { color: '#4C4646', treeDensity: 0,    rockDensity: 0.5,  enemyDensity: 0.022, cactusDensity: 0, spawnMultiplier: 4, hasLava: true },
    badlands:   { color: '#D2B48C', treeDensity: 0,    rockDensity: 0.1,  enemyDensity: 0.025, cactusDensity: 0.05, spawnMultiplier: 3.5, hasBoneTrees: true },
};


// --- Boss Settings ---
const PLAINS_BOSS_RADIUS = 40; const PLAINS_BOSS_HEALTH = 1000; const PLAINS_BOSS_SPEED = 1.0; const PLAINS_BOSS_DETECT_RANGE_SQ = 400 * 400; const PLAINS_BOSS_ATTACK_COOLDOWN = 1500; const PLAINS_BOSS_ATTACK_CHOICE_COOLDOWN = 3000; const BOSS_HIT_RANGE = PLAINS_BOSS_RADIUS + PLAYER_RADIUS + 10; const BOSS_HIT_DAMAGE = 25; const BOSS_SMASH_RANGE = 100; const BOSS_SMASH_DAMAGE = 35; const BOSS_SMASH_WINDUP = 800; const BOSS_SMASH_EFFECT_DURATION = 300; const BOSS_SPIN_RANGE = PLAINS_BOSS_RADIUS + 20; const BOSS_SPIN_DAMAGE = 15; const BOSS_SPIN_DURATION = 1200; const BOSS_SPIN_DAMAGE_INTERVAL = 300;

// Monster Settings
const MONSTER_SPEED = 1.8; const MONSTER_DETECT_RANGE = 250; const MONSTER_ATTACK_RANGE = 40; const MONSTER_ATTACK_COOLDOWN = 1000; const MONSTER_DAMAGE = 10; const INITIAL_MONSTER_COUNT = 1000; const NIGHTLY_MONSTER_SPAWN_COUNT = 100; const MAX_MONSTER_COUNT = 5000; const FOREST_TREE_TARGET = 1200; const GOLD_COIN_DROP_CHANCE = 1 / 50;

// Item Data - Added 'shape' property
const ITEM_DATA = {
    'tree': { color: '#654321', name: 'Tree', isPlaceable: false, health: 50, radius: 15, shape: 'circle'},
    'rock': { color: '#808080', name: 'Rock', isPlaceable: false, health: 150, radius: 12, shape: 'circle'},
    'cactus': { color: '#2E8B57', name: 'Cactus', isPlaceable: false, isSolid: true, isAttackable: true, radius: 10, health: 100, shape: 'cactus' },
    'bone_tree': { color: '#EEDFCC', name: 'Bone Tree', isPlaceable: false, isSolid: true, isAttackable: true, radius: 13, health: 160, shape: 'tree', variant: 'bone'},
    'wood': { color: '#A0522D', name: 'Wood', isPlaceable: false, shape: 'rect' },
    'stone': { color: '#778899', name: 'Stone', isPlaceable: false, shape: 'circle' },
    'plant_fiber': { color: '#9ACD32', name: 'Plant Fiber', isPlaceable: false, shape: 'line' },
    'monster_goop': { color: '#90EE90', name: 'Monster Goop', isPlaceable: false, shape: 'circle' },
    'gold_coin': { color: '#FFD700', name: 'Gold Coin', isPlaceable: false, shape: 'circle' },
    'dust': { color: '#C2B280', name: 'Dust', isPlaceable: false, shape: 'circle'},
    'stick': { color: '#B8860B', name: 'Stick', isPlaceable: false, shape: 'line' },
    'wood_plank': { color: '#DEB887', name: 'Wooden Plank', isPlaceable: true, solidRadius: PLACE_GRID_SIZE / 2, shape: 'rect' },
    'stone_block': { color: '#696969', name: 'Stone Block', isPlaceable: true, solidRadius: PLACE_GRID_SIZE / 2, shape: 'rect' },
    'workbench': { color: '#D2691E', name: 'Workbench', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect' },
    'icky_bed': { color: '#556B2F', name: 'Icky Bed', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect' },
    'torch': { color: '#FFA500', name: 'Torch', isPlaceable: true, isSolid: true, isAttackable: true, solidRadius: 5, health: 10, lightRadius: 120, shape: 'torch' },
    'item_upgrader_t1': { color: '#708090', name: 'Item Upgrader T1', isPlaceable: true, isInteractable: true, solidRadius: PLACE_GRID_SIZE, shape: 'rect' },
    'healing_salve': { color: '#FFC0CB', name: 'Healing Salve', isPlaceable: false, isUsable: true, shape: 'circle' },
    'wood_sword': { color: '#D2B48C', name: 'Wooden Sword', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER, shape: 'sword' },
    'wood_axe': { color: '#8B4513', name: 'Wooden Axe', isPlaceable: false, type: 'tool', toolType: 'axe', gatherMultiplier: AXE_MULTIPLIER, target: 'tree', shape: 'axe' },
    'wood_pickaxe': { color: '#A0522D', name: 'Wooden Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER, target: 'rock', shape: 'pickaxe' },
    'stone_sword': { color: '#A9A9A9', name: 'Stone Sword', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER * 1.5, shape: 'sword' },
    'stone_axe': { color: '#808080', name: 'Stone Axe', isPlaceable: false, type: 'tool', toolType: 'axe', gatherMultiplier: AXE_MULTIPLIER * 1.5, target: 'tree', shape: 'axe' },
    'stone_pickaxe': { color: '#696969', name: 'Stone Pickaxe', isPlaceable: false, type: 'tool', toolType: 'pickaxe', gatherMultiplier: PICKAXE_MULTIPLIER * 1.5, target: 'rock', shape: 'pickaxe' },
    'wooden_bow': { color: '#CD853F', name: 'Wooden Bow', isPlaceable: false, type: 'tool', toolType: 'bow', shape: 'bow', range: 400, damage: 15 },
    'stone_reinforced_bow': { color: '#A58D71', name: 'Stone-Reinforced Bow', isPlaceable: false, type: 'tool', toolType: 'bow', shape: 'bow', range: 450, damage: 22 },
    'arrow': { color: '#F5F5DC', name: 'Arrow', isPlaceable: false, type: 'ammo', shape: 'line' },
    'bone_scythe': { color: '#F5F5DC', name: 'Bone Scythe', isPlaceable: false, type: 'tool', toolType: 'sword', damageMultiplier: SWORD_MULTIPLIER * 2, shape: 'sword'},
    'fishing_rod': { color: '#C0C0C0', name: 'Fishing Rod', isPlaceable: false, type: 'tool', toolType: 'fishing_rod', shape: 'line' },
};

// --- Game State ---
let mouseCanvasX = 0; let mouseCanvasY = 0;
let worldMouseX = 0; let worldMouseY = 0;
let keysPressed = {};
let resources = []; let monsters = []; let solidObjects = []; let bosses = []; let walls = []; // Added walls array
let projectiles = []; // Added projectile array
let droppedItems = [];
let gameTime = 0; let dayCount = 1; let isNight = false;
let currentNightOpacity = 0;
let isGameOver = false; let isCraftingMenuOpen = false; let isUpgraderUIOpen = false;
let selectedUpgradeInput = { slotIndex: -1, source: null };
let cameraX = 0; let cameraY = 0;

const player = {
    x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2,
    radius: PLAYER_RADIUS,
    id: 'player',
    health: PLAYER_MAX_HEALTH, hunger: PLAYER_MAX_HUNGER,
    angle: 0,
    isAttacking: false, attackTimer: 0,
    isInteracting: false, interactTimer: 0,
    inventorySlots: new Array(INVENTORY_COLS * INVENTORY_ROWS).fill(null),
    hotbarSlots: new Array(HOTBAR_SIZE).fill(null),
    selectedHotbarSlotIndex: 0,
    equippedItemType: null,
    selectedInventoryItem: null,
    respawnX: WORLD_WIDTH / 2,
    respawnY: WORLD_HEIGHT / 2,
};

// --- Define Recipes ---
const recipes = [
    { id: 'stick', name: "Stick (x4)", output: { type: 'stick', count: 4 }, input: { 'wood': 1 }, requiresWorkbench: false },
    { id: 'wood_plank', name: "Wooden Plank (x4)", output: { type: 'wood_plank', count: 4 }, input: { 'wood': 1 }, requiresWorkbench: false },
    { id: 'stone_block', name: "Stone Block", output: { type: 'stone_block', count: 1 }, input: { 'stone': 2 }, requiresWorkbench: false },
    { id: 'basic_workbench', name: "Workbench", output: { type: 'workbench', count: 1 }, input: { 'wood_plank': 5, 'stick': 2 }, requiresWorkbench: false },
    { id: 'healing_salve', name: "Healing Salve", output: { type: 'healing_salve', count: 1}, input: { 'plant_fiber': 3, 'monster_goop': 1}, requiresWorkbench: false },
    { id: 'icky_bed', name: "Icky Bed", output: { type: 'icky_bed', count: 1}, input: { 'wood_plank': 8, 'plant_fiber': 5, 'monster_goop': 3 }, requiresWorkbench: false },
    { id: 'torch', name: "Torch (x3)", output: { type: 'torch', count: 3 }, input: { 'stick': 12, 'monster_goop': 10 }, requiresWorkbench: false },
    { id: 'item_upgrader_t1', name: "Item Upgrader T1", output: { type: 'item_upgrader_t1', count: 1 }, input: { 'stone': 10, 'wood': 10, 'monster_goop': 15 }, requiresWorkbench: false },
    { id: 'arrow', name: "Arrow (x5)", output: { type: 'arrow', count: 5 }, input: { 'stick': 1, 'stone': 1 }, requiresWorkbench: false },
    { id: 'wood_sword', name: "Wooden Sword", output: { type: 'wood_sword', count: 1}, input: { 'wood_plank': 2, 'stick': 1}, requiresWorkbench: true },
    { id: 'wood_axe', name: "Wooden Axe", output: { type: 'wood_axe', count: 1}, input: { 'wood_plank': 3, 'stick': 2}, requiresWorkbench: true },
    { id: 'wood_pickaxe', name: "Wooden Pickaxe", output: { type: 'wood_pickaxe', count: 1}, input: { 'wood_plank': 3, 'stick': 2}, requiresWorkbench: true },
    // REMOVED Wooden Bow Recipe
    { id: 'fishing_rod', name: "Fishing Rod", output: { type: 'fishing_rod', count: 1}, input: { 'stick': 3, 'plant_fiber': 2}, requiresWorkbench: true },
];

// --- Define Upgrader Recipes ---
const UPGRADER_RECIPES = {
    'wood_sword':   { material: 'stone', materialCount: 5, output: 'stone_sword', name: 'Stone Sword' },
    'wood_axe':     { material: 'stone', materialCount: 5, output: 'stone_axe', name: 'Stone Axe' },
    'wood_pickaxe': { material: 'stone', materialCount: 5, output: 'stone_pickaxe', name: 'Stone Pickaxe' },
    'wooden_bow':   { material: 'stone', materialCount: 8, output: 'stone_reinforced_bow', name: 'Stone-Reinforced Bow' },
};

// --- Utility Functions ---
function distanceSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
function distance(x1, y1, x2, y2) { return Math.sqrt(distanceSq(x1, y1, x2, y2)); }
function normalizeAngle(angle) { while (angle <= -Math.PI) angle += 2 * Math.PI; while (angle > Math.PI) angle -= 2 * Math.PI; return angle; }
function clampCamera() { const camLeft = player.x - canvas.width / 2; const camTop = player.y - canvas.height / 2; const camRight = player.x + canvas.width / 2; const camBottom = player.y + canvas.height / 2; cameraX = player.x; cameraY = player.y; if (camLeft < 0) cameraX = canvas.width / 2; if (camRight > WORLD_WIDTH) cameraX = WORLD_WIDTH - canvas.width / 2; if (camTop < 0) cameraY = canvas.height / 2; if (camBottom > WORLD_HEIGHT) cameraY = WORLD_HEIGHT - canvas.height / 2; }
function canvasToWorld(canvasX, canvasY) { const worldOriginX = cameraX - canvas.width / 2; const worldOriginY = cameraY - canvas.height / 2; return { x: canvasX + worldOriginX, y: canvasY + worldOriginY }; }
function getBiomeAt(x, y) { if (x < BIOME_BOUNDS.ROCKY_X_END && y < BIOME_BOUNDS.ROCKY_Y_END) return 'rocky'; if (x > BIOME_BOUNDS.SWAMP_X_START && y < BIOME_BOUNDS.SWAMP_Y_END) return 'swamp'; if (x < BIOME_BOUNDS.VOLCANO_X_END && y > BIOME_BOUNDS.VOLCANO_Y_START) return 'volcano'; if (x > BIOME_BOUNDS.BADLANDS_X_START && y > BIOME_BOUNDS.BADLANDS_Y_START) return 'badlands'; if (y < BIOME_BOUNDS.FROSTLANDS_Y_END) return 'frostlands'; if (y > BIOME_BOUNDS.DESERT_Y_START) return 'desert'; if (x < BIOME_BOUNDS.FOREST_X_END) return 'forest'; if (x > BIOME_BOUNDS.JUNGLE_X_START) return 'jungle'; return 'plains'; }
// Helper to format time (MM:SS)
function formatTime(milliseconds) { if (milliseconds < 0) milliseconds = 0; const totalSeconds = Math.floor(milliseconds / 1000); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; }


// --- Item Handling Functions ---
function findFirstEmptyInventorySlot() { return player.inventorySlots.findIndex(slot => slot === null); }
function findItemStackableInventorySlot(itemType) { return player.inventorySlots.findIndex(slot => slot !== null && slot.type === itemType && slot.count < MAX_STACK_SIZE); }
function addDroppedItem(x, y, type, count = 1) { for (let i = 0; i < count; i++) { const offsetX = (Math.random() - 0.5) * 15; const offsetY = (Math.random() - 0.5) * 15; droppedItems.push({ id: `item_${Date.now()}_${Math.random()}`, x: x + offsetX, y: y + offsetY, type: type, radius: DROPPED_ITEM_RADIUS, spawnTime: Date.now() }); } }
function addToInventory(itemType, count = 1) { let remainingCount = count; while (remainingCount > 0) { const stackableSlotIndex = findItemStackableInventorySlot(itemType); if (stackableSlotIndex !== -1) { const slot = player.inventorySlots[stackableSlotIndex]; const canAdd = MAX_STACK_SIZE - slot.count; const amountToAdd = Math.min(remainingCount, canAdd); slot.count += amountToAdd; remainingCount -= amountToAdd; } else { break; } } while (remainingCount > 0) { const emptySlotIndex = findFirstEmptyInventorySlot(); if (emptySlotIndex !== -1) { const amountToAdd = Math.min(remainingCount, MAX_STACK_SIZE); player.inventorySlots[emptySlotIndex] = { type: itemType, count: amountToAdd }; remainingCount -= amountToAdd; } else { console.warn(`Inventory full! Could not add ${remainingCount} ${itemType}.`); remainingCount = 0; break; } } if (isCraftingMenuOpen) { populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } updateMainHotbarVisuals(); }
function removeFromInventory(itemType, count = 1) { let remainingToRemove = count; let removedSuccessfully = 0; for (let i = 0; i < player.inventorySlots.length && remainingToRemove > 0; i++) { const slot = player.inventorySlots[i]; if (slot && slot.type === itemType) { const amountToRemoveFromSlot = Math.min(remainingToRemove, slot.count); slot.count -= amountToRemoveFromSlot; remainingToRemove -= amountToRemoveFromSlot; removedSuccessfully += amountToRemoveFromSlot; if (slot.count <= 0) { player.inventorySlots[i] = null; } } } /* Check hotbar too if needed */ if (removedSuccessfully > 0) { if (isCraftingMenuOpen) { populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } updateMainHotbarVisuals(); } if(remainingToRemove > 0) { return false; } return true; }
function getTotalItemCount(itemType) { const invCount = player.inventorySlots.reduce((total, slot) => (slot && slot.type === itemType ? total + slot.count : total), 0); const hotbarCount = player.hotbarSlots.reduce((total, slot) => (slot && slot.type === itemType ? total + slot.count : total), 0); return invCount + hotbarCount; }

// --- Crafting Functions ---
function canCraft(recipe) { for (const itemId in recipe.input) { if (getTotalItemCount(itemId) < recipe.input[itemId]) return false; } return true; }
function doCraft(recipeId) { const recipe = recipes.find(r => r.id === recipeId); if (!recipe) return; if (canCraft(recipe)) { let success = true; const ingredientsToRemove = { ...recipe.input }; for (const itemId in ingredientsToRemove) { if (!removeFromInventory(itemId, ingredientsToRemove[itemId])) { success = false; break; } } if (success) { addToInventory(recipe.output.type, recipe.output.count); console.log(`%cCrafted ${recipe.output.count}x ${recipe.output.type}!`, 'color: cyan; font-weight: bold;'); if (isCraftingMenuOpen) populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } else { console.error(`Crafting failed for ${recipe.name} due to ingredient removal issue.`); } } else { console.log(`Cannot craft ${recipe.name} - missing ingredients.`); } }

// --- UI Interaction ('E' Menu - Item Moving) ---
function handleInventorySlotClick(index) { const clickedSlot = player.inventorySlots[index]; const selected = player.selectedInventoryItem; if (selected) { const originalSourceSlot = selected.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; originalSourceSlot[selected.index] = clickedSlot; player.inventorySlots[index] = { type: selected.type, count: selected.count }; player.selectedInventoryItem = null; } else if (clickedSlot) { player.selectedInventoryItem = { index: index, type: clickedSlot.type, count: clickedSlot.count, source: 'inventory' }; } populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); updateMainHotbarVisuals(); }
function handleHotbarSlotClick(index) { const clickedSlot = player.hotbarSlots[index]; const selected = player.selectedInventoryItem; if (selected) { const originalSourceSlot = selected.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; originalSourceSlot[selected.index] = clickedSlot; player.hotbarSlots[index] = { type: selected.type, count: selected.count }; player.selectedInventoryItem = null; } else if (clickedSlot) { player.selectedInventoryItem = { index: index, type: clickedSlot.type, count: clickedSlot.count, source: 'hotbar' }; } populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); updateMainHotbarVisuals(); updateEquippedItem(); }

// Draws an item representation onto a given context at (0,0) within the specified size
function drawItemShape(ctx, itemType, size) {
    const itemData = ITEM_DATA[itemType];
    if (!itemData) { ctx.fillStyle = 'magenta'; ctx.fillRect(size * 0.1, size * 0.1, size * 0.8, size * 0.8); ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.strokeRect(size * 0.1, size * 0.1, size * 0.8, size * 0.8); ctx.beginPath(); ctx.moveTo(size*0.1,size*0.1); ctx.lineTo(size*0.9,size*0.9); ctx.moveTo(size*0.9,size*0.1); ctx.lineTo(size*0.1,size*0.9); ctx.stroke(); return; }
    ctx.save(); ctx.translate(size / 2, size / 2); ctx.fillStyle = itemData.color || '#FFFFFF'; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 1;
    const scale = size / 30; ctx.scale(scale, scale); const shapeSize = 18;
    switch (itemData.shape) {
        case 'line': ctx.beginPath(); ctx.moveTo(0, -shapeSize*0.6); ctx.lineTo(0, shapeSize*0.6); ctx.lineWidth = 3*scale > 1 ? 3 : 1/scale; ctx.stroke(); break;
        case 'rect': ctx.fillRect(-shapeSize*0.4, -shapeSize*0.4, shapeSize*0.8, shapeSize*0.8); ctx.strokeRect(-shapeSize*0.4, -shapeSize*0.4, shapeSize*0.8, shapeSize*0.8); break;
        case 'torch': const sH=shapeSize*1.0, sW=shapeSize*0.2, fH=shapeSize*0.5; ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-sW/2, sH*0.1, sW, sH*0.9); ctx.fillStyle=itemData.color; ctx.beginPath(); ctx.ellipse(0, -sH*0.25, sW*1.5, fH, 0,0,Math.PI*2); ctx.fill(); break;
        case 'sword': const swH=shapeSize*1.3, swW=shapeSize*0.15, gW=shapeSize*0.4; ctx.fillStyle = '#444'; ctx.fillRect(-swW*1.2, swH*0.2, swW*2.4, swH*0.2); ctx.fillStyle = '#888'; ctx.fillRect(-gW/2, swH*0.1, gW, swW*2); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.moveTo(0, -swH*0.4); ctx.lineTo(-swW, swH*0.1); ctx.lineTo(swW, swH*0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); break;
        case 'axe': case 'pickaxe': const hH=shapeSize*1.2, hW=shapeSize*0.15, hdW=shapeSize*0.6, hdH=shapeSize*0.4; ctx.fillStyle = ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-hW/2, -hH/2+hdH/2, hW, hH); ctx.strokeRect(-hW/2, -hH/2+hdH/2, hW, hH); ctx.fillStyle = itemData.color; ctx.fillRect(-hdW/2, -hH/2, hdW, hdH); ctx.strokeRect(-hdW/2, -hH/2, hdW, hdH); break;
        case 'bow': ctx.beginPath(); ctx.moveTo(0, -shapeSize * 0.6); ctx.quadraticCurveTo(-shapeSize * 0.7, 0, 0, shapeSize * 0.6); ctx.quadraticCurveTo(shapeSize * 0.7, 0, 0, -shapeSize * 0.6); ctx.moveTo(-shapeSize*0.1, -shapeSize*0.5); ctx.lineTo(-shapeSize*0.1, shapeSize*0.5); ctx.lineWidth = 1 * scale > 0.5 ? 1 : 0.5/scale; ctx.strokeStyle = '#eee'; ctx.stroke(); ctx.lineWidth = 3 * scale > 1 ? 3 : 1/scale; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke(); ctx.fill(); break;
        case 'cactus': const cW = shapeSize * 0.4; const cH = shapeSize * 1.3; ctx.fillRect(-cW/2,-cH/2, cW, cH); ctx.fillRect(-cW*1.2, -cH*0.1, cW*2.4, cW*0.6); ctx.strokeStyle='darkgreen'; ctx.strokeRect(-cW/2,-cH/2, cW, cH); break;
        case 'circle': default: ctx.beginPath(); ctx.arc(0, 0, shapeSize*0.4, 0, Math.PI*2); ctx.fill(); ctx.stroke(); break;
    }
    ctx.restore();
}

// --- Update Combined Crafting Menu Display ---
function populateCraftingMenu(isNearWorkbench, isNearUpgrader) {
    if (!craftingMenuDiv) return;
    const inventoryGrid = document.getElementById('inventoryGrid'); const hotbarGrid = document.getElementById('hotbarGrid'); const playerRecipeList = document.getElementById('recipeList');
    const workbenchContextDiv = document.getElementById('workbenchContext'); const upgraderContextDiv = document.getElementById('upgraderContext');
    const workbenchRecipeList = document.getElementById('workbenchRecipeList');
    if (!inventoryGrid || !hotbarGrid || !playerRecipeList || !workbenchContextDiv || !upgraderContextDiv || !workbenchRecipeList) { console.error("Missing UI elements for combined crafting menu!"); return; }
    inventoryGrid.style.setProperty('--inventory-cols', INVENTORY_COLS); hotbarGrid.style.setProperty('--hotbar-size', HOTBAR_SIZE);
    const createSlotCanvas = (item) => { const itemCanvas = document.createElement('canvas'); itemCanvas.width = 40; itemCanvas.height = 40; itemCanvas.classList.add('item-icon'); const itemCtx = itemCanvas.getContext('2d'); if(item && item.type) { drawItemShape(itemCtx, item.type, itemCanvas.width); } return itemCanvas; };
    inventoryGrid.innerHTML = ''; player.inventorySlots.forEach((item, index) => { const slotDiv = document.createElement('div'); slotDiv.classList.add('inventory-slot'); slotDiv.dataset.index = index; if (item) { const itemData = ITEM_DATA[item.type] || { name: item.type }; slotDiv.title = itemData.name; slotDiv.appendChild(createSlotCanvas(item)); if (item.count > 1) { const countSpan = document.createElement('span'); countSpan.classList.add('item-count'); countSpan.textContent = item.count; slotDiv.appendChild(countSpan); } } if (player.selectedInventoryItem && player.selectedInventoryItem.source === 'inventory' && player.selectedInventoryItem.index === index) { slotDiv.classList.add('selected-for-move'); if(item) slotDiv.style.opacity = '0.5'; } slotDiv.addEventListener('click', () => handleInventorySlotClick(index)); inventoryGrid.appendChild(slotDiv); });
    hotbarGrid.innerHTML = ''; player.hotbarSlots.forEach((item, index) => { const slotDiv = document.createElement('div'); slotDiv.classList.add('hotbar-menu-slot'); slotDiv.dataset.index = index; if (item) { const itemData = ITEM_DATA[item.type] || { name: item.type }; slotDiv.title = itemData.name; slotDiv.appendChild(createSlotCanvas(item)); if (item.count > 1) { const countSpan = document.createElement('span'); countSpan.classList.add('item-count'); countSpan.textContent = item.count; slotDiv.appendChild(countSpan); } } if (player.selectedInventoryItem && player.selectedInventoryItem.source === 'hotbar' && player.selectedInventoryItem.index === index) { slotDiv.classList.add('selected-for-move'); if(item) slotDiv.style.opacity = '0.5'; } slotDiv.addEventListener('click', () => handleHotbarSlotClick(index)); hotbarGrid.appendChild(slotDiv); });
    playerRecipeList.innerHTML = ''; const playerRecipes = recipes.filter(recipe => !recipe.requiresWorkbench); if (playerRecipes.length === 0) { playerRecipeList.innerHTML = `<li>No player recipes available.</li>`; } else { playerRecipes.forEach(recipe => { const li = document.createElement('li'); const canCurrentlyCraft = canCraft(recipe); let ingredientsHTML = ''; for (const itemId in recipe.input) { const required = recipe.input[itemId]; const owned = getTotalItemCount(itemId); const missingClass = owned < required ? 'missing' : ''; const itemName = (ITEM_DATA[itemId]?.name || itemId).replace(/_/g, ' '); ingredientsHTML += `<span class="ingredient ${missingClass}">${itemName}: ${owned}/${required}</span>`; } li.innerHTML = `<div><strong>${recipe.name}</strong><div class="recipe-details">${ingredientsHTML}</div></div><button data-recipe-id="${recipe.id}" ${canCurrentlyCraft ? '' : 'disabled'}>Craft</button>`; const craftButton = li.querySelector('button'); if(craftButton) { craftButton.addEventListener('click', () => { doCraft(recipe.id); }); } playerRecipeList.appendChild(li); }); }
    workbenchRecipeList.innerHTML = ''; if (isNearWorkbench) { populateWorkbenchRecipes(workbenchRecipeList); }
    if (isNearUpgrader) { populateUpgraderUI(); } else { const upgraderInputSlot = document.getElementById('upgraderInputSlot'); const upgraderMaterialSlot = document.getElementById('upgraderMaterialSlot'); const upgraderOutputSlot = document.getElementById('upgraderOutputSlot'); const upgradeItemButton = document.getElementById('upgradeItemButton'); if(upgraderInputSlot)upgraderInputSlot.innerHTML='';if(upgraderMaterialSlot)upgraderMaterialSlot.innerHTML='';if(upgraderOutputSlot)upgraderOutputSlot.innerHTML='';if(upgradeItemButton)upgradeItemButton.disabled=true;selectedUpgradeInput = { slotIndex: -1, source: null }; }
}
function toggleCraftingMenu() { isCraftingMenuOpen = !isCraftingMenuOpen; if (isCraftingMenuOpen) { const nearUpgrader = isNearUpgrader(); const nearWorkbench = !nearUpgrader && isNearWorkbench(); let context = 'player'; let title = 'Crafting'; let activeClass = ''; if (nearUpgrader) { context = 'upgrader'; title = 'Item Upgrader'; activeClass = 'upgrader-active'; } else if (nearWorkbench) { context = 'workbench'; title = 'Workbench Crafting'; activeClass = 'workbench-active'; } populateCraftingMenu(nearWorkbench, nearUpgrader); craftingMenuDiv.className = 'active ' + activeClass; craftingMenuDiv.style.display = 'flex'; craftingMenuTitle.textContent = title; } else { craftingMenuDiv.style.display = 'none'; craftingMenuDiv.className = ''; if (player.selectedInventoryItem) { player.selectedInventoryItem = null; } if (selectedUpgradeInput.slotIndex !== -1) selectedUpgradeInput = { slotIndex: -1, source: null }; } }

// --- Helper Functions for Proximity ---
function isNearWorkbench() { for (const obj of solidObjects) { if (obj.isPlaced && obj.type === 'workbench') { const distSq = distanceSq(player.x, player.y, obj.x, obj.y); if (distSq < INTERACT_RANGE_SQ) { if (distSq > (player.radius + obj.radius - 5) * (player.radius + obj.radius - 5) ) { return true; } } } } return false; }
function isNearUpgrader() { for (const obj of solidObjects) { if (obj.isPlaced && obj.type === 'item_upgrader_t1') { const distSq = distanceSq(player.x, player.y, obj.x, obj.y); if (distSq < INTERACT_RANGE_SQ) { if (distSq > (player.radius + obj.radius - 5) * (player.radius + obj.radius - 5) ) { return true; } } } } return false; }

// Helper Function to find first upgradeable tool
function findUpgradeableTool() { const woodenToolTypes = ['wood_sword', 'wood_axe', 'wood_pickaxe', 'wooden_bow']; for(let i=0; i < player.hotbarSlots.length; i++) { const item = player.hotbarSlots[i]; if (item && woodenToolTypes.includes(item.type) && UPGRADER_RECIPES[item.type]) { return { item, index: i, source: 'hotbar' }; } } for(let i=0; i < player.inventorySlots.length; i++) { const item = player.inventorySlots[i]; if (item && woodenToolTypes.includes(item.type) && UPGRADER_RECIPES[item.type]) { return { item, index: i, source: 'inventory' }; } } return null; }

// --- Populate Contextual UI Sections ---
function populateWorkbenchRecipes(listElement) { if (!listElement) return; listElement.innerHTML = ''; const availableRecipes = recipes.filter(recipe => recipe.requiresWorkbench === true); if (availableRecipes.length === 0) { listElement.innerHTML = `<li>No workbench recipes available yet.</li>`; } else { availableRecipes.forEach(recipe => { const li = document.createElement('li'); const canCurrentlyCraft = canCraft(recipe); let ingredientsHTML = ''; for (const itemId in recipe.input) { const required = recipe.input[itemId]; const owned = getTotalItemCount(itemId); const missingClass = owned < required ? 'missing' : ''; const itemName = (ITEM_DATA[itemId]?.name || itemId).replace(/_/g, ' '); ingredientsHTML += `<span class="ingredient ${missingClass}">${itemName}: ${owned}/${required}</span>`; } li.innerHTML = `<div><strong>${recipe.name}</strong><div class="recipe-details">${ingredientsHTML}</div></div><button data-recipe-id="${recipe.id}" ${canCurrentlyCraft ? '' : 'disabled'}>Craft</button>`; const craftButton = li.querySelector('button'); if (craftButton) { craftButton.addEventListener('click', () => { doCraft(recipe.id); }); } listElement.appendChild(li); }); } }
function populateUpgraderUI() { const inputSlotDiv = document.getElementById('upgraderInputSlot'); const materialSlotDiv = document.getElementById('upgraderMaterialSlot'); const outputSlotDiv = document.getElementById('upgraderOutputSlot'); const upgradeBtn = document.getElementById('upgradeItemButton'); if (!inputSlotDiv || !materialSlotDiv || !outputSlotDiv || !upgradeBtn ) { console.error("Missing Upgrader UI elements"); return; } const createSlotCanvas = (item) => { const itemCanvas = document.createElement('canvas'); itemCanvas.width = 40; itemCanvas.height = 40; itemCanvas.classList.add('item-icon'); const itemCtx = itemCanvas.getContext('2d'); if(item && item.type) { drawItemShape(itemCtx, item.type, itemCanvas.width); } return itemCanvas; }; inputSlotDiv.innerHTML = '(Click Tool)'; inputSlotDiv.style.opacity = '0.5'; inputSlotDiv.classList.remove('has-item'); materialSlotDiv.innerHTML = '(Material)'; materialSlotDiv.style.opacity = '0.5'; materialSlotDiv.classList.remove('has-item'); outputSlotDiv.innerHTML = '(Result)'; outputSlotDiv.style.opacity = '0.5'; outputSlotDiv.classList.remove('has-item'); upgradeBtn.disabled = true; if (!inputSlotDiv.dataset.listenerAdded) { inputSlotDiv.addEventListener('click', handleUpgraderInputClick); inputSlotDiv.dataset.listenerAdded = 'true'; } let currentInputItem = null; if (selectedUpgradeInput.slotIndex !== -1 && selectedUpgradeInput.source) { const sourceArray = selectedUpgradeInput.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; currentInputItem = sourceArray[selectedUpgradeInput.slotIndex]; } if (currentInputItem) { inputSlotDiv.innerHTML = ''; inputSlotDiv.appendChild(createSlotCanvas(currentInputItem)); inputSlotDiv.style.opacity = '1'; inputSlotDiv.classList.add('has-item'); const upgradeRecipe = UPGRADER_RECIPES[currentInputItem.type]; if (upgradeRecipe) { materialSlotDiv.innerHTML = ''; const materialItem = { type: upgradeRecipe.material, count: upgradeRecipe.materialCount }; materialSlotDiv.appendChild(createSlotCanvas(materialItem)); const countSpanMat = document.createElement('span'); countSpanMat.classList.add('item-count'); countSpanMat.textContent = upgradeRecipe.materialCount; materialSlotDiv.appendChild(countSpanMat); materialSlotDiv.style.opacity = '1'; materialSlotDiv.classList.add('has-item'); outputSlotDiv.innerHTML = ''; const outputItem = { type: upgradeRecipe.output, count: 1}; outputSlotDiv.appendChild(createSlotCanvas(outputItem)); outputSlotDiv.style.opacity = '1'; outputSlotDiv.classList.add('has-item'); const hasMaterials = getTotalItemCount(upgradeRecipe.material) >= upgradeRecipe.materialCount; upgradeBtn.disabled = !hasMaterials; } else { outputSlotDiv.innerHTML = '(Invalid)'; upgradeBtn.disabled = true; } } else { upgradeBtn.disabled = true; } }
function handleUpgraderInputClick() { const selected = player.selectedInventoryItem; if (selected) { const itemType = selected.type; if (UPGRADER_RECIPES[itemType]) { selectedUpgradeInput.slotIndex = selected.index; selectedUpgradeInput.source = selected.source; player.selectedInventoryItem = null; populateCraftingMenu(false, true); } } else if (selectedUpgradeInput.slotIndex !== -1) { selectedUpgradeInput = { slotIndex: -1, source: null }; populateCraftingMenu(false, true); } }
function doUpgrade() { if (selectedUpgradeInput.slotIndex === -1 || !selectedUpgradeInput.source) { console.warn("No tool selected to upgrade."); return; } const sourceArray = selectedUpgradeInput.source === 'inventory' ? player.inventorySlots : player.hotbarSlots; const toolToUpgrade = sourceArray[selectedUpgradeInput.slotIndex]; if (!toolToUpgrade) { console.error("Selected tool disappeared?"); selectedUpgradeInput = {slotIndex: -1, source: null}; populateCraftingMenu(false, true); return; } const upgradeRecipe = UPGRADER_RECIPES[toolToUpgrade.type]; if (!upgradeRecipe) { console.error("Upgrade recipe inconsistency."); return; } if (getTotalItemCount(upgradeRecipe.material) >= upgradeRecipe.materialCount) { const removedMaterial = removeFromInventory(upgradeRecipe.material, upgradeRecipe.materialCount); let removedTool = false; if (selectedUpgradeInput.source === 'inventory') { player.inventorySlots[selectedUpgradeInput.slotIndex] = null; removedTool = true; } else if (selectedUpgradeInput.source === 'hotbar') { player.hotbarSlots[selectedUpgradeInput.slotIndex] = null; removedTool = true; updateMainHotbarVisuals(); updateEquippedItem(); } if (removedMaterial && removedTool) { addToInventory(upgradeRecipe.output, 1); console.log(`%cUpgraded to ${upgradeRecipe.name}!`, "color: lightblue; font-weight: bold;"); selectedUpgradeInput = {slotIndex: -1, source: null}; populateCraftingMenu(false, true); } else { console.error("Failed to remove resources during upgrade attempt."); } } else { console.warn(`Not enough ${upgradeRecipe.material} (button click).`); } }
// Add event listener dynamically when populating if needed, or ensure button is always present
const integratedUpgradeButton = document.getElementById('upgradeItemButton');
if (integratedUpgradeButton) integratedUpgradeButton.addEventListener('click', doUpgrade);


// --- Update Main Hotbar Visuals ---
function updateMainHotbarVisuals() { mainHotbarSlots.forEach((slotDiv, index) => { const item = player.hotbarSlots[index]; const existingIcon = slotDiv.querySelector('.item-icon'); const existingCount = slotDiv.querySelector('.item-count'); if (existingIcon) slotDiv.removeChild(existingIcon); if (existingCount) slotDiv.removeChild(existingCount); let numberSpan = slotDiv.querySelector('span'); if (!numberSpan) { numberSpan = document.createElement('span'); numberSpan.style.opacity = '0.5'; numberSpan.style.position = 'absolute'; numberSpan.style.top = '5px'; numberSpan.style.left = '5px'; numberSpan.style.zIndex = '-1'; numberSpan.textContent = `${index + 1}`; slotDiv.appendChild(numberSpan); } if (item) { const itemCanvas = document.createElement('canvas'); itemCanvas.width = 35; itemCanvas.height = 35; itemCanvas.classList.add('item-icon'); itemCanvas.style.pointerEvents = 'none'; const itemCtx = itemCanvas.getContext('2d'); if(item.type){ drawItemShape(itemCtx, item.type, itemCanvas.width); } slotDiv.appendChild(itemCanvas); if (item.count > 1) { const countSpan = document.createElement('span'); countSpan.classList.add('item-count'); countSpan.textContent = item.count; slotDiv.appendChild(countSpan); } } }); }

// --- Collision Detection ---
function checkCollision(entityRadius, potentialX, potentialY, ignoreId = null, checkAgainst = [...solidObjects, ...walls]) { // Check walls too!
    for (const solid of checkAgainst) { if (solid && solid.id !== ignoreId) { if (solid.isWall) { const closestX = Math.max(solid.x, Math.min(potentialX, solid.x + solid.width)); const closestY = Math.max(solid.y, Math.min(potentialY, solid.y + solid.height)); const distSq = distanceSq(potentialX, potentialY, closestX, closestY); if (distSq < entityRadius * entityRadius) { return solid; } } else if (typeof solid.radius === 'number') { const distSq = distanceSq(potentialX, potentialY, solid.x, solid.y); const radiiSumSq = (entityRadius + solid.radius) * (entityRadius + solid.radius); if (distSq < radiiSumSq) { return solid; } } } } return null;
}

// --- Initialization ---
function createWalls() { walls = []; const WALL_COLOR = 'rgba(60, 40, 30, 0.8)'; const addWall = (id, x, y, width, height) => { walls.push({ id, x, y, width, height, color: WALL_COLOR, isWall: true }); solidObjects.push(walls[walls.length - 1]); }; addWall('wall_forest_plains', BIOME_BOUNDS.FOREST_X_END - WALL_THICKNESS / 2, BIOME_BOUNDS.FROSTLANDS_Y_END, WALL_THICKNESS, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); addWall('wall_jungle_plains', BIOME_BOUNDS.JUNGLE_X_START - WALL_THICKNESS / 2, BIOME_BOUNDS.FROSTLANDS_Y_END, WALL_THICKNESS, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); addWall('wall_rocky_frost', BIOME_BOUNDS.ROCKY_X_END - WALL_THICKNESS / 2, 0, WALL_THICKNESS, BIOME_BOUNDS.ROCKY_Y_END); addWall('wall_swamp_frost', BIOME_BOUNDS.SWAMP_X_START - WALL_THICKNESS / 2, 0, WALL_THICKNESS, BIOME_BOUNDS.SWAMP_Y_END); addWall('wall_volcano_desert', BIOME_BOUNDS.VOLCANO_X_END - WALL_THICKNESS / 2, BIOME_BOUNDS.VOLCANO_Y_START, WALL_THICKNESS, WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START); addWall('wall_badlands_desert', BIOME_BOUNDS.BADLANDS_X_START - WALL_THICKNESS / 2, BIOME_BOUNDS.BADLANDS_Y_START, WALL_THICKNESS, WORLD_HEIGHT - BIOME_BOUNDS.BADLANDS_Y_START); addWall('wall_frost_plains', BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.FROSTLANDS_Y_END - WALL_THICKNESS / 2, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, WALL_THICKNESS); addWall('wall_desert_plains', BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.DESERT_Y_START - WALL_THICKNESS / 2, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, WALL_THICKNESS); addWall('wall_rocky_forest', 0, BIOME_BOUNDS.ROCKY_Y_END - WALL_THICKNESS / 2, BIOME_BOUNDS.ROCKY_X_END, WALL_THICKNESS); addWall('wall_swamp_jungle', BIOME_BOUNDS.SWAMP_X_START, BIOME_BOUNDS.SWAMP_Y_END - WALL_THICKNESS / 2, WORLD_WIDTH - BIOME_BOUNDS.SWAMP_X_START, WALL_THICKNESS); addWall('wall_volcano_forest', 0, BIOME_BOUNDS.VOLCANO_Y_START - WALL_THICKNESS / 2, BIOME_BOUNDS.VOLCANO_X_END, WALL_THICKNESS); addWall('wall_badlands_jungle', BIOME_BOUNDS.BADLANDS_X_START, BIOME_BOUNDS.BADLANDS_Y_START - WALL_THICKNESS / 2, WORLD_WIDTH - BIOME_BOUNDS.BADLANDS_X_START, WALL_THICKNESS); console.log(`Created ${walls.length} wall segments.`); }
function spawnInitialResources() { resources = []; solidObjects = []; let currentResourceCount = 0; let forestTreeCount = 0; let rockyRockCount = 0; let badlandsBoneTreeCount = 0; let spawnAttempts = 0; const MAX_ATTEMPTS_PER_TYPE = 15000; console.log(`Spawning ${FOREST_TREE_TARGET} trees in Forest...`); spawnAttempts = 0; while (forestTreeCount < FOREST_TREE_TARGET && spawnAttempts < MAX_ATTEMPTS_PER_TYPE * 2) { spawnAttempts++; const x = Math.random() * BIOME_BOUNDS.FOREST_X_END; const y = BIOME_BOUNDS.FROSTLANDS_Y_END + Math.random() * (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); if (getBiomeAt(x, y) !== 'forest') continue; const itemBaseData = ITEM_DATA['tree']; const radius = itemBaseData?.radius || 15; const baseMaxHealth = itemBaseData?.health || 50; const resource = { id: `res_tree_${Date.now()}_${Math.random()}`, x: x, y: y, radius: radius, type: 'tree', color: itemBaseData.color, maxHealth: baseMaxHealth * 2, health: baseMaxHealth * 2, flashUntil: 0, isAttackable: true, isSolid: true, isPlaced: false, variant: null }; if (!checkCollision(resource.radius, resource.x, resource.y, null, solidObjects)) { resources.push(resource); solidObjects.push(resource); forestTreeCount++; currentResourceCount++; } } console.log(`Spawned ${forestTreeCount} forest trees.`); console.log(`Spawning 1500 rocks in Rocky...`); spawnAttempts = 0; count = 0; while (count < 1500 && spawnAttempts < MAX_ATTEMPTS_PER_TYPE * 1.5) { spawnAttempts++; const x = Math.random() * BIOME_BOUNDS.ROCKY_X_END; const y = Math.random() * BIOME_BOUNDS.ROCKY_Y_END; if (getBiomeAt(x, y) !== 'rocky') continue; const itemBaseData = ITEM_DATA['rock']; const radius = itemBaseData?.radius || 12; const baseMaxHealth = itemBaseData?.health || 150; const resource = { id: `res_rock_${Date.now()}_${Math.random()}`, x: x, y: y, radius: radius, type: 'rock', color: itemBaseData.color, maxHealth: baseMaxHealth * 2, health: baseMaxHealth * 2, flashUntil: 0, isAttackable: true, isSolid: true, isPlaced: false }; if (!checkCollision(resource.radius, resource.x, resource.y, null, solidObjects)) { resources.push(resource); solidObjects.push(resource); count++; currentResourceCount++; } } console.log(`Spawned ${count} rocky rocks.`); console.log(`Spawning 300 bone trees in Badlands...`); spawnAttempts = 0; count = 0; while (count < 300 && spawnAttempts < MAX_ATTEMPTS_PER_TYPE) { spawnAttempts++; const x = BIOME_BOUNDS.BADLANDS_X_START + Math.random() * (WORLD_WIDTH - BIOME_BOUNDS.BADLANDS_X_START); const y = BIOME_BOUNDS.BADLANDS_Y_START + Math.random() * (WORLD_HEIGHT - BIOME_BOUNDS.BADLANDS_Y_START); if (getBiomeAt(x, y) !== 'badlands') continue; const itemBaseData = ITEM_DATA['bone_tree']; const radius = itemBaseData?.radius || 13; const baseMaxHealth = itemBaseData?.health || 80; const resource = { id: `res_bonetree_${Date.now()}_${Math.random()}`, x: x, y: y, radius: radius, type: 'bone_tree', color: itemBaseData.color, maxHealth: baseMaxHealth * 2, health: baseMaxHealth * 2, flashUntil: 0, isAttackable: true, isSolid: true, isPlaced: false, variant: 'bone' }; if (!checkCollision(resource.radius, resource.x, resource.y, null, solidObjects)) { resources.push(resource); solidObjects.push(resource); count++; currentResourceCount++; } } console.log(`Spawned ${count} bone trees.`); console.log("Spawning other resources..."); const TARGET_OTHER_RESOURCES = 2000; spawnAttempts = 0; const MAX_OTHER_ATTEMPTS = TARGET_OTHER_RESOURCES * 15; let tempOtherCount = 0; while (tempOtherCount < TARGET_OTHER_RESOURCES && spawnAttempts < MAX_OTHER_ATTEMPTS) { spawnAttempts++; const x = Math.random() * WORLD_WIDTH; const y = Math.random() * WORLD_HEIGHT; const biome = getBiomeAt(x, y); if (biome === 'rocky' || biome === 'badlands' || biome === 'forest') continue; if ((x > JUNGLE_LAKE.x && x < JUNGLE_LAKE.x + JUNGLE_LAKE.width && y > JUNGLE_LAKE.y && y < JUNGLE_LAKE.y + JUNGLE_LAKE.height) || lavaPools.some(p => x > p.x && x < p.x + p.width && y > p.y && y < p.y + p.height) || (x < ISLAND_PADDING / 2 || x > WORLD_WIDTH - ISLAND_PADDING / 2 || y < ISLAND_PADDING / 2 || y > WORLD_HEIGHT - ISLAND_PADDING / 2)) continue; const data = BIOME_DATA[biome]; const multiplier = data.spawnMultiplier || 1; const baseSpawnAttemptChance = 0.05; if (Math.random() > baseSpawnAttemptChance * multiplier) continue; const rand = Math.random(); let resourceType = null; let variant = null; let currentTreeDensity = data.treeDensity; let currentRockDensity = data.rockDensity; let currentCactusDensity = data.cactusDensity; if (biome === 'volcano' || biome === 'swamp') currentTreeDensity = 0; const totalDensity = currentTreeDensity + currentRockDensity + currentCactusDensity; if (totalDensity > 0) { const treeChance = currentTreeDensity / totalDensity; const rockChance = currentRockDensity / totalDensity; if (rand < treeChance) { resourceType = 'tree'; if (biome === 'frostlands') variant = 'snowy'; } else if (rand < treeChance + rockChance) { resourceType = 'rock'; } else if (currentCactusDensity > 0 && biome === 'desert') { resourceType = 'cactus'; } } if (resourceType) { const itemBaseData = ITEM_DATA[resourceType]; const radius = itemBaseData?.radius || (resourceType === 'tree' ? (12 + Math.random() * 6) : (10 + Math.random() * 4)); const baseMaxHealth = itemBaseData?.health || (resourceType === 'tree' ? 50 : 150); const resource = { id: `res_${resourceType}_${Date.now()}_${Math.random()}`, x: x, y: y, radius: radius, type: resourceType, color: itemBaseData.color, maxHealth: baseMaxHealth * 2, health: baseMaxHealth * 2, flashUntil: 0, isAttackable: true, isSolid: true, isPlaced: false, variant: variant }; if (!checkCollision(resource.radius, resource.x, resource.y, null, solidObjects)) { resources.push(resource); solidObjects.push(resource); tempOtherCount++; currentResourceCount++; } } } if (spawnAttempts >= MAX_OTHER_ATTEMPTS) console.warn("Max attempts reached spawning other resources."); console.log(`Total resources spawned: ${currentResourceCount}`); }
function spawnInitialMonsters() { monsters = []; let spawnAttempts = 0; const MAX_SPAWN_ATTEMPTS = INITIAL_MONSTER_COUNT * 5; console.log(`Attempting to spawn exactly ${INITIAL_MONSTER_COUNT} initial monsters...`); let currentMonsterCount = 0; while(currentMonsterCount < INITIAL_MONSTER_COUNT && spawnAttempts < MAX_SPAWN_ATTEMPTS) { spawnAttempts++; const x = Math.random() * WORLD_WIDTH; const y = Math.random() * WORLD_HEIGHT; if ((x > JUNGLE_LAKE.x && x < JUNGLE_LAKE.x + JUNGLE_LAKE.width && y > JUNGLE_LAKE.y && y < JUNGLE_LAKE.y + JUNGLE_LAKE.height) || lavaPools.some(p => x > p.x && x < p.x + p.width && y > p.y && y < p.y + p.height) || (x < ISLAND_PADDING / 2 || x > WORLD_WIDTH - ISLAND_PADDING / 2 || y < ISLAND_PADDING / 2 || y > WORLD_HEIGHT - ISLAND_PADDING / 2) || distanceSq(x, y, player.x, player.y) < (200 * 200) || checkCollision(10, x, y, null, [...solidObjects, ...walls])) { continue; } const baseMonsterHealth = 50; const monster = { id: `mon_${Date.now()}_${Math.random()}`, x: x, y: y, radius: 10 + Math.random() * 5, type: 'slime', color: '#DC143C', maxHealth: baseMonsterHealth * 2, health: baseMonsterHealth * 2, flashUntil: 0, state: 'idle', attackCooldown: MONSTER_ATTACK_COOLDOWN, lastAttackTime: 0, target: null, isAttackable: true, isSolid: false, }; monsters.push(monster); currentMonsterCount++; } if (spawnAttempts >= MAX_SPAWN_ATTEMPTS && currentMonsterCount < INITIAL_MONSTER_COUNT) { console.warn(`Max spawn attempts reached for initial monsters. Spawned: ${currentMonsterCount}`); } console.log(`Spawned ${currentMonsterCount} actual initial monsters.`); }
function spawnBosses() { bosses = []; const baseBossHealth = PLAINS_BOSS_HEALTH; const plainsEdgeBuffer = 50; const spawnX = BIOME_BOUNDS.FOREST_X_END + plainsEdgeBuffer + Math.random() * 100; const spawnY = WORLD_CENTER_Y; const boss = { id: `boss_plains_${Date.now()}`, x: spawnX, y: spawnY, radius: PLAINS_BOSS_RADIUS, type: 'plains_boss', color: '#665A48', angle: 0, maxHealth: baseBossHealth, health: baseBossHealth, flashUntil: 0, state: 'patrolling', attackCooldown: PLAINS_BOSS_ATTACK_COOLDOWN, lastAttackTime: 0, attackTarget: null, speed: PLAINS_BOSS_SPEED, detectRangeSq: PLAINS_BOSS_DETECT_RANGE_SQ, attackRange_hit: BOSS_HIT_RANGE, attackRange_smash: BOSS_SMASH_RANGE, attackRange_spin: BOSS_SPIN_RANGE, patrolTargetX: null, patrolTargetY: null, attackAnimationTimer: 0, attackChoiceCooldown: PLAINS_BOSS_ATTACK_CHOICE_COOLDOWN, lastAttackChoiceTime: 0, currentAttack: null, smashLanded: false, lastSpinDamageTime: 0, isAttackable: true, isSolid: true, isPlaced: false, isBoss: true }; bosses.push(boss); solidObjects.push(boss); console.log("Spawned Plains Boss at", Math.round(spawnX), Math.round(spawnY)); }

// --- Input Handling ---
document.addEventListener('keydown', (event) => { if (isGameOver) return; const key = event.key.toLowerCase(); if (key === 'e') { toggleCraftingMenu(); keysPressed[key] = false; return; } if (key === 'escape') { if (isCraftingMenuOpen) { toggleCraftingMenu(); } keysPressed[key] = false; return; } if (isCraftingMenuOpen) return; keysPressed[key] = true; if (!isNaN(parseInt(key)) && parseInt(key) >= 1 && parseInt(key) <= HOTBAR_SIZE) { selectHotbar(parseInt(key) - 1); } });
document.addEventListener('keyup', (event) => { keysPressed[event.key.toLowerCase()] = false; });
canvas.addEventListener('mousemove', (event) => { if (isGameOver) return; const rect = canvas.getBoundingClientRect(); mouseCanvasX = event.clientX - rect.left; mouseCanvasY = event.clientY - rect.top; const worldCoords = canvasToWorld(mouseCanvasX, mouseCanvasY); worldMouseX = worldCoords.x; worldMouseY = worldCoords.y; });
canvas.addEventListener('mousedown', (event) => { if (isGameOver || isCraftingMenuOpen) return; if (event.button === 0) { if (!player.isAttacking && !player.isInteracting) { player.isAttacking = true; player.attackTimer = Date.now(); tryAttack(); } } else if (event.button === 2) { if (!player.isInteracting && !player.isAttacking) { player.isInteracting = true; player.interactTimer = Date.now(); tryInteract(); } } });
closeCraftingButton.addEventListener('click', () => { if (player.selectedInventoryItem) { player.selectedInventoryItem = null; } if (selectedUpgradeInput.slotIndex !== -1) selectedUpgradeInput = { slotIndex: -1, source: null }; toggleCraftingMenu(); });
canvas.addEventListener('contextmenu', (event) => event.preventDefault());

// --- Action Functions ---
function findNearestObject(x, y, rangeSq, filterFn = () => true) { let closestObject = null; let minDistanceSq = rangeSq; for (const obj of solidObjects) { if (obj.isPlaced && filterFn(obj)) { const distSq = distanceSq(x, y, obj.x, obj.y); if (distSq < minDistanceSq && distSq < (obj.radius + PLAYER_RADIUS) * (obj.radius + PLAYER_RADIUS)) { minDistanceSq = distSq; closestObject = obj; } } } return closestObject; }
function decrementHotbarItem(index) { const slot = player.hotbarSlots[index]; if (!slot) return false; slot.count--; if (slot.count <= 0) { player.hotbarSlots[index] = null; } updateMainHotbarVisuals(); updateEquippedItem(); if (isCraftingMenuOpen) { populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } return true; }
function tryAttack() { let bestTarget = null; let minTargetDistSq = (ATTACK_RANGE + player.radius) * (ATTACK_RANGE + player.radius); const attackables = [...monsters, ...resources, ...bosses]; const attackCheckX = player.x + Math.cos(player.angle) * (player.radius); const attackCheckY = player.y + Math.sin(player.angle) * (player.radius); for (const target of attackables) { if (!target || target.health <= 0) continue; const distSq = distanceSq(attackCheckX, attackCheckY, target.x, target.y); if (distSq < minTargetDistSq && distSq < (target.radius + ATTACK_RANGE) * (target.radius + ATTACK_RANGE) ) { const angleToTarget = Math.atan2(target.y - player.y, target.x - player.x); const angleDiff = Math.abs(normalizeAngle(player.angle - angleToTarget)); if (angleDiff < ATTACK_SWING_ARC / 2 + 0.5) { minTargetDistSq = distSq; bestTarget = target; } } } if (bestTarget) { bestTarget.flashUntil = Date.now() + FLASH_DURATION; let damageDealt = 0; const equippedItemSlot = player.hotbarSlots[player.selectedHotbarSlotIndex]; const equippedItemType = equippedItemSlot ? equippedItemSlot.type : null; const equippedItemData = equippedItemType ? ITEM_DATA[equippedItemType] : null; const targetIsMonster = monsters.some(m => m.id === bestTarget.id); const targetIsBoss = bosses.some(b => b.id === bestTarget.id); const targetIsTree = bestTarget.type === 'tree'; const targetIsRock = bestTarget.type === 'rock'; const targetIsCactus = bestTarget.type === 'cactus'; const targetIsBoneTree = bestTarget.type === 'bone_tree'; const targetIsPlaced = bestTarget.isPlaced; if (equippedItemData && equippedItemData.type === 'tool') { if ((targetIsMonster || targetIsBoss) && equippedItemData.toolType === 'sword') { damageDealt = BASE_ATTACK_POWER * equippedItemData.damageMultiplier; } else if ((targetIsTree || targetIsBoneTree) && equippedItemData.toolType === 'axe') { damageDealt = BASE_GATHER_POWER * equippedItemData.gatherMultiplier; } else if (targetIsRock && equippedItemData.toolType === 'pickaxe') { damageDealt = BASE_GATHER_POWER * equippedItemData.gatherMultiplier; } else if (targetIsCactus && equippedItemData.toolType === 'axe') { damageDealt = BASE_GATHER_POWER * equippedItemData.gatherMultiplier; } else if (targetIsPlaced && (equippedItemData.toolType === 'axe' || equippedItemData.toolType === 'pickaxe')) { damageDealt = BASE_GATHER_POWER * 2.0; } else { damageDealt = BASE_ATTACK_POWER / 2; } } else { damageDealt = (targetIsMonster || targetIsBoss) ? BASE_ATTACK_POWER : BASE_GATHER_POWER; } bestTarget.health -= damageDealt; if (bestTarget.health <= 0) { console.log(`%cDestroyed ${bestTarget.type}!`, 'color: orange; font-weight: bold;'); const dropX = bestTarget.x; const dropY = bestTarget.y; let itemsToDrop = []; if (targetIsTree) { itemsToDrop.push({ type: 'wood', count: 1 + Math.floor(Math.random() * 3) }); if (Math.random() < 0.2) itemsToDrop.push({ type: 'plant_fiber', count: 1 }); } else if (targetIsRock) { itemsToDrop.push({ type: 'stone', count: 1 + Math.floor(Math.random() * 2) }); } else if (targetIsCactus) { itemsToDrop.push({ type: 'plant_fiber', count: 1 + Math.floor(Math.random()*2)}); } else if (targetIsBoneTree) { itemsToDrop.push({ type: 'dust', count: 1 + Math.floor(Math.random() * 3) }); if (Math.random() < 0.02) { itemsToDrop.push({ type: 'bone_scythe', count: 1 }); console.log("%cDropped Bone Scythe!", "color: magenta; font-weight:bold;"); } } else if (targetIsMonster) { itemsToDrop.push({ type: 'monster_goop', count: 1 + Math.floor(Math.random() * 4) }); if (Math.random() < GOLD_COIN_DROP_CHANCE) { itemsToDrop.push({ type: 'gold_coin', count: 1 }); console.log("%cDropped Gold Coin!", "color: gold; font-weight:bold;"); } if (Math.random() < 0.02) itemsToDrop.push({ type: 'healing_salve', count: 1}); } else if (targetIsBoss) { console.log("Plains Boss Defeated! Dropping loot..."); itemsToDrop.push({ type: 'gold_coin', count: 10 + Math.floor(Math.random() * 16) }); itemsToDrop.push({ type: 'stone', count: 5 + Math.floor(Math.random() * 11) }); itemsToDrop.push({ type: 'wood', count: 5 + Math.floor(Math.random() * 11) }); itemsToDrop.push({ type: 'wooden_bow', count: 1 }); if (Math.random() < 0.1) { itemsToDrop.push({ type: 'healing_salve', count: 2 }); } } else if (targetIsPlaced) { itemsToDrop.push({ type: bestTarget.type, count: 1}); } itemsToDrop.forEach(drop => { addDroppedItem(dropX, dropY, drop.type, drop.count); }); if (bestTarget.isSolid) { solidObjects = solidObjects.filter(s => s.id !== bestTarget.id); } if (targetIsMonster) { monsters = monsters.filter(m => m.id !== bestTarget.id); } else if (targetIsBoss) { bosses = bosses.filter(b => b.id !== bestTarget.id); } else { resources = resources.filter(r => r.id !== bestTarget.id); } } } }
function tryInteract() { const equippedItem = player.hotbarSlots[player.selectedHotbarSlotIndex]; const itemType = equippedItem ? equippedItem.type : null; const itemData = itemType ? ITEM_DATA[itemType] : null; if (equippedItem && itemData && itemData.isUsable) { if (itemType === 'healing_salve') { if (player.health < PLAYER_MAX_HEALTH) { player.health += HEAL_AMOUNT; player.health = Math.min(player.health, PLAYER_MAX_HEALTH); decrementHotbarItem(player.selectedHotbarSlotIndex); return; } else { return; } } return; } const nearbyInteractable = findNearestObject(player.x, player.y, INTERACT_RANGE_SQ, (obj) => ITEM_DATA[obj.type]?.isInteractable); if (nearbyInteractable) { if (nearbyInteractable.type === 'icky_bed') { player.respawnX = nearbyInteractable.x; player.respawnY = nearbyInteractable.y; console.log(`%cSpawn point set!`, 'color: yellow;'); nearbyInteractable.flashUntil = Date.now() + 200; return; } /* Removed upgrader RMB interaction */ return; } if (equippedItem && itemData && itemData.isPlaceable) { const gridX = Math.round(worldMouseX / PLACE_GRID_SIZE) * PLACE_GRID_SIZE; const gridY = Math.round(worldMouseY / PLACE_GRID_SIZE) * PLACE_GRID_SIZE; if (distanceSq(player.x, player.y, gridX, gridY) > PLACE_RANGE_SQ) { return; } const collisionRadius = itemData.solidRadius || PLACE_GRID_SIZE / 2; if (checkCollision(collisionRadius, gridX, gridY)) { return; } if (distanceSq(player.x, player.y, gridX, gridY) < (player.radius + collisionRadius) * (player.radius + collisionRadius)) { return; } const placedObject = { id: `placed_${Date.now()}_${Math.random()}`, x: gridX, y: gridY, radius: collisionRadius, type: itemType, color: itemData.color, maxHealth: itemData.health || 100, health: itemData.health || 100, flashUntil: 0, isAttackable: true, isSolid: true, isPlaced: true, lightRadius: itemData.lightRadius || 0, isInteractable: itemData.isInteractable || false }; resources.push(placedObject); solidObjects.push(placedObject); decrementHotbarItem(player.selectedHotbarSlotIndex); return; } }
function selectHotbar(index) { if (index < 0 || index >= HOTBAR_SIZE) return; player.selectedHotbarSlotIndex = index; mainHotbarSlots.forEach((slot, i) => { slot.classList.toggle('selected', i === index); }); updateEquippedItem(); }
function updateEquippedItem() { const equippedSlotContent = player.hotbarSlots[player.selectedHotbarSlotIndex]; player.equippedItemType = equippedSlotContent ? equippedSlotContent.type : null; }

// --- Item Upgrader UI Functions ---
// (populateUpgraderUI, handleUpgraderInputClick, doUpgrade) - These are now called within populateCraftingMenu/toggleCraftingMenu/event listeners

// --- Update Functions ---
function updatePlayer(deltaTime) { if (isGameOver || isCraftingMenuOpen ) return; let dx = 0; let dy = 0; if (keysPressed['w']) dy -= 1; if (keysPressed['s']) dy += 1; if (keysPressed['a']) dx -= 1; if (keysPressed['d']) dx += 1; const magnitude = Math.sqrt(dx * dx + dy * dy); if (magnitude > 0) { dx = (dx / magnitude) * PLAYER_SPEED; dy = (dy / magnitude) * PLAYER_SPEED; } else { dx = 0; dy = 0; } let potentialX = player.x + dx; let potentialY = player.y + dy; let collidedWith = checkCollision(player.radius, potentialX, potentialY, player.id, [...solidObjects, ...monsters, ...bosses]); if (dx !== 0 && collidedWith) { potentialX = player.x; dx = 0; } collidedWith = checkCollision(player.radius, potentialX, potentialY, player.id, [...solidObjects, ...monsters, ...bosses]); if (dy !== 0 && collidedWith) { potentialY = player.y; dy = 0; } player.x = potentialX; player.y = potentialY; player.x = Math.max(player.radius, Math.min(WORLD_WIDTH - player.radius, player.x)); player.y = Math.max(player.radius, Math.min(WORLD_HEIGHT - player.radius, player.y)); for (let i = droppedItems.length - 1; i >= 0; i--) { const item = droppedItems[i]; const distSq = distanceSq(player.x, player.y, item.x, item.y); if (distSq < ITEM_PICKUP_RANGE_SQ) { addToInventory(item.type, 1); droppedItems.splice(i, 1); } } const aimDx = worldMouseX - player.x; const aimDy = worldMouseY - player.y; player.angle = Math.atan2(aimDy, aimDx); const now = Date.now(); if (player.isAttacking && now - player.attackTimer > ATTACK_DURATION) { player.isAttacking = false; } if (player.isInteracting && now - player.interactTimer > INTERACT_DURATION) { player.isInteracting = false;} if (player.health <= 0 && !isGameOver) { isGameOver = true; console.error("Player Died! Respawning..."); deathMessageDiv.style.display = 'block'; const deathX = player.x; const deathY = player.y; setTimeout(() => { const allSlots = [...player.inventorySlots.map((item, index) => item ? { item, index, source: 'inventory' } : null), ...player.hotbarSlots.map((item, index) => item ? { item, index, source: 'hotbar' } : null)].filter(Boolean); if (allSlots.length > 0) { const randomIndex = Math.floor(Math.random() * allSlots.length); const slotToDropFrom = allSlots[randomIndex]; const droppedItem = slotToDropFrom.item; if (droppedItem) { console.log(`%cDropping ${droppedItem.count}x ${droppedItem.type} from ${slotToDropFrom.source} slot ${slotToDropFrom.index} on death!`, "color: orange"); addDroppedItem(deathX, deathY, droppedItem.type, droppedItem.count); if (slotToDropFrom.source === 'inventory') { player.inventorySlots[slotToDropFrom.index] = null; } else { player.hotbarSlots[slotToDropFrom.index] = null; } if (isCraftingMenuOpen) { populateCraftingMenu(isNearWorkbench(), isNearUpgrader()); } updateMainHotbarVisuals(); } } player.health = PLAYER_MAX_HEALTH; player.x = player.respawnX; player.y = player.respawnY; player.isAttacking = false; player.isInteracting = false; clampCamera(); updateUI(); deathMessageDiv.style.display = 'none'; isGameOver = false; }, 2000); } }
function updateMonsters(deltaTime) { if (isGameOver || isCraftingMenuOpen ) return; const now = Date.now(); monsters.forEach(monster => { if (monster.health <= 0) return; const distToPlayerSq = distanceSq(monster.x, monster.y, player.x, player.y); const angleToPlayer = Math.atan2(player.y - monster.y, player.x - monster.x); if (distToPlayerSq > MONSTER_DETECT_RANGE * MONSTER_DETECT_RANGE) { monster.state = 'idle'; monster.target = null; } else if (distToPlayerSq <= MONSTER_ATTACK_RANGE * MONSTER_ATTACK_RANGE) { monster.state = 'attacking'; monster.target = player; } else { monster.state = 'chasing'; monster.target = player; } let dx = 0; let dy = 0; if (monster.state === 'chasing') { dx = Math.cos(angleToPlayer) * MONSTER_SPEED; dy = Math.sin(angleToPlayer) * MONSTER_SPEED; } if (dx !== 0 || dy !== 0) { let potentialX = monster.x + dx; let potentialY = monster.y + dy; let collidedWith = checkCollision(monster.radius, potentialX, potentialY, monster.id, [...solidObjects, ...monsters, ...bosses, player]); if (!collidedWith) { monster.x = potentialX; monster.y = potentialY; } else { potentialX = monster.x + dx; potentialY = monster.y; collidedWith = checkCollision(monster.radius, potentialX, potentialY, monster.id, [...solidObjects, ...monsters, ...bosses, player]); if (!collidedWith) { monster.x = potentialX; } else { potentialX = monster.x; potentialY = monster.y + dy; collidedWith = checkCollision(monster.radius, potentialX, potentialY, monster.id, [...solidObjects, ...monsters, ...bosses, player]); if (!collidedWith) { monster.y = potentialY; } } } } if (monster.state === 'attacking') { if (now - monster.lastAttackTime > monster.attackCooldown) { player.health -= MONSTER_DAMAGE; player.health = Math.max(0, player.health); monster.lastAttackTime = now; document.getElementById('gameContainer').style.boxShadow = 'inset 0 0 30px 10px rgba(255,0,0,0.5)'; setTimeout(()=> { document.getElementById('gameContainer').style.boxShadow = ''; }, 150); } } monster.x = Math.max(monster.radius, Math.min(WORLD_WIDTH - monster.radius, monster.x)); monster.y = Math.max(monster.radius, Math.min(WORLD_HEIGHT - monster.radius, monster.y)); }); }
function updateBosses(deltaTime) { if (isGameOver || isCraftingMenuOpen ) return; const now = Date.now(); bosses.forEach(boss => { if (boss.health <= 0) return; const distToPlayerSq = distanceSq(boss.x, boss.y, player.x, player.y); const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x); switch(boss.state) { case 'patrolling': if (distToPlayerSq < boss.detectRangeSq) { boss.state = 'chasing'; boss.attackTarget = player; break; } if (boss.patrolTargetX === null || distanceSq(boss.x, boss.y, boss.patrolTargetX, boss.patrolTargetY) < 50*50) { const edgeChoice = Math.random(); let px, py; if (edgeChoice < 0.25) { px = BIOME_BOUNDS.FOREST_X_END + Math.random() * (BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END); py = BIOME_BOUNDS.FROSTLANDS_Y_END - 30 - Math.random()*50; } else if (edgeChoice < 0.5) { px = BIOME_BOUNDS.FOREST_X_END + Math.random() * (BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END); py = BIOME_BOUNDS.DESERT_Y_START + 30 + Math.random()*50; } else if (edgeChoice < 0.75) { px = BIOME_BOUNDS.FOREST_X_END - 30 - Math.random()*50; py = BIOME_BOUNDS.FROSTLANDS_Y_END + Math.random() * (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); } else { px = BIOME_BOUNDS.JUNGLE_X_START + 30 + Math.random()*50; py = BIOME_BOUNDS.FROSTLANDS_Y_END + Math.random() * (BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); } boss.patrolTargetX = Math.max(0, Math.min(WORLD_WIDTH, px)); boss.patrolTargetY = Math.max(0, Math.min(WORLD_HEIGHT, py)); } if (boss.patrolTargetX !== null) { const angleToTarget = Math.atan2(boss.patrolTargetY - boss.y, boss.patrolTargetX - boss.x); boss.angle = angleToTarget; let dx = Math.cos(boss.angle) * boss.speed; let dy = Math.sin(boss.angle) * boss.speed; let potentialX = boss.x + dx; let potentialY = boss.y + dy; let collidedWith = checkCollision(boss.radius, potentialX, potentialY, boss.id, [...solidObjects, ...bosses, ...monsters, player]); if (!collidedWith) { boss.x = potentialX; boss.y = potentialY; } else { potentialX = boss.x + dx; potentialY = boss.y; collidedWith = checkCollision(boss.radius, potentialX, potentialY, boss.id, [...solidObjects, ...bosses, ...monsters, player]); if (!collidedWith) { boss.x = potentialX; } else { potentialX = boss.x; potentialY = boss.y + dy; collidedWith = checkCollision(boss.radius, potentialX, potentialY, boss.id, [...solidObjects, ...bosses, ...monsters, player]); if (!collidedWith) { boss.y = potentialY; }} } } break; case 'chasing': if (distToPlayerSq > boss.detectRangeSq * 1.5) { boss.state = 'patrolling'; boss.attackTarget = null; boss.patrolTargetX = null; break; } boss.angle = angleToPlayer; if (now - boss.lastAttackChoiceTime > boss.attackChoiceCooldown && now - boss.lastAttackTime > boss.attackCooldown) { boss.lastAttackChoiceTime = now; let possibleAttacks = []; if (distToPlayerSq < boss.attackRange_hit * boss.attackRange_hit) possibleAttacks.push('hit'); if (distToPlayerSq < boss.attackRange_smash * boss.attackRange_smash) possibleAttacks.push('smash'); if (distToPlayerSq < boss.attackRange_spin * boss.attackRange_spin) possibleAttacks.push('spin'); if (possibleAttacks.length > 0) { boss.currentAttack = possibleAttacks[Math.floor(Math.random() * possibleAttacks.length)]; console.log("Boss chose attack:", boss.currentAttack); boss.state = `attacking_${boss.currentAttack}`; boss.attackAnimationTimer = 0; boss.lastAttackTime = now; if(boss.currentAttack === 'smash') boss.smashLanded = false; if(boss.currentAttack === 'spin') boss.lastSpinDamageTime = 0; } } if (!boss.state.startsWith('attacking')) { let dx = Math.cos(boss.angle) * boss.speed; let dy = Math.sin(boss.angle) * boss.speed; let potentialX = boss.x + dx; let potentialY = boss.y + dy; let collidedWith = checkCollision(boss.radius, potentialX, potentialY, boss.id, [...solidObjects, ...bosses, ...monsters, player]); if (!collidedWith) { boss.x = potentialX; boss.y = potentialY; } else { potentialX = boss.x + dx; potentialY = boss.y; collidedWith = checkCollision(boss.radius, potentialX, potentialY, boss.id, [...solidObjects, ...bosses, ...monsters, player]); if (!collidedWith) { boss.x = potentialX; } else { potentialX = boss.x; potentialY = boss.y + dy; collidedWith = checkCollision(boss.radius, potentialX, potentialY, boss.id, [...solidObjects, ...bosses, ...monsters, player]); if (!collidedWith) { boss.y = potentialY; }} } } break; case 'attacking_hit': boss.angle = angleToPlayer; boss.attackAnimationTimer += deltaTime; if (boss.attackAnimationTimer >= ATTACK_DURATION / 2 && boss.attackAnimationTimer < ATTACK_DURATION) { if (distToPlayerSq < boss.attackRange_hit * boss.attackRange_hit) { player.health = Math.max(0, player.health - BOSS_HIT_DAMAGE); } boss.attackAnimationTimer = ATTACK_DURATION; } if (boss.attackAnimationTimer >= ATTACK_DURATION) { boss.state = 'chasing'; } break; case 'attacking_smash': boss.angle = angleToPlayer; boss.attackAnimationTimer += deltaTime; if (boss.attackAnimationTimer >= BOSS_SMASH_WINDUP && !boss.smashLanded) { boss.smashLanded = true; if (distToPlayerSq < BOSS_SMASH_RANGE * BOSS_SMASH_RANGE) { player.health = Math.max(0, player.health - BOSS_SMASH_DAMAGE); } } if (boss.attackAnimationTimer >= BOSS_SMASH_WINDUP + BOSS_SMASH_EFFECT_DURATION) { boss.state = 'chasing'; } break; case 'attacking_spin': boss.angle = angleToPlayer; boss.attackAnimationTimer += deltaTime; if (now - boss.lastSpinDamageTime > BOSS_SPIN_DAMAGE_INTERVAL) { if (distToPlayerSq < boss.attackRange_spin * boss.attackRange_spin) { player.health = Math.max(0, player.health - BOSS_SPIN_DAMAGE); } boss.lastSpinDamageTime = now; } if (boss.attackAnimationTimer >= BOSS_SPIN_DURATION) { boss.state = 'chasing'; } break; } boss.x = Math.max(boss.radius, Math.min(WORLD_WIDTH - boss.radius, boss.x)); boss.y = Math.max(boss.radius, Math.min(WORLD_HEIGHT - boss.radius, boss.y)); }); }
function updateWorld(deltaTime) {
    if (isGameOver || isCraftingMenuOpen || isUpgraderUIOpen ) return;
    gameTime += deltaTime; const cycleTime = gameTime % DAY_LENGTH; const cyclePercent = cycleTime / DAY_LENGTH; const newDayCount = Math.floor(gameTime / DAY_LENGTH) + 1; if (newDayCount > dayCount) { dayCount = newDayCount; console.log(`Starting Day ${dayCount}`); } const wasNight = isNight; let targetOpacity = 0; let currentPhase = "Day"; let timeUntilNextPhase = 0; const transitionDuration = TRANSITION_DURATION_PERCENT * DAY_LENGTH; let nextPhaseStartTimePercent = SUNSET_START_PERCENT;
    if (cyclePercent >= 0 && cyclePercent < SUNSET_START_PERCENT) { isNight = false; currentPhase = "Day"; targetOpacity = 0; nextPhaseStartTimePercent = SUNSET_START_PERCENT; }
    else if (cyclePercent >= SUNSET_START_PERCENT && cyclePercent < NIGHT_START_PERCENT) { isNight = true; currentPhase = "Sunset"; const transitionProgress = (cyclePercent - SUNSET_START_PERCENT) / TRANSITION_DURATION_PERCENT; targetOpacity = transitionProgress * MAX_NIGHT_OPACITY; nextPhaseStartTimePercent = NIGHT_START_PERCENT; }
    else if (cyclePercent >= NIGHT_START_PERCENT && cyclePercent < SUNRISE_START_PERCENT) { isNight = true; currentPhase = "Night"; targetOpacity = MAX_NIGHT_OPACITY; nextPhaseStartTimePercent = SUNRISE_START_PERCENT; }
    else { isNight = false; currentPhase = "Sunrise"; const transitionProgress = (cyclePercent - SUNRISE_START_PERCENT) / TRANSITION_DURATION_PERCENT; targetOpacity = (1 - transitionProgress) * MAX_NIGHT_OPACITY; nextPhaseStartTimePercent = 1.0; }
    timeUntilNextPhase = (nextPhaseStartTimePercent * DAY_LENGTH) - cycleTime; if (nextPhaseStartTimePercent === 1.0) { timeUntilNextPhase = DAY_LENGTH - cycleTime; } else if (timeUntilNextPhase < -10) { timeUntilNextPhase += DAY_LENGTH; }
    if (Math.abs(currentNightOpacity - targetOpacity) > 0.005) { const opacityChangeSpeed = deltaTime / (transitionDuration / 2); if (currentNightOpacity < targetOpacity) { currentNightOpacity = Math.min(currentNightOpacity + opacityChangeSpeed, targetOpacity); } else if (currentNightOpacity > targetOpacity) { currentNightOpacity = Math.max(currentNightOpacity - opacityChangeSpeed, targetOpacity); } } else { currentNightOpacity = targetOpacity; } currentNightOpacity = Math.max(0, Math.min(MAX_NIGHT_OPACITY, currentNightOpacity));
    if (timeUIDiv) { timeUIDiv.innerHTML = `<span>Phase: ${currentPhase}</span><br><span>~ Left: ${formatTime(timeUntilNextPhase)}</span>`; }
    if (isNight && !wasNight) { console.log("Night begins! Spawning monsters..."); const currentMonsterCount = monsters.length; const spaceAvailable = MAX_MONSTER_COUNT - currentMonsterCount; const slimesToSpawn = Math.min(NIGHTLY_MONSTER_SPAWN_COUNT, spaceAvailable); if (slimesToSpawn > 0) { const landWidth = WORLD_WIDTH - ISLAND_PADDING * 2; const landHeight = WORLD_HEIGHT - ISLAND_PADDING * 2; const baseMonsterHealth = 50; let spawnedCount = 0; let nightSpawnAttempts = 0; const MAX_NIGHT_ATTEMPTS = slimesToSpawn * 5; while (spawnedCount < slimesToSpawn && nightSpawnAttempts < MAX_NIGHT_ATTEMPTS) { nightSpawnAttempts++; const spawnX = Math.random() * WORLD_WIDTH; const spawnY = Math.random() * WORLD_HEIGHT; if ((spawnX > JUNGLE_LAKE.x && spawnX < JUNGLE_LAKE.x + JUNGLE_LAKE.width && spawnY > JUNGLE_LAKE.y && spawnY < JUNGLE_LAKE.y + JUNGLE_LAKE.height) || lavaPools.some(p => spawnX > p.x && spawnX < p.x + p.width && spawnY > p.y && spawnY < p.y + p.height) || (spawnX < ISLAND_PADDING / 2 || spawnX > WORLD_WIDTH - ISLAND_PADDING / 2 || spawnY < ISLAND_PADDING / 2 || spawnY > WORLD_HEIGHT - ISLAND_PADDING / 2)) { continue; } const monster = { id: `mon_${Date.now()}_${Math.random()}`, x: spawnX, y: spawnY, radius: 10 + Math.random() * 5, type: 'slime', color: '#DC143C', maxHealth: baseMonsterHealth * 2, health: baseMonsterHealth * 2, flashUntil: 0, state: 'idle', attackCooldown: MONSTER_ATTACK_COOLDOWN, lastAttackTime: 0, target: null, isAttackable: true, isSolid: false, }; monsters.push(monster); spawnedCount++; } if(nightSpawnAttempts >= MAX_NIGHT_ATTEMPTS) console.warn("Max spawn attempts reached for nightly spawn."); console.log(`Spawned ${spawnedCount} new slimes. Total: ${monsters.length}`); } } else if (!isNight && wasNight) { /* console.log("Day begins!"); */ }
}
function updateUI() { healthValueSpan.textContent = Math.floor(player.health); hungerValueSpan.textContent = Math.floor(player.hunger); dayValueSpan.textContent = dayCount; debugDiv.textContent = `World: (${Math.round(player.x)}, ${Math.round(player.y)}) | Mouse: (${Math.round(worldMouseX)}, ${Math.round(worldMouseY)}) | Res: ${resources.length} | Mon: ${monsters.length} | Items: ${droppedItems.length}`; }
function update(deltaTime) { if (isGameOver) return; if (!deltaTime) return; updatePlayer(deltaTime); updateMonsters(deltaTime); updateBosses(deltaTime); updateWorld(deltaTime); clampCamera(); updateUI(); }

// --- Draw Functions ---
function drawWorldBackground() { ctx.save(); ctx.fillStyle = BIOME_DATA.desert.color; ctx.fillRect(0, BIOME_BOUNDS.DESERT_Y_START, WORLD_WIDTH, WORLD_HEIGHT - BIOME_BOUNDS.DESERT_Y_START); ctx.fillStyle = BIOME_DATA.frostlands.color; ctx.fillRect(0, 0, WORLD_WIDTH, BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle = BIOME_DATA.forest.color; ctx.fillRect(0, BIOME_BOUNDS.FROSTLANDS_Y_END, BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle = BIOME_DATA.jungle.color; ctx.fillRect(BIOME_BOUNDS.JUNGLE_X_START, BIOME_BOUNDS.FROSTLANDS_Y_END, WORLD_WIDTH - BIOME_BOUNDS.JUNGLE_X_START, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle = BIOME_DATA.rocky.color; ctx.fillRect(0, 0, BIOME_BOUNDS.ROCKY_X_END, BIOME_BOUNDS.ROCKY_Y_END); ctx.fillStyle = BIOME_DATA.swamp.color; ctx.fillRect(BIOME_BOUNDS.SWAMP_X_START, 0, WORLD_WIDTH - BIOME_BOUNDS.SWAMP_X_START, BIOME_BOUNDS.SWAMP_Y_END); ctx.fillStyle = BIOME_DATA.volcano.color; ctx.fillRect(0, BIOME_BOUNDS.VOLCANO_Y_START, BIOME_BOUNDS.VOLCANO_X_END, WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START); ctx.fillStyle = BIOME_DATA.badlands.color; ctx.fillRect(BIOME_BOUNDS.BADLANDS_X_START, BIOME_BOUNDS.BADLANDS_Y_START, WORLD_WIDTH - BIOME_BOUNDS.BADLANDS_X_START, WORLD_HEIGHT - BIOME_BOUNDS.BADLANDS_Y_START); ctx.fillStyle = BIOME_DATA.plains.color; ctx.fillRect(BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.FROSTLANDS_Y_END, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillStyle = JUNGLE_LAKE.color; ctx.fillRect(JUNGLE_LAKE.x, JUNGLE_LAKE.y, JUNGLE_LAKE.width, JUNGLE_LAKE.height); lavaPools.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.width, p.height); }); ctx.restore(); }
const WALL_THICKNESS = 15; const WALL_COLOR = 'rgba(60, 40, 30, 0.8)';
function drawBiomeWalls() { ctx.save(); ctx.fillStyle = WALL_COLOR; ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2; ctx.fillRect(BIOME_BOUNDS.FOREST_X_END - WALL_THICKNESS / 2, BIOME_BOUNDS.FROSTLANDS_Y_END, WALL_THICKNESS, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.strokeRect(BIOME_BOUNDS.FOREST_X_END - WALL_THICKNESS / 2, BIOME_BOUNDS.FROSTLANDS_Y_END, WALL_THICKNESS, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillRect(BIOME_BOUNDS.JUNGLE_X_START - WALL_THICKNESS / 2, BIOME_BOUNDS.FROSTLANDS_Y_END, WALL_THICKNESS, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.strokeRect(BIOME_BOUNDS.JUNGLE_X_START - WALL_THICKNESS / 2, BIOME_BOUNDS.FROSTLANDS_Y_END, WALL_THICKNESS, BIOME_BOUNDS.DESERT_Y_START - BIOME_BOUNDS.FROSTLANDS_Y_END); ctx.fillRect(BIOME_BOUNDS.ROCKY_X_END - WALL_THICKNESS / 2, 0, WALL_THICKNESS, BIOME_BOUNDS.ROCKY_Y_END); ctx.strokeRect(BIOME_BOUNDS.ROCKY_X_END - WALL_THICKNESS / 2, 0, WALL_THICKNESS, BIOME_BOUNDS.ROCKY_Y_END); ctx.fillRect(BIOME_BOUNDS.SWAMP_X_START - WALL_THICKNESS / 2, 0, WALL_THICKNESS, BIOME_BOUNDS.SWAMP_Y_END); ctx.strokeRect(BIOME_BOUNDS.SWAMP_X_START - WALL_THICKNESS / 2, 0, WALL_THICKNESS, BIOME_BOUNDS.SWAMP_Y_END); ctx.fillRect(BIOME_BOUNDS.VOLCANO_X_END - WALL_THICKNESS / 2, BIOME_BOUNDS.VOLCANO_Y_START, WALL_THICKNESS, WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START); ctx.strokeRect(BIOME_BOUNDS.VOLCANO_X_END - WALL_THICKNESS / 2, BIOME_BOUNDS.VOLCANO_Y_START, WALL_THICKNESS, WORLD_HEIGHT - BIOME_BOUNDS.VOLCANO_Y_START); ctx.fillRect(BIOME_BOUNDS.BADLANDS_X_START - WALL_THICKNESS / 2, BIOME_BOUNDS.BADLANDS_Y_START, WALL_THICKNESS, WORLD_HEIGHT - BIOME_BOUNDS.BADLANDS_Y_START); ctx.strokeRect(BIOME_BOUNDS.BADLANDS_X_START - WALL_THICKNESS / 2, BIOME_BOUNDS.BADLANDS_Y_START, WALL_THICKNESS, WORLD_HEIGHT - BIOME_BOUNDS.BADLANDS_Y_START); ctx.fillRect(BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.FROSTLANDS_Y_END - WALL_THICKNESS / 2, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, WALL_THICKNESS); ctx.strokeRect(BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.FROSTLANDS_Y_END - WALL_THICKNESS / 2, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, WALL_THICKNESS); ctx.fillRect(BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.DESERT_Y_START - WALL_THICKNESS / 2, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, WALL_THICKNESS); ctx.strokeRect(BIOME_BOUNDS.FOREST_X_END, BIOME_BOUNDS.DESERT_Y_START - WALL_THICKNESS / 2, BIOME_BOUNDS.JUNGLE_X_START - BIOME_BOUNDS.FOREST_X_END, WALL_THICKNESS); ctx.fillRect(0, BIOME_BOUNDS.ROCKY_Y_END - WALL_THICKNESS / 2, BIOME_BOUNDS.ROCKY_X_END, WALL_THICKNESS); ctx.strokeRect(0, BIOME_BOUNDS.ROCKY_Y_END - WALL_THICKNESS / 2, BIOME_BOUNDS.ROCKY_X_END, WALL_THICKNESS); ctx.fillRect(BIOME_BOUNDS.SWAMP_X_START, BIOME_BOUNDS.SWAMP_Y_END - WALL_THICKNESS / 2, WORLD_WIDTH - BIOME_BOUNDS.SWAMP_X_START, WALL_THICKNESS); ctx.strokeRect(BIOME_BOUNDS.SWAMP_X_START, BIOME_BOUNDS.SWAMP_Y_END - WALL_THICKNESS / 2, WORLD_WIDTH - BIOME_BOUNDS.SWAMP_X_START, WALL_THICKNESS); ctx.fillRect(0, BIOME_BOUNDS.VOLCANO_Y_START - WALL_THICKNESS / 2, BIOME_BOUNDS.VOLCANO_X_END, WALL_THICKNESS); ctx.strokeRect(0, BIOME_BOUNDS.VOLCANO_Y_START - WALL_THICKNESS / 2, BIOME_BOUNDS.VOLCANO_X_END, WALL_THICKNESS); ctx.fillRect(BIOME_BOUNDS.BADLANDS_X_START, BIOME_BOUNDS.BADLANDS_Y_START - WALL_THICKNESS / 2, WORLD_WIDTH - BIOME_BOUNDS.BADLANDS_X_START, WALL_THICKNESS); ctx.strokeRect(BIOME_BOUNDS.BADLANDS_X_START, BIOME_BOUNDS.BADLANDS_Y_START - WALL_THICKNESS / 2, WORLD_WIDTH - BIOME_BOUNDS.BADLANDS_X_START, WALL_THICKNESS); ctx.restore(); }
function drawResources() { const now = Date.now(); resources.forEach(res => { ctx.save(); ctx.translate(res.x, res.y); if (res.health < res.maxHealth && res.health > 0 && res.isAttackable) { const barWidth = res.radius * 1.5; const barHeight = 5; const barY = -res.radius - barHeight - 3; ctx.fillStyle = '#666'; ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight); let healthColor = res.type === 'tree' ? '#228B22' : (res.type === 'rock' ? '#A9A9A9' : '#DDD'); ctx.fillStyle = healthColor; ctx.fillRect(-barWidth / 2, barY, barWidth * (res.health / res.maxHealth), barHeight); } const baseColor = res.color || ITEM_DATA[res.type]?.color || 'magenta'; if (res.flashUntil > now) { ctx.fillStyle = (Math.floor(now / 50) % 2 === 0) ? '#FFFFFF' : baseColor; } else { ctx.fillStyle = baseColor; } if(res.type === 'workbench' || res.type === 'stone_block' || res.type === 'wood_plank' || res.type === 'icky_bed' || res.type === 'item_upgrader_t1') { ctx.fillRect(-res.radius, -res.radius, res.radius * 2, res.radius * 2); ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1; ctx.strokeRect(-res.radius, -res.radius, res.radius * 2, res.radius * 2); } else if (res.type === 'torch') { const stickHeight = res.radius * 3; const stickWidth = res.radius * 0.6; const flameHeight = res.radius * 1.5; ctx.fillStyle = ITEM_DATA['stick']?.color || '#B8860B'; ctx.fillRect(-stickWidth / 2, -stickHeight / 2 + flameHeight*0.4 , stickWidth, stickHeight); ctx.fillStyle = baseColor; ctx.beginPath(); ctx.ellipse(0, -stickHeight / 2, stickWidth * 1.2, flameHeight, 0, 0, Math.PI * 2); ctx.fill(); } else if (res.type === 'cactus') { const cactusWidth = res.radius * 0.6; const cactusHeight = res.radius * 2; ctx.fillStyle = baseColor; ctx.fillRect(-cactusWidth/2, -cactusHeight/2, cactusWidth, cactusHeight); ctx.fillRect(-cactusWidth*1.5, -cactusHeight*0.1, cactusWidth*2.5, cactusWidth*0.8); ctx.strokeStyle = 'darkgreen'; ctx.lineWidth=1; ctx.strokeRect(-cactusWidth/2, -cactusHeight/2, cactusWidth, cactusHeight); } else if (res.type === 'tree' || res.type === 'bone_tree') { ctx.beginPath(); ctx.arc(0, 0, res.radius, 0, Math.PI * 2); ctx.fillStyle = res.variant === 'bone' ? '#DDD' : baseColor; ctx.fill(); ctx.fillStyle = res.variant === 'bone' ? '#999' : '#A0522D'; const trunkWidth = res.radius * 0.4; const trunkHeight = res.radius * 0.6; ctx.fillRect(-trunkWidth / 2, 0, trunkWidth, trunkHeight); if (res.variant === 'snowy') { ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath(); ctx.arc(0, -res.radius * 0.3, res.radius * 0.9, 0, Math.PI * 2); ctx.fill(); } } else { ctx.beginPath(); ctx.arc(0, 0, res.radius, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }); }
function drawMonsters() { const now = Date.now(); monsters.forEach(mon => { ctx.save(); ctx.translate(mon.x, mon.y); if (mon.health < mon.maxHealth && mon.health > 0) { const barWidth = mon.radius * 1.5; const barHeight = 4; const barY = -mon.radius - barHeight - 2; ctx.fillStyle = '#550000'; ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight); ctx.fillStyle = '#FF0000'; ctx.fillRect(-barWidth / 2, barY, barWidth * (mon.health / mon.maxHealth), barHeight); } if (mon.flashUntil > now) { ctx.fillStyle = (Math.floor(now / 50) % 2 === 0) ? '#FFFFFF' : mon.color; } else { ctx.fillStyle = mon.color; } ctx.beginPath(); ctx.arc(0, 0, mon.radius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = "black"; ctx.lineWidth = 1; ctx.stroke(); ctx.restore(); }); }
function drawBosses() { bosses.forEach(boss => { if (boss.health <= 0) return; const now = Date.now(); ctx.save(); ctx.translate(boss.x, boss.y); if (boss.health < boss.maxHealth) { const barWidth = boss.radius * 1.8; const barHeight = 8; const barY = -boss.radius - barHeight - 5; ctx.fillStyle = '#440000'; ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight); ctx.fillStyle = '#FF3333'; ctx.fillRect(-barWidth / 2, barY, barWidth * (boss.health / boss.maxHealth), barHeight); ctx.strokeStyle = 'black'; ctx.lineWidth=1; ctx.strokeRect(-barWidth / 2, barY, barWidth, barHeight); } ctx.fillStyle = '#776B5D'; ctx.beginPath(); ctx.arc(0, 0, boss.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.ellipse(-boss.radius*0.4, -boss.radius*0.3, boss.radius*0.3, boss.radius*0.5, Math.PI/4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(boss.radius*0.3, boss.radius*0.4, boss.radius*0.4, boss.radius*0.2, -Math.PI/6, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#3A3127'; ctx.lineWidth = 3; ctx.stroke(); const armRadius = boss.radius * 0.3; const armDist = boss.radius + armRadius * 0.8; let leftArmAngle = boss.angle - Math.PI / 1.5; let rightArmAngle = boss.angle + Math.PI / 1.5; if (boss.state === 'attacking_hit') { const progress = boss.attackAnimationTimer / ATTACK_DURATION; rightArmAngle = boss.angle + Math.PI / 1.5 + Math.sin(progress * Math.PI) * 1.5; } else if (boss.state === 'attacking_smash') { const progress = Math.min(1, boss.attackAnimationTimer / BOSS_SMASH_WINDUP); leftArmAngle = boss.angle - Math.PI / 1.5 - progress * Math.PI * 0.8; rightArmAngle = boss.angle + Math.PI / 1.5 + progress * Math.PI * 0.8; } else if (boss.state === 'attacking_spin') { const progress = boss.attackAnimationTimer / BOSS_SPIN_DURATION; const spinAngleOffset = progress * Math.PI * 4; leftArmAngle = boss.angle + spinAngleOffset - Math.PI / 1.5; rightArmAngle = boss.angle + spinAngleOffset + Math.PI / 1.5; } ctx.fillStyle = '#8B4513'; const leftArmX = Math.cos(leftArmAngle) * armDist; const leftArmY = Math.sin(leftArmAngle) * armDist; ctx.beginPath(); ctx.arc(leftArmX, leftArmY, armRadius, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#696969'; const rightArmX = Math.cos(rightArmAngle) * armDist; const rightArmY = Math.sin(rightArmAngle) * armDist; ctx.beginPath(); ctx.arc(rightArmX, rightArmY, armRadius*1.1, 0, Math.PI*2); ctx.fill(); ctx.stroke(); if (boss.state === 'attacking_smash' && boss.attackAnimationTimer >= BOSS_SMASH_WINDUP) { ctx.save(); const effectProgress = (boss.attackAnimationTimer - BOSS_SMASH_WINDUP) / BOSS_SMASH_EFFECT_DURATION; ctx.globalAlpha = 1.0 - effectProgress; ctx.strokeStyle = 'red'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(0, 0, BOSS_SMASH_RANGE, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); } if (boss.state === 'attacking_spin') { ctx.save(); ctx.globalAlpha = 0.5; ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, BOSS_SPIN_RANGE - 5, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, BOSS_SPIN_RANGE - 15, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); } ctx.restore(); }); }
function drawDroppedItems() { ctx.save(); droppedItems.forEach(item => { const itemData = ITEM_DATA[item.type]; if (!itemData) return; ctx.save(); ctx.translate(item.x, item.y); ctx.fillStyle = itemData.color || '#FFFFFF'; ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 1; const size = item.radius * 1.8; switch (itemData.shape) { case 'line': ctx.beginPath(); ctx.moveTo(-size * 0.7, 0); ctx.lineTo(size * 0.7, 0); ctx.lineWidth = 3; ctx.stroke(); break; case 'rect': ctx.fillRect(-size / 2, -size / 2, size, size); ctx.strokeRect(-size / 2, -size / 2, size, size); break; case 'torch': const stickH = size * 1.2; const stickW = size * 0.2; const flameH = size * 0.6; ctx.fillStyle = ITEM_DATA['stick']?.color || '#B8860B'; ctx.fillRect(-stickW/2, -stickH/2+flameH*0.4, stickW, stickH); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.ellipse(0, -stickH/2, stickW*1.2, flameH, 0,0,Math.PI*2); ctx.fill(); break; case 'sword': const swordH = size * 1.5; const swordW = size * 0.2; const guardW = size * 0.5; ctx.fillStyle = '#444'; ctx.fillRect(-swordW*1.2, swordH*0.2, swordW*2.4, swordH*0.2); ctx.fillStyle = '#888'; ctx.fillRect(-guardW/2, swordH*0.1, guardW, swordW*2); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.moveTo(0, -swH*0.4); ctx.lineTo(-swW, swH*0.1); ctx.lineTo(swW, swH*0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case 'axe': case 'pickaxe': const handleH = size * 1.4; const handleW = size * 0.2; const headW = size * 0.7; const headH = size*0.5; ctx.fillStyle = ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-handleW/2, -handleH/2+headH/2, handleW, handleH); ctx.strokeRect(-handleW/2, -handleH/2+headH/2, handleW, handleH); ctx.fillStyle = itemData.color; ctx.fillRect(-headW/2, -handleH/2, headW, headH); ctx.strokeRect(-headW/2, -handleH/2, headW, headH); break; case 'bow': ctx.beginPath(); ctx.moveTo(0, -size * 0.6); ctx.quadraticCurveTo(-size * 0.7, 0, 0, size * 0.6); ctx.quadraticCurveTo(size * 0.7, 0, 0, -size * 0.6); ctx.moveTo(-size*0.1, -size*0.5); ctx.lineTo(-size*0.1, size*0.5); ctx.lineWidth = 1; ctx.strokeStyle = '#eee'; ctx.stroke(); ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke(); ctx.fill(); break; case 'cactus': const cW = size * 0.4; const cH = size * 1.3; ctx.fillRect(-cW/2,-cH/2, cW, cH); ctx.fillRect(-cW*1.2, -cH*0.1, cW*2.4, cW*0.6); ctx.strokeStyle='darkgreen'; ctx.strokeRect(-cW/2,-cH/2, cW, cH); break; case 'circle': default: ctx.beginPath(); ctx.arc(0, 0, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); break; } ctx.restore(); }); ctx.restore(); }
function drawPlayer() { ctx.save(); ctx.translate(player.x, player.y); ctx.fillStyle = '#87CEEB'; ctx.beginPath(); ctx.arc(0, 0, player.radius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#4682B4'; ctx.lineWidth = 2; ctx.stroke(); let handBaseAngle = player.angle; let handDist = HAND_DISTANCE; let currentHandAngle = handBaseAngle; let rightHandRelativeAngle = handBaseAngle + Math.PI / 4; if (player.isAttacking) { const attackProgress = (Date.now() - player.attackTimer) / ATTACK_DURATION; const swing = Math.sin(attackProgress * Math.PI) * ATTACK_SWING_ARC; currentHandAngle = handBaseAngle + swing - ATTACK_SWING_ARC / 2; rightHandRelativeAngle = currentHandAngle + Math.PI / 4; } else if (player.isInteracting) { const interactProgress = (Date.now() - player.interactTimer) / INTERACT_DURATION; const pulse = Math.sin(interactProgress * Math.PI) * 5; handDist += pulse; currentHandAngle = handBaseAngle; rightHandRelativeAngle = currentHandAngle + Math.PI / 4; } const handAngleOffset = Math.PI / 4; const leftHandX = Math.cos(currentHandAngle - handAngleOffset) * handDist; const leftHandY = Math.sin(currentHandAngle - handAngleOffset) * handDist; const rightHandX = Math.cos(currentHandAngle + handAngleOffset) * handDist; const rightHandY = Math.sin(currentHandAngle + handAngleOffset) * handDist; ctx.fillStyle = '#FFDAB9'; ctx.beginPath(); ctx.arc(leftHandX, leftHandY, LIMB_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(rightHandX, rightHandY, LIMB_RADIUS, 0, Math.PI * 2); ctx.fill(); if (player.equippedItemType) { const itemData = ITEM_DATA[player.equippedItemType]; if (itemData) { ctx.save(); const itemVisualSize = 18; const itemDist = handDist + LIMB_RADIUS - itemVisualSize * 0.1; const itemX = Math.cos(rightHandRelativeAngle) * itemDist; const itemY = Math.sin(rightHandRelativeAngle) * itemDist; ctx.translate(itemX, itemY); ctx.rotate(player.angle); ctx.fillStyle = itemData.color; ctx.strokeStyle = 'black'; ctx.lineWidth = 1; switch (itemData.shape) { case 'line': ctx.beginPath(); ctx.moveTo(0, -itemVisualSize*0.6); ctx.lineTo(0, itemVisualSize*0.6); ctx.lineWidth = 3; ctx.stroke(); break; case 'rect': ctx.fillRect(-itemVisualSize*0.4, -itemVisualSize*0.4, itemVisualSize*0.8, itemVisualSize*0.8); ctx.strokeRect(-itemVisualSize*0.4, -itemVisualSize*0.4, itemVisualSize*0.8, itemVisualSize*0.8); break; case 'torch': const sH=itemVisualSize*1.0, sW=itemVisualSize*0.2, fH=itemVisualSize*0.5; ctx.fillStyle=ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-sW/2, sH*0.1, sW, sH*0.9); ctx.fillStyle=itemData.color; ctx.beginPath(); ctx.ellipse(0, -sH*0.25, sW*1.5, fH, 0,0,Math.PI*2); ctx.fill(); break; case 'sword': const swH=itemVisualSize*1.3, swW=itemVisualSize*0.15, gW=itemVisualSize*0.4; ctx.fillStyle = '#444'; ctx.fillRect(-swW*1.2, swH*0.2, swW*2.4, swH*0.2); ctx.fillStyle = '#888'; ctx.fillRect(-gW/2, swH*0.1, gW, swW*2); ctx.fillStyle = itemData.color; ctx.beginPath(); ctx.moveTo(0, -swH*0.4); ctx.lineTo(-swW, swH*0.1); ctx.lineTo(swW, swH*0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case 'axe': case 'pickaxe': const hH=itemVisualSize*1.2, hW=itemVisualSize*0.15, hdW=itemVisualSize*0.6, hdH=itemVisualSize*0.4; ctx.fillStyle = ITEM_DATA['stick']?.color||'#B8860B'; ctx.fillRect(-hW/2, -hH/2+hdH/2, hW, hH); ctx.strokeRect(-hW/2, -hH/2+hdH/2, hW, hH); ctx.fillStyle = itemData.color; ctx.fillRect(-hdW/2, -hH/2, hdW, hdH); ctx.strokeRect(-hdW/2, -hH/2, hdW, hdH); break; case 'bow': ctx.rotate(-Math.PI / 4); ctx.beginPath(); ctx.moveTo(0, -itemVisualSize*0.7); ctx.quadraticCurveTo(-itemVisualSize*0.8, 0, 0, itemVisualSize*0.7); ctx.quadraticCurveTo(itemVisualSize*0.8, 0, 0, -itemVisualSize*0.7); ctx.moveTo(-itemVisualSize*0.1, -itemVisualSize*0.6); ctx.lineTo(-itemVisualSize*0.1, itemVisualSize*0.6); ctx.lineWidth = 1.5; ctx.strokeStyle = '#eee'; ctx.stroke(); ctx.lineWidth = 2.5; ctx.strokeStyle = 'black'; ctx.stroke(); ctx.fill(); break; case 'circle': default: ctx.beginPath(); ctx.arc(0, 0, itemVisualSize*0.4, 0, Math.PI*2); ctx.fill(); ctx.stroke(); break; } ctx.restore(); } } ctx.restore(); }

function draw() {
    // 1. Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 2. Apply Camera Transformation
    ctx.save();
    ctx.translate(canvas.width / 2 - cameraX, canvas.height / 2 - cameraY);

    // 3. Draw Base World Elements
    drawWorldBackground();
    drawBiomeWalls(); // Draw Walls
    drawResources();
    drawMonsters();
    drawBosses();
    drawDroppedItems();
    drawPlayer();

    // 4. Apply Lighting/Darkness Effect (Additive Method)
    if (currentNightOpacity > 0.01) {
        ctx.save(); // Save world coordinate state before light/dark
        // --- Draw Darkness Overlay ---
        ctx.fillStyle = '#00001a'; ctx.globalAlpha = currentNightOpacity; ctx.fillRect(cameraX - canvas.width / 2, cameraY - canvas.height / 2, canvas.width, canvas.height); ctx.globalAlpha = 1.0;
        // --- Add Light Sources (Additive) ---
        ctx.globalCompositeOperation = 'lighter';
        // Draw Torch Lights
        resources.forEach(res => { if (res.isPlaced && res.lightRadius && res.lightRadius > 0 && res.type === 'torch') { const gradient = ctx.createRadialGradient(res.x, res.y, 0, res.x, res.y, res.lightRadius); const torchBrightness = 0.6; gradient.addColorStop(0, `rgba(255, 190, 120, ${torchBrightness})`); gradient.addColorStop(0.6, `rgba(200, 100, 50, ${torchBrightness * 0.5})`); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(res.x, res.y, res.lightRadius, 0, Math.PI * 2); ctx.fill(); } });
        // Draw Lava Light
        lavaPools.forEach(p => { if (p.lightRadius && p.lightRadius > 0) { const lavaBrightness = p.lightOpacity || 0.8; const lavaGradient = ctx.createLinearGradient(p.x, p.y, p.x + p.width, p.y); lavaGradient.addColorStop(0, `rgba(255, 80, 0, ${lavaBrightness * 0.6})`); lavaGradient.addColorStop(0.5, `rgba(255, 140, 0, ${lavaBrightness * 0.7})`); lavaGradient.addColorStop(1, `rgba(255, 80, 0, ${lavaBrightness * 0.6})`); ctx.fillStyle = lavaGradient; ctx.fillRect(p.x, p.y, p.width, p.height); } });
        // Draw Player Held Torch Light
        if (player.equippedItemType === 'torch') { const torchData = ITEM_DATA['torch']; if (torchData && torchData.lightRadius > 0) { const plrLightRadius = torchData.lightRadius; const gradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, plrLightRadius); const playerTorchBrightness = 0.65; gradient.addColorStop(0, `rgba(255, 190, 120, ${playerTorchBrightness})`); gradient.addColorStop(0.6, `rgba(200, 100, 50, ${playerTorchBrightness * 0.5})`); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(player.x, player.y, plrLightRadius, 0, Math.PI * 2); ctx.fill(); } }
        ctx.restore(); // Restore composite operation and alpha
    }

    // 5. Restore Camera Transformation
    ctx.restore();

    // 6. Draw UI Elements (HTML/CSS)
}


// --- Game Loop ---
let lastTime = 0;
function gameLoop(timestamp) { const deltaTime = timestamp - lastTime; lastTime = timestamp; if (!isGameOver) { update(deltaTime || 0); } draw(); requestAnimationFrame(gameLoop); }

// --- Start Game ---
createWalls(); // Create wall data before spawning
spawnInitialResources();
spawnInitialMonsters();
spawnBosses();
// Give Starting Item
player.hotbarSlots[0] = { type: 'wood_sword', count: 1 };

selectHotbar(0);
updateMainHotbarVisuals();
updateEquippedItem();
clampCamera();
updateUI();
requestAnimationFrame(gameLoop);